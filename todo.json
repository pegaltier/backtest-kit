{
    "wiki": {
        "wikis": {
            "en": {
                "metadata": {
                    "repo_name": "gitlab.com/tpetrtadi/backtest-kit-master",
                    "commit_hash": "9fa7f401",
                    "generated_at": "2025-12-14T14:04:31.626206",
                    "config": null,
                    "config_source": "none"
                },
                "pages": [
                    {
                        "page_plan": {
                            "id": "1",
                            "title": "Overview"
                        },
                        "content": "# Overview\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [assets/uml.svg](assets/uml.svg)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [docs/classes/WalkerCommandService.md](docs/classes/WalkerCommandService.md)\n- [docs/interfaces/BacktestStatistics.md](docs/interfaces/BacktestStatistics.md)\n- [docs/interfaces/IStrategyCallbacks.md](docs/interfaces/IStrategyCallbacks.md)\n- [docs/interfaces/LiveStatistics.md](docs/interfaces/LiveStatistics.md)\n- [docs/internals.md](docs/internals.md)\n- [docs/types/IStrategyTickResult.md](docs/types/IStrategyTickResult.md)\n- [docs/uml.puml](docs/uml.puml)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [scripts/uml.mjs](scripts/uml.mjs)\n- [src/interfaces/Heatmap.interface.ts](src/interfaces/Heatmap.interface.ts)\n- [test/e2e/defend.test.mjs](test/e2e/defend.test.mjs)\n- [test/e2e/risk.test.mjs](test/e2e/risk.test.mjs)\n- [test/index.mjs](test/index.mjs)\n- [test/mock/getMockCandles.mjs](test/mock/getMockCandles.mjs)\n- [test/spec/heat.test.mjs](test/spec/heat.test.mjs)\n- [test/spec/list.test.mjs](test/spec/list.test.mjs)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis document provides a high-level introduction to the **backtest-kit** framework, a production-ready TypeScript system for backtesting and live trading cryptocurrency strategies. The framework is designed to enable seamless transition between historical simulation and real-time execution with identical code, while providing crash-safe persistence, comprehensive validation, and AI-powered strategy optimization.\n\nThis overview covers the framework's purpose, core capabilities, architectural layers, and execution modes. For detailed information on specific subsystems:\n- Core concepts (signals, execution contexts, events) - see [Core Concepts](#2)\n- Detailed architecture (DI, services, clients) - see [System Architecture](#3)\n- Strategy development - see [Strategy System](#4)\n- Execution mode implementations - see [Execution Modes (Detailed)](#5)\n- Data integration - see [Data and Exchanges](#6)\n- Configuration - see [Configuration System](#7)\n- Reporting - see [Reporting and Analytics](#8)\n\n**Sources**: [README.md:1-26](), [docs/internals.md:1-13](), [package.json:1-26]()\n\n---\n\n## Core Features\n\nThe framework provides seven major feature categories:\n\n| Feature Category | Description | Key Components |\n|-----------------|-------------|----------------|\n| **Production-Ready Execution** | Seamless switch between backtest/live modes with identical strategy code | `Backtest`, `Live` classes |\n| **Crash-Safe Persistence** | Atomic JSON file writes with automatic state recovery | `PersistSignalAdapter`, `waitForInit()` |\n| **Validation System** | Checks signals for TP/SL logic, risk/reward ratios, portfolio limits | `addRisk()`, validation services |\n| **Memory-Efficient Streaming** | Async generator architecture for processing large datasets | `BacktestLogicPrivateService`, `LiveLogicPrivateService` |\n| **AI Integration** | LLM-powered strategy generation via Ollama API | `Optimizer` class, `OptimizerTemplateService` |\n| **Event-Driven Monitoring** | Pub/sub system for signals, errors, progress, completion | `listenSignal*()`, emitter subjects |\n| **Risk Management** | Custom rules for position limits, time windows, multi-strategy coordination | `IRiskSchema`, `ClientRisk` |\n\n**Sources**: [README.md:15-26](), [docs/internals.md:14-26]()\n\n---\n\n## Execution Modes\n\nThe framework implements four distinct execution modes, each optimized for specific use cases:\n\n```mermaid\ngraph LR\n    subgraph \"Finite Modes\"\n        BT[\"Backtest<br/>Historical Simulation<br/>Fast Candle Processing\"]\n        WK[\"Walker<br/>Strategy Comparison<br/>Sequential A/B Testing\"]\n    end\n    \n    subgraph \"Infinite Modes\"\n        LV[\"Live<br/>Real-Time Trading<br/>Crash Recovery\"]\n    end\n    \n    subgraph \"Generative Modes\"\n        OPT[\"Optimizer<br/>LLM Code Generation<br/>Multi-Timeframe Analysis\"]\n    end\n    \n    BT --> |\"yields closed signals\"| RESULTS[\"Results\"]\n    WK --> |\"compares metrics\"| RESULTS\n    LV --> |\"yields opened/closed\"| RESULTS\n    OPT --> |\"generates .mjs files\"| CODE[\"Executable Code\"]\n```\n\n**Backtest Mode** (`Backtest.run()`, `Backtest.background()`):\n- Iterates through pre-generated timeframes sequentially\n- Fast candle processing with skip-to-close optimization\n- Generator yields closed signals for memory efficiency\n- Use case: Historical validation, strategy research\n\n**Live Mode** (`Live.run()`, `Live.background()`):\n- Infinite loop with `sleep(61 seconds)` between ticks\n- Atomic persistence via `PersistSignalAdapter` after each operation\n- `waitForInit()` recovers state from disk on restart\n- Use case: Real-time trading with crash safety\n\n**Walker Mode** (`Walker.run()`, `Walker.background()`):\n- Sequential execution of multiple backtests\n- Compares strategies by metrics (Sharpe ratio, max drawdown, etc.)\n- Tracks best strategy and best metric value\n- Use case: Strategy comparison, A/B testing\n\n**Optimizer Mode** (`Optimizer.run()`, `Optimizer.dump()`):\n- Fetches multi-timeframe historical data (1h, 30m, 15m, 1m)\n- Formats data for LLM consumption (Ollama API)\n- Generates complete executable `.mjs` files\n- Use case: AI-driven strategy development\n\nFor detailed implementation details, see [Execution Modes (Detailed)](#5).\n\n**Sources**: [README.md:33-167](), [docs/internals.md:54-82](), [src/classes/Backtest.ts](), [src/classes/Live.ts](), [src/classes/Walker.ts](), [src/classes/Optimizer.ts]()\n\n---\n\n## Key Components and Public API\n\n### Component Registration API\n\nThe framework uses a registration pattern for defining strategies, exchanges, data sources, and risk profiles:\n\n```mermaid\ngraph TD\n    USER[\"User Code\"] --> |\"addStrategy()\"| STRAT_SCHEMA[\"StrategySchemaService<br/>ToolRegistry Storage\"]\n    USER --> |\"addExchange()\"| EXCH_SCHEMA[\"ExchangeSchemaService<br/>Configuration Registry\"]\n    USER --> |\"addFrame()\"| FRAME_SCHEMA[\"FrameSchemaService<br/>Timeframe Definitions\"]\n    USER --> |\"addRisk()\"| RISK_SCHEMA[\"RiskSchemaService<br/>Validation Rules\"]\n    USER --> |\"addSizing()\"| SIZE_SCHEMA[\"SizingSchemaService<br/>Position Sizing Logic\"]\n    USER --> |\"addWalker()\"| WALK_SCHEMA[\"WalkerSchemaService<br/>Comparison Config\"]\n    USER --> |\"addOptimizer()\"| OPT_SCHEMA[\"OptimizerSchemaService<br/>Prompt Templates\"]\n    \n    STRAT_SCHEMA --> VAL[\"Validation Layer\"]\n    EXCH_SCHEMA --> VAL\n    FRAME_SCHEMA --> VAL\n    RISK_SCHEMA --> VAL\n    \n    VAL --> CONN[\"Connection Layer<br/>Memoized Clients\"]\n    CONN --> EXEC[\"Execution Layer<br/>Logic Services\"]\n```\n\n**Registration Functions** (exported from [src/lib/index.ts]()):\n- `addStrategy(IStrategySchema)` - Define signal generation logic and lifecycle callbacks\n- `addExchange(IExchangeSchema)` - Configure data source (CCXT integration, custom APIs)\n- `addFrame(IFrameSchema)` - Specify date range and interval for backtests\n- `addRisk(IRiskSchema)` - Set portfolio limits and validation rules\n- `addSizing(ISizingSchema)` - Configure position sizing methods (fixed, Kelly, ATR)\n- `addWalker(IWalkerSchema)` - Define strategy comparison configuration\n- `addOptimizer(IOptimizerSchema)` - Configure LLM prompt templates and data sources\n\n### Execution API\n\n```mermaid\ngraph LR\n    subgraph \"Synchronous Execution\"\n        RUN_BT[\"Backtest.run()<br/>AsyncGenerator\"]\n        RUN_LV[\"Live.run()<br/>AsyncGenerator\"]\n        RUN_WK[\"Walker.run()<br/>AsyncGenerator\"]\n        RUN_OPT[\"Optimizer.run()<br/>AsyncGenerator\"]\n    end\n    \n    subgraph \"Background Execution\"\n        BG_BT[\"Backtest.background()<br/>Fire and Forget\"]\n        BG_LV[\"Live.background()<br/>Fire and Forget\"]\n        BG_WK[\"Walker.background()<br/>Fire and Forget\"]\n    end\n    \n    RUN_BT --> |\"for await\"| CONSUME[\"User Consumption\"]\n    RUN_LV --> |\"for await\"| CONSUME\n    RUN_WK --> |\"for await\"| CONSUME\n    RUN_OPT --> |\"for await\"| CONSUME\n    \n    BG_BT --> |\"listenDoneBacktest()\"| EVENTS[\"Event Listeners\"]\n    BG_LV --> |\"listenDoneLive()\"| EVENTS\n    BG_WK --> |\"listenWalkerComplete()\"| EVENTS\n```\n\n**Execution Methods**:\n- `Backtest.run(symbol, context)` - Synchronous backtest with generator iteration\n- `Backtest.background(symbol, context)` - Fire-and-forget backtest with event listeners\n- `Live.run(symbol, context)` - Synchronous live execution\n- `Live.background(symbol, context)` - Background live execution\n- `Walker.run(symbol, context)` - Strategy comparison\n- `Optimizer.run(symbol, optimizerName)` - LLM strategy generation\n\n### Event Listener API\n\n```mermaid\ngraph TD\n    EMIT[\"Event Emitters<br/>(signalEmitter, errorEmitter, etc.)\"] --> Q[\"Queued Processing<br/>functools-kit\"]\n    Q --> L1[\"listenSignal()<br/>All Signals\"]\n    Q --> L2[\"listenSignalLive()<br/>Live Only\"]\n    Q --> L3[\"listenSignalBacktest()<br/>Backtest Only\"]\n    Q --> L4[\"listenError()<br/>Error Handling\"]\n    Q --> L5[\"listenRisk()<br/>Validation Rejections\"]\n    Q --> L6[\"listenPartialProfit()<br/>Profit Milestones\"]\n    Q --> L7[\"listenPartialLoss()<br/>Loss Milestones\"]\n    Q --> L8[\"listenDoneBacktest()<br/>Completion\"]\n    Q --> L9[\"listenWalkerComplete()<br/>Best Strategy\"]\n```\n\n**Event Listeners** (all use queued async processing):\n- `listenSignal(fn)` - All signal events (idle, opened, active, closed)\n- `listenSignalBacktest(fn)` - Backtest signals only\n- `listenSignalLive(fn)` - Live signals only\n- `listenSignalOnce(filter, fn)` - Single-execution with predicate filter\n- `listenError(fn)` - Background execution errors\n- `listenRisk(fn)` - Risk validation rejections\n- `listenPartialProfit(fn)` - Profit milestone tracking (10%, 20%, 30%, etc.)\n- `listenDoneBacktest(fn)` - Backtest completion\n- `listenWalkerComplete(fn)` - Walker final results\n\n**Sources**: [src/lib/index.ts](), [docs/internals.md:84-89](), [README.md:140-167]()\n\n---\n\n## Architectural Layers\n\nThe framework implements a five-layer architecture with clear separation of concerns:\n\n```mermaid\ngraph TB\n    subgraph \"Layer 1: Public API\"\n        API[\"Public Functions<br/>addStrategy, addExchange, addFrame<br/>Backtest.run, Live.run, Walker.run<br/>listenSignal, listenError\"]\n    end\n    \n    subgraph \"Layer 2: Orchestration (Execution Modes)\"\n        CMD_BT[\"BacktestCommandService<br/>Validation + Execution\"]\n        CMD_LV[\"LiveCommandService<br/>Validation + Execution\"]\n        CMD_WK[\"WalkerCommandService<br/>Validation + Execution\"]\n    end\n    \n    subgraph \"Layer 3: Service Layer (Dependency Injection)\"\n        LOGIC[\"Logic Services<br/>BacktestLogicPublicService<br/>BacktestLogicPrivateService<br/>LiveLogicPublicService<br/>LiveLogicPrivateService<br/>WalkerLogicPublicService<br/>WalkerLogicPrivateService\"]\n        GLOBAL[\"Global Services<br/>StrategyGlobalService<br/>RiskGlobalService<br/>SizingGlobalService<br/>PartialGlobalService<br/>OptimizerGlobalService\"]\n        CORE[\"Core Services<br/>StrategyCoreService<br/>ExchangeCoreService<br/>FrameCoreService\"]\n        CONN[\"Connection Services<br/>StrategyConnectionService<br/>ExchangeConnectionService<br/>FrameConnectionService<br/>RiskConnectionService<br/>SizingConnectionService<br/>PartialConnectionService<br/>OptimizerConnectionService\"]\n        VAL[\"Validation Services<br/>StrategyValidationService<br/>ExchangeValidationService<br/>FrameValidationService<br/>RiskValidationService<br/>ConfigValidationService\"]\n        SCHEMA[\"Schema Services<br/>StrategySchemaService<br/>ExchangeSchemaService<br/>FrameSchemaService<br/>RiskSchemaService<br/>WalkerSchemaService<br/>SizingSchemaService<br/>OptimizerSchemaService\"]\n    end\n    \n    subgraph \"Layer 4: Client Layer (Business Logic)\"\n        CLIENT[\"ClientStrategy<br/>ClientExchange<br/>ClientFrame<br/>ClientRisk<br/>ClientSizing<br/>ClientPartial<br/>ClientOptimizer\"]\n    end\n    \n    subgraph \"Layer 5: Persistence & Events\"\n        PERSIST[\"PersistSignalAdapter<br/>PersistScheduleAdapter<br/>PersistRiskAdapter<br/>PersistPartialAdapter\"]\n        EVENTS[\"signalEmitter<br/>signalLiveEmitter<br/>signalBacktestEmitter<br/>errorEmitter<br/>riskSubject<br/>partialProfitSubject\"]\n    end\n    \n    API --> CMD_BT\n    API --> CMD_LV\n    API --> CMD_WK\n    \n    CMD_BT --> LOGIC\n    CMD_LV --> LOGIC\n    CMD_WK --> LOGIC\n    \n    LOGIC --> CORE\n    LOGIC --> GLOBAL\n    CORE --> CONN\n    GLOBAL --> CONN\n    CONN --> SCHEMA\n    CONN --> CLIENT\n    VAL --> SCHEMA\n    \n    CLIENT --> PERSIST\n    CLIENT --> EVENTS\n    LOGIC --> EVENTS\n```\n\n### Layer Responsibilities\n\n**Layer 1 - Public API**:\n- User-facing functions exported from [src/lib/index.ts]()\n- Configuration registration (`addStrategy`, `addExchange`, etc.)\n- Execution triggers (`Backtest.run`, `Live.background`, etc.)\n- Event subscription (`listenSignal`, `listenError`, etc.)\n\n**Layer 2 - Orchestration**:\n- Command services: `BacktestCommandService`, `LiveCommandService`, `WalkerCommandService`\n- Validation coordination (ensures all required components are registered)\n- Delegates to Logic services for actual execution\n\n**Layer 3 - Service Layer**:\n- **Logic Services**: Public/private split for execution flow\n  - Public: Context setup and validation wrapper\n  - Private: Generator implementation with business logic\n- **Core Services**: Domain operations (strategy tick, exchange candles, frame timeframes)\n- **Connection Services**: Memoized client factory pattern (cache by `symbol:strategyName`)\n- **Schema Services**: ToolRegistry pattern for immutable configuration storage\n- **Validation Services**: Runtime existence checks with memoization\n- **Global Services**: Portfolio-level state management (risk tracking, partial tracking)\n\n**Layer 4 - Client Layer**:\n- Pure business logic implementations without DI\n- Prototype methods (not arrow functions) for memory efficiency\n- Classes: `ClientStrategy`, `ClientExchange`, `ClientFrame`, `ClientRisk`, `ClientSizing`, `ClientPartial`, `ClientOptimizer`\n\n**Layer 5 - Persistence & Events**:\n- Atomic JSON file writes via `PersistSignalAdapter` and related adapters\n- Pub/sub event system using `functools-kit` Subject\n- Queued async processing to prevent race conditions\n\nFor detailed architecture documentation, see [System Architecture](#3).\n\n**Sources**: [docs/internals.md:28-52](), [src/lib/index.ts](), [src/lib/services/](), [src/lib/clients/]()\n\n---\n\n## Dependency Injection System\n\nThe framework uses a custom DI container with Symbol-based keys and a centralized `backtest` aggregation object:\n\n```mermaid\ngraph TD\n    TYPES[\"types.ts<br/>Symbol Definitions<br/>TYPES.loggerService<br/>TYPES.strategyConnectionService<br/>etc.\"] --> PROVIDE[\"provide.ts<br/>Service Registration<br/>provide() calls\"]\n    PROVIDE --> BACKTEST[\"backtest object<br/>Singleton Export<br/>All services injected\"]\n    \n    BACKTEST --> CMD[\"Command Services<br/>backtestCommandService<br/>liveCommandService<br/>walkerCommandService\"]\n    BACKTEST --> LOGIC[\"Logic Services<br/>backtestLogicPublicService<br/>backtestLogicPrivateService<br/>etc.\"]\n    BACKTEST --> SCHEMA[\"Schema Services<br/>strategySchemaService<br/>exchangeSchemaService<br/>etc.\"]\n    BACKTEST --> VAL[\"Validation Services<br/>strategyValidationService<br/>exchangeValidationService<br/>etc.\"]\n    BACKTEST --> CONN[\"Connection Services<br/>strategyConnectionService<br/>exchangeConnectionService<br/>etc.\"]\n    BACKTEST --> CORE[\"Core Services<br/>strategyCoreService<br/>exchangeCoreService<br/>frameCoreService\"]\n    BACKTEST --> GLOBAL[\"Global Services<br/>strategyGlobalService<br/>riskGlobalService<br/>etc.\"]\n    BACKTEST --> MD[\"Markdown Services<br/>backtestMarkdownService<br/>liveMarkdownService<br/>etc.\"]\n```\n\n**Key DI Components**:\n- `types.ts` - Symbol-based service identifiers (e.g., `TYPES.strategyCoreService = Symbol.for(\"strategyCoreService\")`)\n- `provide.ts` - Service registration with factory functions\n- `backtest` object - Central service locator providing access to all services\n- Scoped contexts - `ExecutionContextService` and `MethodContextService` for nested context propagation\n\nFor detailed DI documentation, see [Dependency Injection System](#3.2).\n\n**Sources**: [src/lib/index.ts](), [src/lib/types.ts](), [src/lib/provide.ts](), [docs/internals.md:46-52]()\n\n---\n\n## Signal Lifecycle\n\nThe framework uses a type-safe discriminated union for signal states:\n\n```mermaid\nstateDiagram-v2\n    [*] --> idle: No active signal\n    idle --> scheduled: Limit order created\n    scheduled --> opened: Price reaches priceOpen\n    scheduled --> cancelled: TP/SL hit before activation\n    opened --> active: Market order filled\n    active --> closed: TP/SL/timeout reached\n    closed --> [*]\n    \n    note right of idle\n        action: \"idle\"\n        currentPrice: number\n    end note\n    \n    note right of scheduled\n        action: \"scheduled\"\n        IScheduledSignalRow\n        scheduledAt, priceOpen\n    end note\n    \n    note right of opened\n        action: \"opened\"\n        ISignalRow\n        pendingAt, priceOpen\n    end note\n    \n    note right of active\n        action: \"active\"\n        ISignalRow\n        Monitoring TP/SL\n    end note\n    \n    note right of closed\n        action: \"closed\"\n        ISignalRow + closeReason\n        PNL calculated\n    end note\n    \n    note right of cancelled\n        action: \"cancelled\"\n        IScheduledSignalRow\n        No position opened\n    end note\n```\n\n**Signal States**:\n- `idle` - No active signal, waiting for next signal generation\n- `scheduled` - Limit order created, waiting for price to reach `priceOpen`\n- `cancelled` - Scheduled signal cancelled (TP/SL hit before activation)\n- `opened` - Market order filled OR limit order activated, position now open\n- `active` - Position being monitored for TP/SL/timeout\n- `closed` - Position closed with `closeReason` (`take_profit`, `stop_loss`, `time_expired`)\n\nEach state is a discriminated union type with an `action` discriminator property, enabling TypeScript type narrowing. For detailed signal lifecycle documentation, see [Signal Lifecycle and State Machine](#2.1).\n\n**Sources**: [docs/internals.md:14-19](), [types.d.ts](), [src/lib/clients/ClientStrategy.ts]()\n\n---\n\n## Configuration System\n\nThe framework uses a global configuration object with economic viability validation:\n\n```mermaid\ngraph LR\n    USER[\"setConfig()\"] --> VAL[\"ConfigValidationService\"]\n    VAL --> |\"Validate slippage + fees\"| CHECK1[\"Economic Viability\"]\n    VAL --> |\"Calculate min TP distance\"| CHECK2[\"Minimum TP = slippage + fees + margin\"]\n    CHECK1 --> GLOBAL[\"GLOBAL_CONFIG\"]\n    CHECK2 --> GLOBAL\n    \n    GLOBAL --> USE1[\"Signal Validation\"]\n    GLOBAL --> USE2[\"PNL Calculation\"]\n    GLOBAL --> USE3[\"VWAP Candle Count\"]\n    GLOBAL --> USE4[\"Schedule Timeout\"]\n```\n\n**Key Configuration Parameters**:\n- `CC_PERCENT_SLIPPAGE` - Slippage percentage (default: 0.1%)\n- `CC_PERCENT_FEE` - Trading fee percentage (default: 0.1%)\n- `CC_AVG_PRICE_CANDLES_COUNT` - VWAP calculation window (default: 5 candles)\n- `CC_SCHEDULE_AWAIT_MINUTES` - Pending signal timeout (default: 120 minutes)\n- `CC_MIN_TAKE_PROFIT_DISTANCE` - Minimum TP distance (calculated from slippage + fees)\n- `CC_MIN_STOP_LOSS_DISTANCE` - Minimum SL distance\n- `CC_TICK_TTL` - Time between live ticks (default: 61 seconds)\n\nThe `ConfigValidationService` ensures that the combination of slippage and fees doesn't make trading economically unviable. For detailed configuration documentation, see [Configuration System](#7).\n\n**Sources**: [README.md:173-179](), [docs/internals.md:141-143](), [src/lib/services/validation/ConfigValidationService.ts]()\n\n---\n\n## Testing and Reliability\n\nThe framework includes 280+ tests covering validation, recovery, reports, and events:\n\n| Test Category | Coverage | Key Test Files |\n|--------------|----------|----------------|\n| **Signal Lifecycle** | Idle → opened → active → closed state transitions | [test/spec/backtest.test.mjs]() |\n| **Validation** | TP/SL logic, negative prices, timestamp checks | [test/spec/validation.test.mjs]() |\n| **PNL Calculation** | Fees (0.1%), slippage (0.1%), realistic simulations | [test/spec/pnl.test.mjs]() |\n| **Event System** | Listener coordination, Once variants with filters | [test/spec/event.test.mjs]() |\n| **Crash Recovery** | Atomic writes, waitForInit recovery | [test/e2e/restore.test.mjs]() |\n| **Risk Management** | Portfolio limits, symbol filters, price-based logic | [test/e2e/risk.test.mjs]() |\n| **Edge Cases** | Concurrent positions, same-candle activation/close | [test/e2e/defend.test.mjs]() |\n\n**Sources**: [README.md:180-182](), [test/index.mjs:1-45](), [docs/internals.md:115-132]()\n\n---\n\n## Use Cases\n\nThe framework is designed for:\n\n1. **Algorithmic Trading Development**\n   - Backtest validation on historical data\n   - Live deployment with identical code\n   - Real-time signal generation with ML models or technical indicators\n\n2. **Strategy Research**\n   - Multi-strategy comparison via Walker mode\n   - Statistical analysis (Sharpe ratio, max drawdown, win rate)\n   - Portfolio heatmaps for symbol-level performance\n\n3. **AI-Driven Optimization**\n   - LLM-powered strategy generation via Optimizer mode\n   - Multi-timeframe data analysis\n   - Automated code export\n\n4. **Risk Management**\n   - Portfolio-level position limits\n   - Multi-strategy coordination\n   - Custom validation rules (symbol filters, time windows, price ranges)\n\n5. **Educational Projects**\n   - Learning trading system architecture\n   - Understanding signal lifecycle\n   - Event-driven system design\n\n6. **Production Trading Bots**\n   - Crash-safe persistence\n   - Graceful shutdown (waits for position close)\n   - Real-time notifications via event listeners\n\n**Sources**: [docs/internals.md:104-113](), [README.md:1-26]()\n\n---\n\n## Technology Stack\n\nThe framework is built on:\n\n| Technology | Purpose | Version |\n|-----------|---------|---------|\n| **TypeScript** | Type-safe development | 5.0+ |\n| **di-kit** | Dependency injection container | 1.0.18 |\n| **di-scoped** | Scoped context propagation | 1.0.20 |\n| **functools-kit** | Subject pattern, queued async, memoization | 1.0.94 |\n| **get-moment-stamp** | Timestamp utilities | 1.1.1 |\n| **CCXT** | Exchange data integration (peer dependency) | - |\n| **Ollama** | LLM API integration (peer dependency) | - |\n\n**Sources**: [package.json:74-79](), [demo/optimization/package.json:8-13]()"
                    },
                    {
                        "page_plan": {
                            "id": "2",
                            "title": "Core Concepts"
                        },
                        "content": "# Core Concepts\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [assets/uml.svg](assets/uml.svg)\n- [docs/classes/WalkerCommandService.md](docs/classes/WalkerCommandService.md)\n- [docs/interfaces/BacktestStatistics.md](docs/interfaces/BacktestStatistics.md)\n- [docs/interfaces/IStrategyCallbacks.md](docs/interfaces/IStrategyCallbacks.md)\n- [docs/interfaces/LiveStatistics.md](docs/interfaces/LiveStatistics.md)\n- [docs/internals.md](docs/internals.md)\n- [docs/types/IStrategyTickResult.md](docs/types/IStrategyTickResult.md)\n- [docs/uml.puml](docs/uml.puml)\n- [scripts/uml.mjs](scripts/uml.mjs)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\nThis document explains the three fundamental abstractions that underpin the entire backtest-kit framework: **signals**, **execution contexts**, and **event-driven communication**. Understanding these concepts is essential for working with any part of the system, as they form the foundation for all execution modes, strategy definitions, and data flows.\n\nFor detailed information about specific signal states and transitions, see [Signal Lifecycle and State Machine](#2.1). For information about how execution modes utilize these concepts, see [Execution Modes Overview](#2.2). For comprehensive coverage of the event system's capabilities, see [Event-Driven Architecture](#2.3).\n\n---\n\n## Signal Lifecycle and State Machine\n\nThe framework uses a **discriminated union type system** to represent trading signals as they progress through their lifecycle. All signal states are captured in the `IStrategyTickResult` type, which is a union of six distinct result types, each identified by an `action` discriminator field.\n\n### Signal State Types\n\n| State | Type | Description |\n|-------|------|-------------|\n| `idle` | `IStrategyTickResultIdle` | No active signal, strategy is monitoring for entry opportunities |\n| `scheduled` | `IStrategyTickResultScheduled` | Signal created with `priceOpen` specified, waiting for price to reach entry point |\n| `opened` | `IStrategyTickResultOpened` | Signal just activated at `priceOpen`, position is now open |\n| `active` | `IStrategyTickResultActive` | Position is being monitored against TP/SL/time conditions |\n| `closed` | `IStrategyTickResultClosed` | Position closed with final PnL calculation |\n| `cancelled` | `IStrategyTickResultCancelled` | Scheduled signal cancelled without opening position |\n\nThe discriminated union pattern enables **type-safe state handling** throughout the codebase. TypeScript's type narrowing automatically provides the correct type when checking `result.action === \"closed\"`, ensuring that only valid fields for that state are accessible.\n\n```mermaid\ngraph LR\n    Idle[\"idle<br/>(action: 'idle')\"]\n    Scheduled[\"scheduled<br/>(action: 'scheduled')\"]\n    Opened[\"opened<br/>(action: 'opened')\"]\n    Active[\"active<br/>(action: 'active')\"]\n    Closed[\"closed<br/>(action: 'closed')\"]\n    Cancelled[\"cancelled<br/>(action: 'cancelled')\"]\n    \n    Idle -->|\"getSignal returns<br/>ISignalDto with priceOpen\"| Scheduled\n    Idle -->|\"getSignal returns<br/>ISignalDto without priceOpen\"| Opened\n    Scheduled -->|\"currentPrice reaches priceOpen\"| Opened\n    Scheduled -->|\"CC_SCHEDULE_AWAIT_MINUTES exceeded\"| Cancelled\n    Opened -->|\"signal persisted,<br/>monitoring begins\"| Active\n    Active -->|\"TP/SL/time condition met\"| Closed\n    Active -->|\"continue monitoring\"| Active\n```\n\n**Diagram: Signal State Transition Flow**\n\n### Core Signal Interfaces\n\nThe `ISignalDto` interface represents the **data transfer object** returned from strategy's `getSignal` callback:\n\n- **`position`**: `\"long\"` or `\"short\"` direction\n- **`priceOpen`** (optional): If specified, creates scheduled signal; if omitted, opens immediately at current VWAP\n- **`priceTakeProfit`**: Exit price for profitable close\n- **`priceStopLoss`**: Exit price for loss-limiting close\n- **`minuteEstimatedTime`**: Expected duration before `time_expired` close reason\n\nAfter validation, the signal becomes an `ISignalRow` with auto-generated fields:\n\n- **`id`**: UUID v4 identifier (auto-generated if not provided)\n- **`exchangeName`**, **`strategyName`**: Routing information\n- **`scheduledAt`**, **`pendingAt`**: Timing metadata\n- **`symbol`**: Trading pair (e.g., `\"BTCUSDT\"`)\n\n**Sources:** [types.d.ts:855-905](), [types.d.ts:976-1000](), [docs/internals.md:14-19]()\n\n---\n\n## Execution Contexts\n\nThe framework uses **two scoped context services** to propagate execution parameters implicitly throughout the call stack, eliminating the need for explicit parameter passing. Both services are implemented using `di-scoped` for async-safe context isolation.\n\n### ExecutionContextService\n\n`ExecutionContextService` provides **runtime execution parameters** for operations that need to know *when* and *where* they're executing:\n\n| Field | Type | Purpose |\n|-------|------|---------|\n| `symbol` | `string` | Trading pair (e.g., `\"BTCUSDT\"`) |\n| `when` | `Date` | Current timestamp for operation |\n| `backtest` | `boolean` | `true` for historical simulation, `false` for live trading |\n\nThis context is set at the **innermost execution level** (within each tick) and is used by:\n- `ClientExchange.getCandles()` and `getNextCandles()` to determine time boundaries\n- `ClientStrategy` to calculate VWAP and compare against TP/SL conditions\n- Persistence adapters to generate filenames (includes `backtest` flag)\n\n```typescript\n// Context propagation pattern\nExecutionContextService.runInContext(\n  async () => {\n    // Inside this callback, context is automatically available\n    const candles = await exchange.getCandles(symbol, \"1m\", 5);\n    // getCandles internally reads: ExecutionContextService.context.when\n  },\n  { symbol: \"BTCUSDT\", when: new Date(), backtest: true }\n);\n```\n\n### MethodContextService\n\n`MethodContextService` provides **schema routing information** for operations that need to retrieve registered configurations:\n\n| Field | Type | Purpose |\n|-------|------|---------|\n| `strategyName` | `string` | Which strategy schema to use |\n| `exchangeName` | `string` | Which exchange schema to use |\n| `frameName` | `string` | Which frame schema to use (empty for live mode) |\n\nThis context is set at the **outermost execution level** (around entire run calls) and is used by:\n- Connection services to retrieve memoized client instances by schema name\n- Schema services to look up registered configurations\n- Validation services to check existence of referenced schemas\n\n```mermaid\ngraph TB\n    subgraph \"Public API\"\n        BacktestRun[\"Backtest.run(symbol, context)\"]\n        LiveRun[\"Live.run(symbol, context)\"]\n    end\n    \n    subgraph \"MethodContext Layer\"\n        MethodCtx[\"MethodContextService.runAsyncIterator<br/>{strategyName, exchangeName, frameName}\"]\n    end\n    \n    subgraph \"Logic Loop\"\n        TimeframeLoop[\"For each timeframe\"]\n        InfiniteLoop[\"While true\"]\n    end\n    \n    subgraph \"ExecutionContext Layer\"\n        ExecCtx[\"ExecutionContextService.runInContext<br/>{symbol, when, backtest}\"]\n    end\n    \n    subgraph \"Core Operations\"\n        Tick[\"StrategyCoreService.tick()\"]\n        GetCandles[\"ExchangeCoreService.getCandles()\"]\n        GetAvgPrice[\"ClientExchange.getAveragePrice()\"]\n    end\n    \n    BacktestRun --> MethodCtx\n    LiveRun --> MethodCtx\n    MethodCtx --> TimeframeLoop\n    MethodCtx --> InfiniteLoop\n    TimeframeLoop --> ExecCtx\n    InfiniteLoop --> ExecCtx\n    ExecCtx --> Tick\n    ExecCtx --> GetCandles\n    GetCandles --> GetAvgPrice\n```\n\n**Diagram: Context Propagation Through Execution Stack**\n\nThe two contexts are **nested** to achieve separation of concerns:\n- **MethodContext** (outer): Determines *which* strategy/exchange/frame to use (immutable per run)\n- **ExecutionContext** (inner): Determines *when* and *where* to execute (changes per tick)\n\n**Sources:** [types.d.ts:242-285](), [types.d.ts:504-544](), [src/index.ts:159-160](), [docs/internals.md:47-51]()\n\n---\n\n## Event-Driven Architecture\n\nThe framework implements a **comprehensive pub/sub event system** using `functools-kit`'s `Subject` class. All events flow through typed emitters that provide decoupled communication between system components.\n\n### Core Event Emitters\n\nThe framework exposes 18 specialized event emitters organized by domain:\n\n| Emitter | Type | Purpose |\n|---------|------|---------|\n| `signalEmitter` | `Subject<IStrategyTickResult>` | All signals (backtest + live) |\n| `signalLiveEmitter` | `Subject<IStrategyTickResult>` | Live trading signals only |\n| `signalBacktestEmitter` | `Subject<IStrategyTickResult>` | Backtest signals only |\n| `errorEmitter` | `Subject<Error>` | Recoverable errors during execution |\n| `exitEmitter` | `Subject<Error>` | Fatal errors requiring process termination |\n| `doneLiveSubject` | `Subject<DoneContract>` | Live execution completion |\n| `doneBacktestSubject` | `Subject<DoneContract>` | Backtest execution completion |\n| `doneWalkerSubject` | `Subject<DoneContract>` | Walker execution completion |\n| `progressBacktestEmitter` | `Subject<ProgressBacktestContract>` | Backtest progress updates (frames processed) |\n| `progressWalkerEmitter` | `Subject<ProgressWalkerContract>` | Walker progress updates (strategies tested) |\n| `progressOptimizerEmitter` | `Subject<ProgressOptimizerContract>` | Optimizer progress updates (sources fetched) |\n| `performanceEmitter` | `Subject<PerformanceContract>` | Execution timing metrics for profiling |\n| `walkerEmitter` | `Subject<WalkerContract>` | Walker strategy results (intermediate) |\n| `walkerCompleteSubject` | `Subject<IWalkerResults>` | Walker final results with best strategy |\n| `walkerStopSubject` | `Subject<WalkerStopContract>` | Walker cancellation requests |\n| `validationSubject` | `Subject<Error>` | Risk validation errors |\n| `partialProfitSubject` | `Subject<PartialProfitContract>` | Profit milestone events (10%, 20%, ...) |\n| `partialLossSubject` | `Subject<PartialLossContract>` | Loss milestone events (-10%, -20%, ...) |\n| `riskSubject` | `Subject<RiskContract>` | Risk rejection events |\n\n### Queued Async Processing\n\nAll public listener functions wrap callbacks with `queued()` from `functools-kit` to ensure **sequential event processing**. Even when callbacks involve asynchronous operations, events are processed one at a time in the order they were emitted, preventing race conditions and maintaining deterministic behavior.\n\n```typescript\n// Internal implementation pattern\nexport function listenSignal(fn: (event: IStrategyTickResult) => void) {\n  return signalEmitter.subscribe(queued(async (event) => fn(event)));\n}\n```\n\nThis guarantees that even if `fn` performs async work (database writes, API calls), the next event won't start processing until the current one completes.\n\n### Event Flow Pattern\n\n```mermaid\ngraph TB\n    subgraph \"Event Producers\"\n        CS[\"ClientStrategy<br/>(tick/backtest methods)\"]\n        CR[\"ClientRisk<br/>(checkSignal rejection)\"]\n        CP[\"ClientPartial<br/>(profit/loss methods)\"]\n        Logic[\"Logic Services<br/>(progress/completion)\"]\n    end\n    \n    subgraph \"Event Emitters\"\n        SignalAll[\"signalEmitter\"]\n        SignalLive[\"signalLiveEmitter\"]\n        SignalBT[\"signalBacktestEmitter\"]\n        Error[\"errorEmitter\"]\n        Risk[\"riskSubject\"]\n        Partial[\"partialProfitSubject<br/>partialLossSubject\"]\n        Done[\"doneLiveSubject<br/>doneBacktestSubject\"]\n        Progress[\"progressBacktestEmitter\"]\n    end\n    \n    subgraph \"Public Listeners\"\n        ListenSig[\"listenSignal(fn)<br/>(queued processing)\"]\n        ListenErr[\"listenError(fn)<br/>(queued processing)\"]\n        ListenDone[\"listenDoneLive(fn)<br/>(queued processing)\"]\n        ListenRisk[\"listenRisk(fn)<br/>(queued processing)\"]\n    end\n    \n    subgraph \"Internal Consumers\"\n        MD[\"Markdown Services<br/>(report generation)\"]\n    end\n    \n    CS -->|\"emit tick result\"| SignalAll\n    SignalAll -->|\"filter by backtest flag\"| SignalLive\n    SignalAll -->|\"filter by backtest flag\"| SignalBT\n    CR -->|\"emit rejection\"| Risk\n    CP -->|\"emit milestone\"| Partial\n    Logic -->|\"emit completion\"| Done\n    Logic -->|\"emit progress\"| Progress\n    \n    SignalAll --> ListenSig\n    SignalAll --> MD\n    Error --> ListenErr\n    Done --> ListenDone\n    Risk --> ListenRisk\n```\n\n**Diagram: Event System Data Flow with Queued Processing**\n\n### Filter and Once Patterns\n\nListener functions come in **three variants**:\n\n1. **Standard listeners**: Subscribe indefinitely until manually unsubscribed\n   ```typescript\n   const unsub = listenSignal((event) => { /* handle */ });\n   unsub(); // stop listening\n   ```\n\n2. **Once listeners with filter**: Execute callback once when predicate matches, then auto-unsubscribe\n   ```typescript\n   listenSignalOnce(\n     (event) => event.action === \"closed\" && event.closeReason === \"take_profit\",\n     (event) => { /* handle first TP hit */ }\n   );\n   ```\n\n3. **Mode-specific listeners**: Pre-filtered streams for backtest-only or live-only events\n   ```typescript\n   listenSignalBacktest((event) => { /* only backtest signals */ });\n   listenSignalLive((event) => { /* only live signals */ });\n   ```\n\n**Sources:** [src/config/emitters.ts:1-133](), [src/function/event.ts:1-44](), [src/function/event.ts:70-113](), [docs/internals.md:83-90]()\n\n---\n\n## How Core Concepts Interact\n\nThe three core concepts work together to enable **type-safe, context-aware, event-driven execution**:\n\n```mermaid\nsequenceDiagram\n    participant API as \"Public API<br/>(Backtest.run)\"\n    participant Method as \"MethodContextService<br/>{strategyName, exchangeName}\"\n    participant Logic as \"BacktestLogicPrivateService\"\n    participant Exec as \"ExecutionContextService<br/>{symbol, when, backtest=true}\"\n    participant Strategy as \"ClientStrategy.tick()\"\n    participant Signal as \"signalEmitter\"\n    participant Listener as \"User Listener<br/>(queued)\"\n    \n    API->>Method: runAsyncIterator(context)\n    Method->>Logic: run(symbol)\n    Logic->>Exec: runInContext({symbol, when, backtest})\n    Exec->>Strategy: tick()\n    Strategy->>Strategy: Check signal state<br/>(discriminated union)\n    \n    alt Signal Closed\n        Strategy->>Signal: emit({action: \"closed\", ...})\n        Signal->>Listener: queued callback\n        Listener->>Listener: Process event<br/>(sequential, async-safe)\n    else Signal Active\n        Strategy->>Signal: emit({action: \"active\", ...})\n    end\n    \n    Exec-->>Logic: return result\n    Logic-->>Method: yield result\n    Method-->>API: stream result\n```\n\n**Diagram: Sequence Showing Integration of Signals, Contexts, and Events**\n\n1. **MethodContext** is set once at the start of a run, determining which schemas to use\n2. **ExecutionContext** is set per-tick within the loop, providing runtime parameters\n3. **ClientStrategy.tick()** accesses both contexts implicitly to execute strategy logic\n4. **Discriminated union** ensures type-safe handling of signal states\n5. **Event emission** decouples signal generation from consumption\n6. **Queued processing** guarantees sequential, deterministic event handling\n\nThis architecture enables the framework to support multiple execution modes (Backtest, Live, Walker) using the same core abstractions with different context configurations and event filtering.\n\n**Sources:** [docs/internals.md:54-82](), [types.d.ts:242-544](), [src/config/emitters.ts:15-44](), [src/function/event.ts:45-113]()"
                    },
                    {
                        "page_plan": {
                            "id": "2.1",
                            "title": "Signal Lifecycle and State Machine"
                        },
                        "content": "# Signal Lifecycle and State Machine\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [assets/uml.svg](assets/uml.svg)\n- [docs/classes/WalkerCommandService.md](docs/classes/WalkerCommandService.md)\n- [docs/interfaces/BacktestStatistics.md](docs/interfaces/BacktestStatistics.md)\n- [docs/interfaces/IStrategyCallbacks.md](docs/interfaces/IStrategyCallbacks.md)\n- [docs/interfaces/LiveStatistics.md](docs/interfaces/LiveStatistics.md)\n- [docs/internals.md](docs/internals.md)\n- [docs/types/IStrategyTickResult.md](docs/types/IStrategyTickResult.md)\n- [docs/uml.puml](docs/uml.puml)\n- [scripts/uml.mjs](scripts/uml.mjs)\n- [src/client/ClientStrategy.ts](src/client/ClientStrategy.ts)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [src/interfaces/Strategy.interface.ts](src/interfaces/Strategy.interface.ts)\n- [src/lib/services/connection/StrategyConnectionService.ts](src/lib/services/connection/StrategyConnectionService.ts)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis document describes the complete lifecycle of trading signals in backtest-kit, including the state machine that governs signal progression from creation through closure. It covers the discriminated union type system used for type-safe state handling, state transition conditions, scheduled vs immediate signal flows, and crash-safe persistence mechanisms.\n\nFor information about how signals are generated by strategies, see the Strategy System documentation. For details on execution modes (Backtest vs Live), see [Execution Modes Overview](#2.2). For event-driven monitoring of signal state changes, see [Event-Driven Architecture](#2.3).\n\n**Sources**: [types.d.ts:858-1018](), [src/interfaces/Strategy.interface.ts:1-394](), [docs/internals.md:14-20]()\n\n---\n\n## Signal State Machine Overview\n\nThe signal lifecycle is implemented as a type-safe state machine using TypeScript discriminated unions. Every signal progresses through distinct states, with transitions triggered by price conditions, time expiration, or risk validation failures.\n\n```mermaid\nstateDiagram-v2\n    [*] --> idle: \"No active signal\"\n    \n    idle --> scheduled: \"getSignal returns dto with priceOpen\\n(price not reached yet)\"\n    idle --> opened: \"getSignal returns dto without priceOpen\\n(immediate entry)\"\n    idle --> idle: \"getSignal returns null\\n(no opportunity)\"\n    \n    scheduled --> opened: \"Price reaches priceOpen\\nAND risk check passes\"\n    scheduled --> cancelled: \"Timeout (CC_SCHEDULE_AWAIT_MINUTES)\\nOR price hits StopLoss before entry\"\n    scheduled --> idle: \"Risk check fails on activation\"\n    scheduled --> scheduled: \"Price hasn't reached priceOpen yet\\n(monitoring)\"\n    \n    opened --> active: \"Next tick after opening\\n(monitoring begins)\"\n    \n    active --> closed_tp: \"Price reaches priceTakeProfit\"\n    active --> closed_sl: \"Price reaches priceStopLoss\"\n    active --> closed_time: \"Time >= scheduledAt + minuteEstimatedTime\"\n    active --> active: \"None of close conditions met\\n(continue monitoring)\"\n    \n    closed_tp --> [*]\n    closed_sl --> [*]\n    closed_time --> [*]\n    cancelled --> [*]\n    \n    note right of idle\n        action: \"idle\"\n        signal: null\n    end note\n    \n    note right of scheduled\n        action: \"scheduled\"\n        signal: IScheduledSignalRow\n        _isScheduled: true\n    end note\n    \n    note right of opened\n        action: \"opened\"\n        signal: ISignalRow\n        _isScheduled: false\n    end note\n    \n    note right of active\n        action: \"active\"\n        signal: ISignalRow\n        Monitors: TP/SL/Time\n    end note\n    \n    note right of closed_tp\n        action: \"closed\"\n        closeReason: \"take_profit\"\n    end note\n    \n    note right of closed_sl\n        action: \"closed\"\n        closeReason: \"stop_loss\"\n    end note\n    \n    note right of closed_time\n        action: \"closed\"\n        closeReason: \"time_expired\"\n    end note\n    \n    note right of cancelled\n        action: \"cancelled\"\n        Scheduled signal never activated\n    end note\n```\n\n**Sources**: [src/client/ClientStrategy.ts:876-1078](), [src/interfaces/Strategy.interface.ts:172-312](), [types.d.ts:976-1018]()\n\n---\n\n## Discriminated Union Type System\n\nThe framework uses TypeScript discriminated unions for type-safe state handling. The `action` property serves as the discriminator, enabling exhaustive type checking at compile time.\n\n| State Type | `action` Value | Signal Property | Description |\n|------------|----------------|-----------------|-------------|\n| `IStrategyTickResultIdle` | `\"idle\"` | `null` | No active signal exists |\n| `IStrategyTickResultScheduled` | `\"scheduled\"` | `IScheduledSignalRow` | Signal created, waiting for price activation |\n| `IStrategyTickResultOpened` | `\"opened\"` | `ISignalRow` | Signal just opened (first tick after creation) |\n| `IStrategyTickResultActive` | `\"active\"` | `ISignalRow` | Signal being monitored for TP/SL/time |\n| `IStrategyTickResultClosed` | `\"closed\"` | `ISignalRow` | Signal completed with PNL calculation |\n| `IStrategyTickResultCancelled` | `\"cancelled\"` | `IScheduledSignalRow` | Scheduled signal cancelled before activation |\n\n**Union Type Definition**:\n\n```typescript\ntype IStrategyTickResult = \n  | IStrategyTickResultIdle\n  | IStrategyTickResultScheduled\n  | IStrategyTickResultOpened\n  | IStrategyTickResultActive\n  | IStrategyTickResultClosed\n  | IStrategyTickResultCancelled;\n```\n\n**Type Guard Pattern**:\n\n```typescript\nif (result.action === \"closed\") {\n  // TypeScript knows result is IStrategyTickResultClosed\n  console.log(result.closeReason); // \"take_profit\" | \"stop_loss\" | \"time_expired\"\n  console.log(result.pnl.pnlPercentage); // Safe access\n}\n```\n\n**Sources**: [src/interfaces/Strategy.interface.ts:172-312](), [types.d.ts:976-1018](), [docs/types/IStrategyTickResult.md:1-14]()\n\n---\n\n## Signal Data Structures\n\n### Signal Creation Flow\n\n```mermaid\ngraph LR\n    DTO[\"ISignalDto<br/>(from getSignal)\"]\n    Validation[\"VALIDATE_SIGNAL_FN\"]\n    Risk[\"Risk.checkSignal\"]\n    Scheduled[\"IScheduledSignalRow<br/>_isScheduled=true\"]\n    Immediate[\"ISignalRow<br/>_isScheduled=false\"]\n    \n    DTO --> Validation\n    Validation --> Risk\n    Risk -->|\"priceOpen specified<br/>AND not reached\"| Scheduled\n    Risk -->|\"priceOpen omitted<br/>OR already reached\"| Immediate\n    \n    Note1[\"Auto-generated fields:<br/>- id (UUID)<br/>- symbol<br/>- strategyName<br/>- exchangeName<br/>- scheduledAt<br/>- pendingAt\"]\n    Immediate -.-> Note1\n    Scheduled -.-> Note1\n```\n\n### ISignalDto (Input)\n\nData transfer object returned by `getSignal()` callback. Minimal structure provided by strategy developer.\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `id` | `string` | Optional | Auto-generated UUID if omitted |\n| `position` | `\"long\" \\| \"short\"` | Yes | Trade direction |\n| `priceOpen` | `number` | Optional | Entry price (if specified, becomes scheduled signal) |\n| `priceTakeProfit` | `number` | Yes | Target exit price for profit |\n| `priceStopLoss` | `number` | Yes | Exit price for loss protection |\n| `minuteEstimatedTime` | `number` | Yes | Expected duration before time_expired |\n| `note` | `string` | Optional | Human-readable signal description |\n\n**Sources**: [src/interfaces/Strategy.interface.ts:20-39](), [types.d.ts:858-873]()\n\n### ISignalRow (Active Signal)\n\nComplete signal structure after validation and augmentation. Used for immediate signals and activated scheduled signals.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `id` | `string` | Unique UUID identifier |\n| `position` | `\"long\" \\| \"short\"` | Trade direction |\n| `priceOpen` | `number` | Actual entry price (required) |\n| `priceTakeProfit` | `number` | Target profit exit |\n| `priceStopLoss` | `number` | Stop loss exit |\n| `minuteEstimatedTime` | `number` | Signal lifetime in minutes |\n| `symbol` | `string` | Trading pair (e.g., \"BTCUSDT\") |\n| `exchangeName` | `string` | Exchange identifier |\n| `strategyName` | `string` | Strategy identifier |\n| `scheduledAt` | `number` | Creation timestamp (milliseconds) |\n| `pendingAt` | `number` | Activation timestamp (milliseconds) |\n| `_isScheduled` | `boolean` | Runtime marker (always `false` for active signals) |\n| `note` | `string` | Optional description |\n\n**Critical Timestamps**:\n- `scheduledAt`: When signal was first created (never changes)\n- `pendingAt`: When signal became active at `priceOpen` (may differ from `scheduledAt` for scheduled signals)\n\n**Sources**: [src/interfaces/Strategy.interface.ts:41-73](), [types.d.ts:878-895]()\n\n### IScheduledSignalRow (Waiting for Activation)\n\nExtends `ISignalRow` for signals waiting for price to reach entry point. Identical structure but `_isScheduled` is `true`.\n\n**Key Behaviors**:\n- Monitored for price activation conditions every tick\n- Subject to timeout via `CC_SCHEDULE_AWAIT_MINUTES` configuration\n- Can be cancelled if price hits `priceStopLoss` before `priceOpen` is reached\n- `pendingAt` initially equals `scheduledAt`, updated upon activation\n\n**Sources**: [src/interfaces/Strategy.interface.ts:64-73](), [types.d.ts:897-905]()\n\n---\n\n## State Transition Conditions\n\n### Idle → Scheduled\n\n**Trigger**: `getSignal()` returns `ISignalDto` with `priceOpen` specified, and current price hasn't reached entry point yet.\n\n**Conditions**:\n- For LONG: `currentPrice > priceOpen` (price needs to drop to enter)\n- For SHORT: `currentPrice < priceOpen` (price needs to rise to enter)\n\n**Code Location**: [src/client/ClientStrategy.ts:388-442]()\n\n**Validation Steps**:\n1. Check `priceOpen` is specified in DTO\n2. Calculate activation condition based on position type\n3. If not immediately activatable, create `IScheduledSignalRow`\n4. Call `VALIDATE_SIGNAL_FN` with `isScheduled=true`\n\n**Sources**: [src/client/ClientStrategy.ts:388-442]()\n\n---\n\n### Idle → Opened (Immediate Entry)\n\n**Trigger**: `getSignal()` returns `ISignalDto` without `priceOpen`, OR with `priceOpen` already reached.\n\n**Conditions**:\n- `priceOpen` is undefined, OR\n- For LONG: `currentPrice <= priceOpen`\n- For SHORT: `currentPrice >= priceOpen`\n\n**Code Location**: [src/client/ClientStrategy.ts:389-420](), [src/client/ClientStrategy.ts:444-461]()\n\n**Risk Check**: Must pass `Risk.checkSignal()` before opening ([src/client/ClientStrategy.ts:374-387]())\n\n**Auto-Generated Values**:\n- `priceOpen`: Set to `currentPrice` if omitted\n- `scheduledAt`: Current timestamp\n- `pendingAt`: Same as `scheduledAt` (immediate entry)\n- `_isScheduled`: `false`\n\n**Sources**: [src/client/ClientStrategy.ts:444-461](), [src/client/ClientStrategy.ts:848-886]()\n\n---\n\n### Scheduled → Opened (Activation)\n\n**Trigger**: Price reaches entry point while scheduled signal is active.\n\n**Conditions**:\n- For LONG: `currentPrice <= scheduledSignal.priceOpen`\n- For SHORT: `currentPrice >= scheduledSignal.priceOpen`\n- Must NOT have hit `priceStopLoss` first (checked with priority)\n\n**Code Location**: [src/client/ClientStrategy.ts:610-644](), [src/client/ClientStrategy.ts:681-774]()\n\n**Activation Flow**:\n\n```mermaid\nsequenceDiagram\n    participant Tick as \"tick()\"\n    participant Check as \"CHECK_SCHEDULED_SIGNAL_PRICE_ACTIVATION_FN\"\n    participant Activate as \"ACTIVATE_SCHEDULED_SIGNAL_FN\"\n    participant Risk as \"Risk.checkSignal\"\n    participant Persist as \"PersistSignalAdapter\"\n    \n    Tick->>Check: Check price vs priceOpen\n    \n    alt Price hit StopLoss first\n        Check-->>Tick: shouldCancel=true\n        Note over Tick: Cancel signal, return to idle\n    else Price reached priceOpen\n        Check-->>Tick: shouldActivate=true\n        Tick->>Activate: Activate signal\n        Activate->>Risk: Re-check risk limits\n        alt Risk fails\n            Risk-->>Activate: Rejected\n            Activate->>Persist: Clear scheduled signal\n            Activate-->>Tick: Return null\n        else Risk passes\n            Risk-->>Activate: Allowed\n            Activate->>Persist: Clear scheduled signal\n            Activate->>Persist: Write pending signal\n            Note over Activate: Update pendingAt to current time\n            Activate-->>Tick: Return IStrategyTickResultOpened\n        end\n    else Still waiting\n        Check-->>Tick: shouldActivate=false, shouldCancel=false\n        Note over Tick: Return IStrategyTickResultActive (monitoring)\n    end\n```\n\n**Critical**: `pendingAt` is updated to the actual activation timestamp, not kept at `scheduledAt`.\n\n**Sources**: [src/client/ClientStrategy.ts:610-644](), [src/client/ClientStrategy.ts:681-774]()\n\n---\n\n### Scheduled → Cancelled (Timeout or StopLoss)\n\n**Trigger**: Scheduled signal expires or price hits stop loss before entry.\n\n**Timeout Condition**:\n- `currentTime - scheduledAt >= CC_SCHEDULE_AWAIT_MINUTES * 60 * 1000`\n- Default: 90 minutes ([types.d.ts:10]())\n\n**Code Location**: [src/client/ClientStrategy.ts:554-608]()\n\n**StopLoss Cancellation**:\n- For LONG: `currentPrice <= priceStopLoss`\n- For SHORT: `currentPrice >= priceStopLoss`\n- Checked BEFORE activation check to prevent invalid entry\n\n**Code Location**: [src/client/ClientStrategy.ts:610-644](), [src/client/ClientStrategy.ts:646-679]()\n\n**Result**: `IStrategyTickResultCancelled` emitted, signal removed from persistence.\n\n**Sources**: [src/client/ClientStrategy.ts:554-608](), [src/client/ClientStrategy.ts:646-679]()\n\n---\n\n### Opened → Active\n\n**Trigger**: Next tick after signal opening. Automatic transition.\n\n**Purpose**: Separates \"signal just created\" event from \"signal monitoring\" state for callback clarity.\n\n**Code Location**: Implicit in state machine - `opened` is only emitted once, subsequent ticks emit `active`.\n\n**Sources**: [src/client/ClientStrategy.ts:887-965]()\n\n---\n\n### Active → Closed\n\n**Three Close Conditions** (checked in priority order):\n\n#### 1. Take Profit Hit\n\n**Condition**:\n- For LONG: `currentPrice >= priceTakeProfit`\n- For SHORT: `currentPrice <= priceTakeProfit`\n\n**Code Location**: [src/client/ClientStrategy.ts:1141-1180](), [src/client/ClientStrategy.ts:1182-1221]()\n\n**Close Reason**: `\"take_profit\"`\n\n#### 2. Stop Loss Hit\n\n**Condition**:\n- For LONG: `currentPrice <= priceStopLoss`\n- For SHORT: `currentPrice >= priceStopLoss`\n\n**Code Location**: [src/client/ClientStrategy.ts:1223-1262](), [src/client/ClientStrategy.ts:1264-1303]()\n\n**Close Reason**: `\"stop_loss\"`\n\n#### 3. Time Expiration\n\n**Condition**:\n- `currentTime - pendingAt >= minuteEstimatedTime * 60 * 1000`\n\n**Code Location**: [src/client/ClientStrategy.ts:1305-1342]()\n\n**Close Reason**: `\"time_expired\"`\n\n**Max Lifetime Protection**: Signals cannot exceed `CC_MAX_SIGNAL_LIFETIME_MINUTES` (default: 1440 minutes = 1 day) to prevent risk limit deadlock ([types.d.ts:55-59]()).\n\n**Sources**: [src/client/ClientStrategy.ts:1141-1342](), [types.d.ts:55-59]()\n\n---\n\n## Signal Validation Rules\n\nValidation occurs via `VALIDATE_SIGNAL_FN` before signal creation or activation. Throws error if any check fails.\n\n### Price Relationship Validation\n\n| Position | Condition | Error if Violated |\n|----------|-----------|-------------------|\n| LONG | `priceTakeProfit > priceOpen` | TP must be above entry |\n| LONG | `priceStopLoss < priceOpen` | SL must be below entry |\n| SHORT | `priceTakeProfit < priceOpen` | TP must be below entry |\n| SHORT | `priceStopLoss > priceOpen` | SL must be above entry |\n\n**Code Location**: [src/client/ClientStrategy.ts:111-214]()\n\n### Economic Viability Checks\n\n| Check | Configuration | Default | Purpose |\n|-------|---------------|---------|---------|\n| Min TP Distance | `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT` | 0.5% | Ensure TP covers fees + slippage |\n| Min SL Distance | `CC_MIN_STOPLOSS_DISTANCE_PERCENT` | 0.5% | Prevent instant stop-out on volatility |\n| Max SL Distance | `CC_MAX_STOPLOSS_DISTANCE_PERCENT` | 20% | Limit catastrophic losses |\n| Max Lifetime | `CC_MAX_SIGNAL_LIFETIME_MINUTES` | 1440 min | Prevent eternal signals blocking risk limits |\n\n**Code Location**: [src/client/ClientStrategy.ts:163-316]()\n\n**TP Distance Calculation** (LONG example):\n```\ntpDistancePercent = ((priceTakeProfit - priceOpen) / priceOpen) * 100\n```\n\nMust be >= 0.5% to cover:\n- Entry slippage: ~0.1%\n- Entry fee: 0.1%\n- Exit slippage: ~0.1%\n- Exit fee: 0.1%\n- Minimum profit buffer: 0.1%\n\n**Sources**: [src/client/ClientStrategy.ts:45-330](), [types.d.ts:29-59]()\n\n### Immediate Close Prevention\n\nPrevents signals that would close instantly upon creation.\n\n| Scenario | Check | Error Message |\n|----------|-------|---------------|\n| LONG Immediate | `currentPrice <= priceStopLoss` | \"Signal would be immediately closed by stop loss\" |\n| LONG Immediate | `currentPrice >= priceTakeProfit` | \"Signal would be immediately closed by take profit\" |\n| SHORT Immediate | `currentPrice >= priceStopLoss` | \"Signal would be immediately closed by stop loss\" |\n| SHORT Immediate | `currentPrice <= priceTakeProfit` | \"Signal would be immediately closed by take profit\" |\n| LONG Scheduled | `priceOpen <= priceStopLoss` | \"Signal would be immediately cancelled on activation\" |\n| LONG Scheduled | `priceOpen >= priceTakeProfit` | \"This is logically impossible for LONG position\" |\n| SHORT Scheduled | `priceOpen >= priceStopLoss` | \"Signal would be immediately cancelled on activation\" |\n| SHORT Scheduled | `priceOpen <= priceTakeProfit` | \"This is logically impossible for SHORT position\" |\n\n**Code Location**: [src/client/ClientStrategy.ts:124-251]()\n\n**Sources**: [src/client/ClientStrategy.ts:124-251]()\n\n---\n\n## PNL Calculation\n\nProfit and loss calculation includes realistic trading costs via `toProfitLossDto` helper.\n\n### Cost Modeling\n\n| Cost Component | Configuration | Default | Applied When |\n|----------------|---------------|---------|--------------|\n| Slippage | `CC_PERCENT_SLIPPAGE` | 0.1% | Entry and Exit (2x) |\n| Fees | `CC_PERCENT_FEE` | 0.1% | Entry and Exit (2x) |\n\n**Total Trading Costs**: ~0.4% per round trip\n\n**Adjusted Price Calculation**:\n\n```typescript\n// LONG Position\npriceOpenAdjusted = priceOpen * (1 + slippage + fee)  // Pay more to enter\npriceCloseAdjusted = priceClose * (1 - slippage - fee) // Receive less on exit\n\n// SHORT Position  \npriceOpenAdjusted = priceOpen * (1 - slippage - fee)  // Receive less to enter\npriceCloseAdjusted = priceClose * (1 + slippage + fee) // Pay more on exit\n```\n\n**PNL Percentage Formula**:\n\n```typescript\n// LONG\npnlPercentage = ((priceCloseAdjusted - priceOpenAdjusted) / priceOpenAdjusted) * 100\n\n// SHORT\npnlPercentage = ((priceOpenAdjusted - priceCloseAdjusted) / priceOpenAdjusted) * 100\n```\n\n**Code Location**: [src/helpers/toProfitLossDto.ts]()\n\n**Sources**: [src/client/ClientStrategy.ts:26](), [types.d.ts:22-28](), [src/interfaces/Strategy.interface.ts:159-170]()\n\n---\n\n## Persistence and Crash Recovery\n\nThe framework implements crash-safe state persistence via atomic file writes, enabling live trading processes to recover from crashes without position loss.\n\n### Persistence Adapters\n\n| Adapter | File Location | Stored Data | Purpose |\n|---------|---------------|-------------|---------|\n| `PersistSignalAdapter` | `./dump/signal/{symbol}_{strategyName}.json` | Active `ISignalRow` | Restore active positions |\n| `PersistScheduleAdapter` | `./dump/schedule/{symbol}_{strategyName}.json` | Scheduled `IScheduledSignalRow` | Restore waiting signals |\n\n**Atomic Write Pattern**:\n1. Write to temporary file (`{filename}.tmp`)\n2. Rename to target file (atomic operation)\n3. Prevents partial writes on crash\n\n**Code Location**: [src/classes/Persist.ts]()\n\n### Recovery Flow (Live Mode)\n\n```mermaid\nsequenceDiagram\n    participant Process as \"Live Process Start\"\n    participant Wait as \"waitForInit()\"\n    participant Signal as \"PersistSignalAdapter\"\n    participant Schedule as \"PersistScheduleAdapter\"\n    participant Strategy as \"ClientStrategy\"\n    \n    Process->>Wait: Initialize strategy\n    Wait->>Signal: readSignalData(symbol, strategyName)\n    Signal-->>Wait: ISignalRow | null\n    \n    alt Active signal found\n        Wait->>Strategy: Restore _pendingSignal\n        Wait->>Strategy: Call onActive callback\n        Note over Strategy: Continue monitoring TP/SL/time\n    end\n    \n    Wait->>Schedule: readScheduleData(symbol, strategyName)\n    Schedule-->>Wait: IScheduledSignalRow | null\n    \n    alt Scheduled signal found\n        Wait->>Strategy: Restore _scheduledSignal\n        Wait->>Strategy: Call onSchedule callback\n        Note over Strategy: Continue monitoring activation\n    end\n    \n    Wait-->>Process: Initialization complete\n    Process->>Strategy: Begin tick() loop\n```\n\n**Code Location**: [src/client/ClientStrategy.ts:491-552]()\n\n**Key Points**:\n- Only runs in live mode (`backtest=false`)\n- Restores both active and scheduled signals\n- Validates `exchangeName` and `strategyName` match\n- Calls appropriate lifecycle callbacks (`onActive`, `onSchedule`) after restoration\n\n**Sources**: [src/client/ClientStrategy.ts:491-552](), [src/classes/Persist.ts](), [docs/internals.md:26-27]()\n\n---\n\n## Lifecycle Callbacks\n\nStrategies can register optional callbacks to observe state transitions. All callbacks receive `backtest` flag to distinguish execution mode.\n\n### Callback Invocation Points\n\n| Callback | When Invoked | Parameters | State |\n|----------|--------------|------------|-------|\n| `onTick` | Every tick (all states) | `symbol`, `result`, `backtest` | All |\n| `onIdle` | No active signal | `symbol`, `currentPrice`, `backtest` | Idle |\n| `onSchedule` | Scheduled signal created | `symbol`, `data: IScheduledSignalRow`, `currentPrice`, `backtest` | Scheduled |\n| `onOpen` | Signal opened/activated | `symbol`, `data: ISignalRow`, `currentPrice`, `backtest` | Opened |\n| `onActive` | Signal being monitored | `symbol`, `data: ISignalRow`, `currentPrice`, `backtest` | Active |\n| `onPartialProfit` | Profit milestone reached | `symbol`, `data: ISignalRow`, `currentPrice`, `revenuePercent`, `backtest` | Active |\n| `onPartialLoss` | Loss milestone reached | `symbol`, `data: ISignalRow`, `currentPrice`, `lossPercent`, `backtest` | Active |\n| `onClose` | Signal closed | `symbol`, `data: ISignalRow`, `priceClose`, `backtest` | Closed |\n| `onCancel` | Scheduled signal cancelled | `symbol`, `data: IScheduledSignalRow`, `currentPrice`, `backtest` | Cancelled |\n| `onWrite` | State persisted (testing) | `symbol`, `data: ISignalRow \\| null`, `backtest` | Any |\n\n**Code Locations**:\n- Callback interface: [src/interfaces/Strategy.interface.ts:96-126]()\n- Invocation points: [src/client/ClientStrategy.ts]() (various locations)\n\n**onTick Universality**: `onTick` is called for EVERY state transition, receiving the full `IStrategyTickResult`. Other callbacks are supplementary and state-specific.\n\n**Sources**: [src/interfaces/Strategy.interface.ts:96-126](), [docs/interfaces/IStrategyCallbacks.md]()\n\n---\n\n## Event Emissions\n\nBeyond callbacks, the framework emits events via global `Subject` instances for cross-cutting concerns like reporting and monitoring.\n\n### Signal Event Emitters\n\n| Emitter | Emits | Scope | Listener Functions |\n|---------|-------|-------|-------------------|\n| `signalEmitter` | All `IStrategyTickResult` | Both backtest and live | `listenSignal()`, `listenSignalOnce()` |\n| `signalBacktestEmitter` | Backtest results only | Backtest mode | `listenSignalBacktest()`, `listenSignalBacktestOnce()` |\n| `signalLiveEmitter` | Live results only | Live mode | `listenSignalLive()`, `listenSignalLiveOnce()` |\n\n**Emission Points**:\n- After every `tick()` call: [src/lib/services/connection/StrategyConnectionService.ts:218-227]()\n- After every `backtest()` call: [src/lib/services/connection/StrategyConnectionService.ts:254-259]()\n\n**Queued Processing**: All listener functions use `queued()` wrapper from functools-kit to ensure sequential async execution, preventing race conditions.\n\n**Code Location**: [src/config/emitters.ts:15-31](), [src/function/event.ts:70-221]()\n\n**Sources**: [src/config/emitters.ts:15-31](), [src/function/event.ts:70-221](), [src/lib/services/connection/StrategyConnectionService.ts:207-261]()\n\n---\n\n## Backtest Fast-Path Optimization\n\nIn backtest mode, signals use a fast-path through historical candles to avoid tick-by-tick processing.\n\n### backtest() Method Flow\n\n```mermaid\nflowchart TD\n    Start[\"backtest(symbol, strategyName, candles)\"]\n    GetSignal[\"Get _pendingSignal or _scheduledSignal\"]\n    \n    HasSignal{\"Has signal?\"}\n    ReturnIdle[\"Return IStrategyTickResultIdle\"]\n    \n    IsScheduled{\"_isScheduled?\"}\n    MonitorScheduled[\"Monitor scheduled signal<br/>for activation or cancellation\"]\n    \n    ScheduleOutcome{\"Outcome?\"}\n    ReturnCancelled[\"Return IStrategyTickResultCancelled\"]\n    Activated[\"Signal activated<br/>Now _pendingSignal\"]\n    \n    IterateCandles[\"Iterate candles array\"]\n    CalcVWAP[\"Calculate VWAP per candle:<br/>GET_AVG_PRICE_FN\"]\n    \n    CheckTP{\"TP hit?\"}\n    CheckSL{\"SL hit?\"}\n    CheckTime{\"Time expired?\"}\n    \n    CloseTP[\"Close with take_profit<br/>Clear state\"]\n    CloseSL[\"Close with stop_loss<br/>Clear state\"]\n    CloseTime[\"Close with time_expired<br/>Clear state\"]\n    \n    ReturnClosed[\"Return IStrategyTickResultClosed<br/>with PNL calculation\"]\n    \n    Start --> GetSignal\n    GetSignal --> HasSignal\n    HasSignal -->|No| ReturnIdle\n    HasSignal -->|Yes| IsScheduled\n    \n    IsScheduled -->|Yes| MonitorScheduled\n    MonitorScheduled --> ScheduleOutcome\n    ScheduleOutcome -->|Cancelled| ReturnCancelled\n    ScheduleOutcome -->|Activated| Activated\n    \n    IsScheduled -->|No| IterateCandles\n    Activated --> IterateCandles\n    \n    IterateCandles --> CalcVWAP\n    CalcVWAP --> CheckTP\n    CheckTP -->|Yes| CloseTP\n    CheckTP -->|No| CheckSL\n    CheckSL -->|Yes| CloseSL\n    CheckSL -->|No| CheckTime\n    CheckTime -->|Yes| CloseTime\n    CheckTime -->|No| IterateCandles\n    \n    CloseTP --> ReturnClosed\n    CloseSL --> ReturnClosed\n    CloseTime --> ReturnClosed\n```\n\n**Key Optimizations**:\n1. **Skip Individual Ticks**: Processes array of candles directly instead of tick-by-tick\n2. **VWAP Per Candle**: Calculates typical price `(high + low + close) / 3` weighted by volume\n3. **Early Exit**: Stops iterating once close condition met\n4. **No Persistence**: Backtest mode doesn't write to disk (stateless)\n\n**Code Location**: [src/client/ClientStrategy.ts:1008-1139]()\n\n**VWAP Calculation**: [src/client/ClientStrategy.ts:478-489]()\n\n**Sources**: [src/client/ClientStrategy.ts:1008-1139](), [src/client/ClientStrategy.ts:478-489](), [docs/internals.md:54-68]()\n\n---\n\n## Runtime State Management\n\nThe `ClientStrategy` class maintains internal state via private properties.\n\n### State Properties\n\n| Property | Type | Purpose |\n|----------|------|---------|\n| `_pendingSignal` | `ISignalRow \\| null` | Currently active signal being monitored |\n| `_scheduledSignal` | `IScheduledSignalRow \\| null` | Scheduled signal waiting for activation |\n| `_lastSignalTimestamp` | `number \\| null` | Last `getSignal()` invocation time (for throttling) |\n| `_isStopped` | `boolean` | Stop flag for graceful shutdown |\n\n**Mutual Exclusivity**: A strategy can have EITHER `_pendingSignal` OR `_scheduledSignal` active, never both simultaneously.\n\n**Code Location**: [src/client/ClientStrategy.ts]() (class properties)\n\n### State Setter Methods\n\n| Method | Purpose | Side Effects |\n|--------|---------|--------------|\n| `setPendingSignal(signal)` | Set active signal | Writes to `PersistSignalAdapter` (live mode only) |\n| `setScheduledSignal(signal)` | Set scheduled signal | Writes to `PersistScheduleAdapter` (live mode only) |\n| `waitForInit()` | Load persisted state | Reads from both adapters, restores state, calls callbacks |\n| `stop()` | Set stop flag | Sets `_isStopped = true` |\n\n**Persistence Conditional**: State writes only occur in live mode (`backtest=false`). Backtest mode keeps state in memory only.\n\n**Code Location**: [src/client/ClientStrategy.ts]() (various methods)\n\n**Sources**: [src/client/ClientStrategy.ts]()\n\n---\n\n## Summary Table: State Transitions\n\n| From State | To State | Trigger | Validation | Result Type |\n|------------|----------|---------|------------|-------------|\n| `idle` | `idle` | `getSignal()` returns `null` | N/A | `IStrategyTickResultIdle` |\n| `idle` | `scheduled` | `getSignal()` returns DTO with `priceOpen` not reached | Signal + Risk | `IStrategyTickResultScheduled` |\n| `idle` | `opened` | `getSignal()` returns DTO, immediate entry | Signal + Risk | `IStrategyTickResultOpened` |\n| `scheduled` | `scheduled` | Price hasn't reached `priceOpen` | N/A | `IStrategyTickResultActive` (monitoring) |\n| `scheduled` | `opened` | Price reaches `priceOpen` | Risk re-check | `IStrategyTickResultOpened` |\n| `scheduled` | `cancelled` | Timeout OR StopLoss before entry | N/A | `IStrategyTickResultCancelled` |\n| `scheduled` | `idle` | Risk check fails on activation | N/A | `IStrategyTickResultIdle` |\n| `opened` | `active` | Next tick | N/A | `IStrategyTickResultActive` |\n| `active` | `active` | No close condition met | N/A | `IStrategyTickResultActive` |\n| `active` | `closed` | TP hit | N/A | `IStrategyTickResultClosed` (`take_profit`) |\n| `active` | `closed` | SL hit | N/A | `IStrategyTickResultClosed` (`stop_loss`) |\n| `active` | `closed` | Time expired | N/A | `IStrategyTickResultClosed` (`time_expired`) |\n\n**Sources**: [src/client/ClientStrategy.ts:876-1078](), [src/interfaces/Strategy.interface.ts:172-312]()"
                    },
                    {
                        "page_plan": {
                            "id": "2.2",
                            "title": "Execution Modes Overview"
                        },
                        "content": "# Execution Modes Overview\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [assets/uml.svg](assets/uml.svg)\n- [docs/classes/WalkerCommandService.md](docs/classes/WalkerCommandService.md)\n- [docs/interfaces/BacktestStatistics.md](docs/interfaces/BacktestStatistics.md)\n- [docs/interfaces/IStrategyCallbacks.md](docs/interfaces/IStrategyCallbacks.md)\n- [docs/interfaces/LiveStatistics.md](docs/interfaces/LiveStatistics.md)\n- [docs/internals.md](docs/internals.md)\n- [docs/types/IStrategyTickResult.md](docs/types/IStrategyTickResult.md)\n- [docs/uml.puml](docs/uml.puml)\n- [scripts/uml.mjs](scripts/uml.mjs)\n- [src/classes/Backtest.ts](src/classes/Backtest.ts)\n- [src/classes/Live.ts](src/classes/Live.ts)\n- [src/classes/Walker.ts](src/classes/Walker.ts)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis document provides a comparative overview of the four execution modes available in backtest-kit: **Backtest**, **Live**, **Walker**, and **Optimizer**. Each mode serves a distinct purpose in the strategy development and deployment lifecycle, from historical simulation to real-time trading to strategy comparison to LLM-based code generation.\n\nFor detailed implementation specifics of each mode, see: Backtest Mode ([5.1](#5.1)), Live Trading Mode ([5.2](#5.2)), Walker Mode ([5.3](#5.3)), and Optimizer Mode ([5.4](#5.4)).\n\nFor information about the signal lifecycle that underpins all execution modes, see Signal Lifecycle and State Machine ([2.1](#2.1)).\n\n## Execution Modes\n\nThe framework implements four distinct execution modes, each with different characteristics and use cases:\n\n| Mode | Purpose | Data Source | Execution Pattern | Output | Persistence |\n|------|---------|-------------|-------------------|--------|-------------|\n| **Backtest** | Historical simulation | Frame timeframes | Finite generator | Closed signals only | None (stateless) |\n| **Live** | Real-time trading | Current time | Infinite generator | All tick types | Crash-safe JSON files |\n| **Walker** | Strategy comparison | Sequential backtests | Finite generator | Comparative statistics | None (delegates to Backtest) |\n| **Optimizer** | LLM code generation | Multi-timeframe data | Single execution | Generated .mjs file | File system output |\n\n**Sources:** [src/classes/Backtest.ts:1-594](), [src/classes/Live.ts:1-607](), [src/classes/Walker.ts:1-643](), [types.d.ts:1-365609]()\n\n## Mode Architecture Overview\n\n```mermaid\ngraph TB\n    subgraph API[\"Public API Layer\"]\n        BacktestClass[\"Backtest.run()<br/>Backtest.background()\"]\n        LiveClass[\"Live.run()<br/>Live.background()\"]\n        WalkerClass[\"Walker.run()<br/>Walker.background()\"]\n        OptimizerClass[\"Optimizer.run()<br/>Optimizer.dump()\"]\n    end\n    \n    subgraph Command[\"Command Service Layer\"]\n        BacktestCmd[\"BacktestCommandService\"]\n        LiveCmd[\"LiveCommandService\"]\n        WalkerCmd[\"WalkerCommandService\"]\n        OptimizerGlobal[\"OptimizerGlobalService\"]\n    end\n    \n    subgraph Logic[\"Logic Service Layer\"]\n        BacktestLogicPub[\"BacktestLogicPublicService\"]\n        BacktestLogicPriv[\"BacktestLogicPrivateService\"]\n        LiveLogicPub[\"LiveLogicPublicService\"]\n        LiveLogicPriv[\"LiveLogicPrivateService\"]\n        WalkerLogicPub[\"WalkerLogicPublicService\"]\n        WalkerLogicPriv[\"WalkerLogicPrivateService\"]\n    end\n    \n    subgraph Core[\"Core Execution\"]\n        StrategyCore[\"StrategyCoreService<br/>tick() + backtest()\"]\n        ExchangeCore[\"ExchangeCoreService<br/>getCandles()\"]\n        FrameCore[\"FrameCoreService<br/>getTimeframe()\"]\n    end\n    \n    subgraph Context[\"Context Services\"]\n        ExecCtx[\"ExecutionContextService<br/>symbol, when, backtest\"]\n        MethodCtx[\"MethodContextService<br/>strategyName, exchangeName, frameName\"]\n    end\n    \n    BacktestClass --> BacktestCmd\n    LiveClass --> LiveCmd\n    WalkerClass --> WalkerCmd\n    OptimizerClass --> OptimizerGlobal\n    \n    BacktestCmd --> BacktestLogicPub\n    LiveCmd --> LiveLogicPub\n    WalkerCmd --> WalkerLogicPub\n    \n    BacktestLogicPub --> BacktestLogicPriv\n    LiveLogicPub --> LiveLogicPriv\n    WalkerLogicPub --> WalkerLogicPriv\n    \n    BacktestLogicPriv --> StrategyCore\n    BacktestLogicPriv --> ExchangeCore\n    BacktestLogicPriv --> FrameCore\n    \n    LiveLogicPriv --> StrategyCore\n    \n    WalkerLogicPriv --> BacktestLogicPub\n    \n    StrategyCore --> ExecCtx\n    ExchangeCore --> ExecCtx\n    BacktestLogicPriv --> MethodCtx\n    LiveLogicPriv --> MethodCtx\n    WalkerLogicPriv --> MethodCtx\n```\n\n**Sources:** [src/classes/Backtest.ts:355-593](), [src/classes/Live.ts:372-606](), [src/classes/Walker.ts:418-643](), [src/lib/index.ts:1-195]()\n\n## Backtest Mode\n\n### Purpose\nExecutes a strategy against historical data to evaluate performance. Optimized for speed with timeframe skipping and fast candle processing.\n\n### Key Characteristics\n\n```mermaid\ngraph LR\n    Input[\"symbol<br/>strategyName<br/>exchangeName<br/>frameName\"] --> Frame[\"FrameCoreService.getTimeframe()\"]\n    Frame --> Loop[\"Iterate timeframes\"]\n    Loop --> Tick[\"ClientStrategy.tick()\"]\n    Tick --> Check{Signal opened?}\n    Check -->|No| Loop\n    Check -->|Yes| Candles[\"ExchangeCoreService.getNextCandles()\"]\n    Candles --> FastBacktest[\"ClientStrategy.backtest()<br/>Fast processing\"]\n    FastBacktest --> Skip[\"Skip to closeTimestamp\"]\n    Skip --> Yield[\"yield closed signal\"]\n    Yield --> Loop\n```\n\n**Entry Point:** `Backtest.run(symbol, context)` where context contains `{ strategyName, exchangeName, frameName }`\n\n**Execution Context:**\n- `when` = timeframe timestamp (Date from array)\n- `backtest` = `true`\n- Finite loop (ends when timeframes exhausted)\n\n**Performance Optimizations:**\n- Timeframe array pre-generated by `FrameCoreService`\n- Fast candle processing via `ClientStrategy.backtest()` instead of individual ticks\n- Skip-to-close optimization: jumps directly to `closeTimestamp` after signal opens\n- No persistence overhead (stateless execution)\n\n**Output:** Async generator yielding `IStrategyTickResultClosed` only. Filters out idle/active states.\n\n**Sources:** [src/classes/Backtest.ts:355-593](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:1-199](), [types.d.ts:974-1095]()\n\n## Live Mode\n\n### Purpose\nExecutes a strategy in real-time with crash-safe state persistence. Designed for production trading environments.\n\n### Key Characteristics\n\n```mermaid\ngraph LR\n    Input[\"symbol<br/>strategyName<br/>exchangeName\"] --> Init[\"waitForInit()<br/>Load persisted state\"]\n    Init --> Loop[\"Infinite while(true)\"]\n    Loop --> Now[\"when = new Date()\"]\n    Now --> Tick[\"ClientStrategy.tick()\"]\n    Tick --> Persist[\"PersistSignalAdapter<br/>Atomic JSON write\"]\n    Persist --> Yield[\"yield signal\"]\n    Yield --> Sleep[\"sleep(61s)\"]\n    Sleep --> Check{Stopped?}\n    Check -->|No| Loop\n    Check -->|Yes| Wait[\"Wait for closed\"]\n    Wait --> Done[\"Done\"]\n```\n\n**Entry Point:** `Live.run(symbol, context)` where context contains `{ strategyName, exchangeName }`\n\n**Execution Context:**\n- `when` = `new Date()` (current timestamp)\n- `backtest` = `false`\n- Infinite loop (runs until manually stopped)\n\n**Crash Recovery:**\n- `PersistSignalAdapter` writes state to `./dump/signals/{symbol}_{strategyName}.json`\n- Atomic writes via `writeFile()` ensure consistency\n- `waitForInit()` loads persisted state on startup\n- Process can crash and restart - state recovered from disk\n\n**Graceful Shutdown:**\n- `stop()` sets internal flag to prevent new signals\n- Background mode waits for `signal.action === \"closed\"` before breaking loop\n- Ensures open positions complete normally before exit\n\n**Output:** Async generator yielding all tick types: `idle`, `opened`, `active`, `closed`, `scheduled`, `cancelled`\n\n**Sources:** [src/classes/Live.ts:372-606](), [src/lib/services/logic/private/LiveLogicPrivateService.ts:1-134](), [types.d.ts:974-1095]()\n\n## Walker Mode\n\n### Purpose\nCompares multiple strategies against the same historical data to identify the best performer based on a chosen metric (e.g., Sharpe ratio, win rate).\n\n### Key Characteristics\n\n```mermaid\ngraph LR\n    Input[\"symbol<br/>walkerName\"] --> Schema[\"WalkerSchemaService<br/>Get strategy list\"]\n    Schema --> Loop[\"for each strategy\"]\n    Loop --> Backtest[\"BacktestLogicPublicService.run()\"]\n    Backtest --> Stats[\"BacktestMarkdownService.getData()\"]\n    Stats --> Compare[\"Compare metric values\"]\n    Compare --> Track[\"Track bestStrategy\"]\n    Track --> Yield[\"yield WalkerContract\"]\n    Yield --> Next{More strategies?}\n    Next -->|Yes| Loop\n    Next -->|No| Complete[\"walkerCompleteSubject.next()\"]\n```\n\n**Entry Point:** `Walker.run(symbol, { walkerName })` where `walkerName` references a walker schema\n\n**Walker Schema Structure:**\n```typescript\ninterface IWalkerSchema {\n  walkerName: string;\n  strategies: StrategyName[];  // List of strategies to compare\n  exchangeName: string;         // Shared exchange\n  frameName: string;            // Shared timeframe\n  metric?: WalkerMetric;        // Comparison metric (default: sharpeRatio)\n}\n```\n\n**Execution Flow:**\n1. Iterate through `strategies[]` array sequentially\n2. Run full backtest for each strategy via `BacktestLogicPublicService`\n3. Retrieve statistics via `BacktestMarkdownService.getData()`\n4. Compare metric value with current best\n5. Yield progress update with `bestStrategy` and `bestMetric`\n6. Emit final results via `walkerCompleteSubject`\n\n**Stop Mechanism:**\n- Uses `walkerStopSubject` for inter-strategy communication\n- Filtered by `walkerName` to support multiple concurrent walkers\n- Stops current running strategy and prevents subsequent strategies from executing\n\n**Output:** Async generator yielding `WalkerContract` after each strategy completion\n\n**Sources:** [src/classes/Walker.ts:418-643](), [src/lib/services/logic/private/WalkerLogicPrivateService.ts:1-204](), [types.d.ts:2175-2257]()\n\n## Optimizer Mode\n\n### Purpose\nGenerates complete strategy code using LLM (Ollama API) based on historical market data and user-provided prompts. Outputs executable .mjs files.\n\n### Key Characteristics\n\n```mermaid\ngraph LR\n    Input[\"symbol<br/>optimizerName\"] --> Sources[\"Iterate data sources<br/>1h, 30m, 15m, 1m\"]\n    Sources --> Fetch[\"Fetch candles<br/>CCXT_DUMPER_URL or Exchange API\"]\n    Fetch --> Format[\"Format for LLM<br/>Markdown tables\"]\n    Format --> Prompt[\"User getPrompt() callback\"]\n    Prompt --> LLM[\"Ollama API<br/>deepseek-v3.1:671b\"]\n    LLM --> Template[\"OptimizerTemplateService<br/>Generate .mjs file\"]\n    Template --> Output[\"Complete executable code\"]\n```\n\n**Entry Point:** `Optimizer.run(symbol, { optimizerName })` where `optimizerName` references an optimizer schema\n\n**Optimizer Schema Structure:**\n```typescript\ninterface IOptimizerSchema {\n  optimizerName: string;\n  sources: IOptimizerSource[];       // Data sources (intervals + ranges)\n  getPrompt: (data: IOptimizerData) => Promise<string>;  // LLM prompt generator\n  callbacks?: {\n    onProgress?: (source: IOptimizerSource, data: ICandleData[]) => void;\n  };\n}\n```\n\n**Data Source Iteration:**\n- Each source specifies: `interval` (e.g., \"1h\"), `since`, `until`, `limit`\n- Framework fetches historical candles for each source\n- Progress tracked via `progressOptimizerEmitter`\n\n**LLM Integration:**\n- Formats candle data as markdown tables in user/assistant message pairs\n- User provides custom `getPrompt()` callback for strategy logic\n- Calls Ollama API with `deepseek-v3.1:671b` model\n- Receives generated strategy code as response\n\n**Template System:**\n- `OptimizerTemplateService.generate()` wraps LLM output in complete executable\n- Generated file includes: imports, `addExchange()`, `addStrategy()`, `addFrame()`, `addWalker()`, `Walker.background()`\n- Output is a fully functional backtest-kit script\n\n**File Output:** `Optimizer.dump()` writes to `./{optimizerName}_{symbol}.mjs`\n\n**Output:** Returns generated code string, no async generator pattern\n\n**Sources:** [types.d.ts:2507-2647](), [src/lib/services/template/OptimizerTemplateService.ts:1-203](), [demo/optimization/src/index.mjs:1-154]()\n\n## Mode Comparison by Data Flow\n\n### Time Progression\n\n| Mode | Time Source | Pattern | Range |\n|------|-------------|---------|-------|\n| Backtest | `FrameCoreService.getTimeframe()` | Pre-generated array | `startDate` to `endDate` at fixed intervals |\n| Live | `new Date()` | Real-time clock | Open-ended (infinite) |\n| Walker | Delegates to Backtest | Sequential backtests | Same as configured Frame |\n| Optimizer | Specified in sources | Historical fetch | Per-source date ranges |\n\n### Signal Output Filtering\n\n```mermaid\ngraph TB\n    subgraph Backtest[\"Backtest Mode\"]\n        B_All[\"All tick types\"] --> B_Filter[\"Filter: closed only\"]\n        B_Filter --> B_Yield[\"yield closed signals\"]\n    end\n    \n    subgraph Live[\"Live Mode\"]\n        L_All[\"All tick types\"] --> L_Filter[\"Filter: opened + closed\"]\n        L_Filter --> L_Yield[\"yield opened/closed<br/>No idle/active\"]\n    end\n    \n    subgraph Walker[\"Walker Mode\"]\n        W_All[\"Backtest signals\"] --> W_Stats[\"Aggregate to stats\"]\n        W_Stats --> W_Yield[\"yield progress after each strategy\"]\n    end\n    \n    subgraph Optimizer[\"Optimizer Mode\"]\n        O_Candles[\"Historical candles\"] --> O_LLM[\"LLM processing\"]\n        O_LLM --> O_Code[\"return code string\"]\n    end\n```\n\n**Backtest Filtering Logic:** [src/lib/services/logic/private/BacktestLogicPrivateService.ts:80-95]()\n```typescript\nif (result.action === \"closed\") {\n  yield result;  // Only yield closed signals\n}\n// idle, opened, active, scheduled, cancelled are not yielded\n```\n\n**Live Filtering Logic:** [src/lib/services/logic/private/LiveLogicPrivateService.ts:95-115]()\n```typescript\nif (result.action === \"opened\" || result.action === \"closed\") {\n  yield result;  // Only yield opened and closed\n}\n// idle and active are filtered out to reduce noise\n```\n\n**Sources:** [src/lib/services/logic/private/BacktestLogicPrivateService.ts:1-199](), [src/lib/services/logic/private/LiveLogicPrivateService.ts:1-134]()\n\n## Persistence Patterns\n\n### Backtest: Stateless\n\n- No persistence layer\n- All state in memory during execution\n- Cleared on completion via `clear()` methods\n- Markdown reports generated on-demand via `getData()`/`getReport()`\n\n### Live: Crash-Safe\n\n```mermaid\ngraph LR\n    Tick[\"ClientStrategy.tick()\"] --> Check{State changed?}\n    Check -->|Yes| Write[\"PersistSignalAdapter.writeSignalData()\"]\n    Write --> Atomic[\"Atomic writeFile()\"]\n    Atomic --> Disk[\"./dump/signals/<br/>{symbol}_{strategy}.json\"]\n    Check -->|No| Continue[\"Continue\"]\n    \n    Restart[\"Process restart\"] --> Load[\"waitForInit()\"]\n    Load --> Read[\"readFile()\"]\n    Read --> Restore[\"Restore state\"]\n```\n\n**Persistence Implementation:** [src/classes/Persist.ts:1-372]()\n\n**Atomic Write Pattern:**\n- `PersistSignalAdapter.writeSignalData()` writes entire state object\n- Uses `await writeFile()` for atomic operation (no partial writes)\n- Crash during write leaves previous valid state intact\n\n**State Recovery:**\n- `ClientStrategy.waitForInit()` calls `PersistSignalAdapter.readSignalData()`\n- Returns `null` if no persisted state exists (first run)\n- Returns `ISignalRow` if previous state exists (recovery)\n\n**Sources:** [src/classes/Persist.ts:1-372](), [src/client/ClientStrategy.ts:1-874]()\n\n## When to Use Each Mode\n\n### Use Backtest When:\n- Validating strategy logic against historical data\n- Measuring performance metrics (Sharpe ratio, win rate, etc.)\n- Speed is critical (need fast iteration)\n- No persistence required\n- Testing parameter sensitivity\n- Generating performance reports\n\n### Use Live When:\n- Deploying to production trading\n- Need crash-safe state persistence\n- Real-time market data required\n- Long-running process (days/weeks)\n- Monitoring open positions\n- Graceful shutdown critical\n\n### Use Walker When:\n- Comparing multiple strategies on same data\n- A/B testing different parameters\n- Finding optimal strategy for a symbol\n- Need automated metric-based selection\n- Batch processing multiple strategies\n- Building strategy leaderboards\n\n### Use Optimizer When:\n- Generating strategy code via LLM\n- Need multi-timeframe data analysis\n- Automating strategy creation\n- Exploring new trading ideas with AI\n- Exporting complete executable code\n- Iterative prompt engineering\n\n**Sources:** [docs/internals.md:104-113](), [types.d.ts:1-365609]()\n\n## Code Entry Points\n\n### Backtest Execution\n\n**Singleton API:**\n```typescript\nimport { Backtest } from \"backtest-kit\";\n\n// Run and consume results\nfor await (const signal of Backtest.run(\"BTCUSDT\", {\n  strategyName: \"my-strategy\",\n  exchangeName: \"binance\",\n  frameName: \"1d-backtest\"\n})) {\n  console.log(\"Closed signal PNL:\", signal.pnl.pnlPercentage);\n}\n\n// Background execution\nconst cancel = Backtest.background(\"BTCUSDT\", { /*...*/ });\n```\n\n**Instance API:**\n```typescript\nimport { BacktestInstance } from \"backtest-kit\";\n\nconst instance = new BacktestInstance(\"BTCUSDT\", \"my-strategy\");\nfor await (const signal of instance.run(\"BTCUSDT\", { /*...*/ })) {\n  // Process signal\n}\n```\n\n**Location:** [src/classes/Backtest.ts:355-593]()\n\n### Live Execution\n\n**Singleton API:**\n```typescript\nimport { Live } from \"backtest-kit\";\n\n// Run and consume results\nfor await (const signal of Live.run(\"BTCUSDT\", {\n  strategyName: \"my-strategy\",\n  exchangeName: \"binance\"\n})) {\n  if (signal.action === \"opened\") {\n    console.log(\"Position opened\");\n  } else if (signal.action === \"closed\") {\n    console.log(\"Position closed:\", signal.pnl.pnlPercentage);\n  }\n}\n\n// Background execution\nconst cancel = Live.background(\"BTCUSDT\", { /*...*/ });\n```\n\n**Instance API:**\n```typescript\nimport { LiveInstance } from \"backtest-kit\";\n\nconst instance = new LiveInstance(\"BTCUSDT\", \"my-strategy\");\nfor await (const signal of instance.run(\"BTCUSDT\", { /*...*/ })) {\n  // Process signal\n}\n```\n\n**Location:** [src/classes/Live.ts:372-606]()\n\n### Walker Execution\n\n**Singleton API:**\n```typescript\nimport { Walker } from \"backtest-kit\";\n\n// Run and consume results\nfor await (const progress of Walker.run(\"BTCUSDT\", {\n  walkerName: \"my-walker\"\n})) {\n  console.log(\"Progress:\", progress.strategiesTested, \"/\", progress.totalStrategies);\n  console.log(\"Best strategy:\", progress.bestStrategy, progress.bestMetric);\n}\n\n// Background execution\nconst cancel = Walker.background(\"BTCUSDT\", { walkerName: \"my-walker\" });\n```\n\n**Instance API:**\n```typescript\nimport { WalkerInstance } from \"backtest-kit\";\n\nconst instance = new WalkerInstance(\"BTCUSDT\", \"my-walker\");\nfor await (const progress of instance.run(\"BTCUSDT\", { /*...*/ })) {\n  // Process progress\n}\n```\n\n**Location:** [src/classes/Walker.ts:418-643]()\n\n### Optimizer Execution\n\n**Singleton API:**\n```typescript\nimport { Optimizer } from \"backtest-kit\";\n\n// Generate strategy code\nconst code = await Optimizer.run(\"BTCUSDT\", {\n  optimizerName: \"my-optimizer\"\n});\n\n// Save to file\nawait Optimizer.dump(\"BTCUSDT\", \"my-optimizer\");\n// Creates: ./my-optimizer_BTCUSDT.mjs\n```\n\n**Location:** [types.d.ts:2507-2647](), [demo/optimization/src/index.mjs:1-154]()\n\n## Event Emitters by Mode\n\nEach execution mode emits to specific event subjects for monitoring:\n\n| Mode | Signal Emitter | Progress Emitter | Completion Emitter |\n|------|----------------|------------------|-------------------|\n| Backtest | `signalBacktestEmitter` | `progressBacktestEmitter` | `doneBacktestSubject` |\n| Live | `signalLiveEmitter` | N/A | `doneLiveSubject` |\n| Walker | N/A (uses `walkerEmitter`) | `progressWalkerEmitter` | `doneWalkerSubject`, `walkerCompleteSubject` |\n| Optimizer | N/A | `progressOptimizerEmitter` | N/A |\n\n**Common Emitters:**\n- `signalEmitter` - Receives all signals from both Backtest and Live\n- `errorEmitter` - Recoverable errors during background execution\n- `exitEmitter` - Fatal errors requiring process termination\n- `performanceEmitter` - Execution metrics across all modes\n\n**Sources:** [src/config/emitters.ts:1-133](), [src/function/event.ts:1-610]()"
                    },
                    {
                        "page_plan": {
                            "id": "2.3",
                            "title": "Event-Driven Architecture"
                        },
                        "content": "# Event-Driven Architecture\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [assets/uml.svg](assets/uml.svg)\n- [docs/classes/WalkerCommandService.md](docs/classes/WalkerCommandService.md)\n- [docs/interfaces/BacktestStatistics.md](docs/interfaces/BacktestStatistics.md)\n- [docs/interfaces/IStrategyCallbacks.md](docs/interfaces/IStrategyCallbacks.md)\n- [docs/interfaces/LiveStatistics.md](docs/interfaces/LiveStatistics.md)\n- [docs/internals.md](docs/internals.md)\n- [docs/types/IStrategyTickResult.md](docs/types/IStrategyTickResult.md)\n- [docs/uml.puml](docs/uml.puml)\n- [scripts/uml.mjs](scripts/uml.mjs)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [src/lib/services/markdown/BacktestMarkdownService.ts](src/lib/services/markdown/BacktestMarkdownService.ts)\n- [src/lib/services/markdown/HeatMarkdownService.ts](src/lib/services/markdown/HeatMarkdownService.ts)\n- [src/lib/services/markdown/LiveMarkdownService.ts](src/lib/services/markdown/LiveMarkdownService.ts)\n- [src/lib/services/markdown/PartialMarkdownService.ts](src/lib/services/markdown/PartialMarkdownService.ts)\n- [src/lib/services/markdown/PerformanceMarkdownService.ts](src/lib/services/markdown/PerformanceMarkdownService.ts)\n- [src/lib/services/markdown/ScheduleMarkdownService.ts](src/lib/services/markdown/ScheduleMarkdownService.ts)\n- [src/lib/services/markdown/WalkerMarkdownService.ts](src/lib/services/markdown/WalkerMarkdownService.ts)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis document explains the pub/sub event system in backtest-kit, including event emitters, listener functions, queued async processing, and how events flow through the system. It covers the complete event architecture from producers to consumers.\n\nFor information about the signal lifecycle state machine that produces signal events, see [Signal Lifecycle and State Machine](#2.1). For details on how different execution modes use events, see [Execution Modes Overview](#2.2). For comprehensive documentation on using event listeners in your code, see [Event Listeners and Monitoring](#9.2).\n\n## Overview\n\nThe backtest-kit framework implements a comprehensive event-driven architecture using the pub/sub pattern via `functools-kit` Subject. This architecture decouples event producers (strategies, execution logic, risk managers) from event consumers (markdown reports, user callbacks, monitoring systems) through a central event bus.\n\nAll event communication flows through typed Subject instances exported from [src/config/emitters.ts](). The framework provides 18 distinct event emitters organized by domain: signals, errors, completion, progress, risk, and performance. User code subscribes to events via listener functions exported from [src/function/event.ts](), which wrap Subject subscriptions with queued async processing to maintain event ordering.\n\n**Key Architecture Principles:**\n\n| Principle | Implementation | Benefit |\n|-----------|---------------|---------|\n| **Decoupling** | Producers emit to Subject, consumers subscribe | Producers don't know about consumers |\n| **Type Safety** | Typed payloads (contracts) | Compile-time validation |\n| **Ordering** | `queued()` wrapper on all listeners | Sequential async execution |\n| **Filtering** | Separate emitters for live/backtest | Targeted subscriptions |\n| **Once Semantics** | `Once` listener variants | Single-shot reactions |\n\nSources: [src/config/emitters.ts:1-133](), [src/function/event.ts:1-548](), [docs/internals.md:83-90]()\n\n## Event Emitter Taxonomy\n\nThe framework organizes 18 event emitters into six functional categories. Each emitter is a `functools-kit` Subject instance that implements the Observable pattern.\n\n```mermaid\ngraph TB\n    subgraph \"Signal Events\"\n        SE[\"signalEmitter<br/>IStrategyTickResult<br/>All signals\"]\n        SLE[\"signalLiveEmitter<br/>IStrategyTickResult<br/>Live only\"]\n        SBE[\"signalBacktestEmitter<br/>IStrategyTickResult<br/>Backtest only\"]\n    end\n    \n    subgraph \"Error Events\"\n        ERR[\"errorEmitter<br/>Error<br/>Recoverable errors\"]\n        EXIT[\"exitEmitter<br/>Error<br/>Fatal errors\"]\n        VAL[\"validationSubject<br/>Error<br/>Risk validation\"]\n    end\n    \n    subgraph \"Completion Events\"\n        DL[\"doneLiveSubject<br/>DoneContract<br/>Live complete\"]\n        DB[\"doneBacktestSubject<br/>DoneContract<br/>Backtest complete\"]\n        DW[\"doneWalkerSubject<br/>DoneContract<br/>Walker complete\"]\n    end\n    \n    subgraph \"Progress Events\"\n        PB[\"progressBacktestEmitter<br/>ProgressBacktestContract<br/>Timeframe progress\"]\n        PW[\"progressWalkerEmitter<br/>ProgressWalkerContract<br/>Strategy progress\"]\n        PO[\"progressOptimizerEmitter<br/>ProgressOptimizerContract<br/>Source progress\"]\n    end\n    \n    subgraph \"Walker Events\"\n        WE[\"walkerEmitter<br/>WalkerContract<br/>Strategy results\"]\n        WC[\"walkerCompleteSubject<br/>IWalkerResults<br/>Final results\"]\n        WS[\"walkerStopSubject<br/>WalkerStopContract<br/>Stop signals\"]\n    end\n    \n    subgraph \"Portfolio Events\"\n        PP[\"partialProfitSubject<br/>PartialProfitContract<br/>Profit milestones\"]\n        PL[\"partialLossSubject<br/>PartialLossContract<br/>Loss milestones\"]\n        RS[\"riskSubject<br/>RiskContract<br/>Risk rejections\"]\n        PERF[\"performanceEmitter<br/>PerformanceContract<br/>Execution metrics\"]\n    end\n```\n\n**Event Emitter Reference:**\n\n| Emitter | Payload Type | Purpose | Producers |\n|---------|-------------|---------|-----------|\n| `signalEmitter` | `IStrategyTickResult` | All signal events (live + backtest) | ClientStrategy |\n| `signalLiveEmitter` | `IStrategyTickResult` | Live trading signals only | LiveLogicPrivateService |\n| `signalBacktestEmitter` | `IStrategyTickResult` | Backtest signals only | BacktestLogicPrivateService |\n| `errorEmitter` | `Error` | Recoverable execution errors | Logic services |\n| `exitEmitter` | `Error` | Fatal errors requiring termination | Logic services |\n| `validationSubject` | `Error` | Risk validation failures | ClientRisk |\n| `doneLiveSubject` | `DoneContract` | Live execution completion | LiveLogicPrivateService |\n| `doneBacktestSubject` | `DoneContract` | Backtest completion | BacktestLogicPrivateService |\n| `doneWalkerSubject` | `DoneContract` | Walker completion | WalkerLogicPrivateService |\n| `progressBacktestEmitter` | `ProgressBacktestContract` | Backtest timeframe progress | BacktestLogicPrivateService |\n| `progressWalkerEmitter` | `ProgressWalkerContract` | Walker strategy progress | WalkerLogicPrivateService |\n| `progressOptimizerEmitter` | `ProgressOptimizerContract` | Optimizer source progress | OptimizerGlobalService |\n| `performanceEmitter` | `PerformanceContract` | Performance metrics | Logic services |\n| `walkerEmitter` | `WalkerContract` | Walker strategy results | WalkerLogicPrivateService |\n| `walkerCompleteSubject` | `IWalkerResults` | Walker final results | WalkerLogicPrivateService |\n| `walkerStopSubject` | `WalkerStopContract` | Walker stop signals (bidirectional) | User code / Logic |\n| `partialProfitSubject` | `PartialProfitContract` | Profit level milestones | ClientPartial |\n| `partialLossSubject` | `PartialLossContract` | Loss level milestones | ClientPartial |\n| `riskSubject` | `RiskContract` | Risk rejection events (rejections only) | ClientRisk |\n\nSources: [src/config/emitters.ts:15-132](), [types.d.ts:1-6000]()\n\n## Event Producers\n\nEvent producers are internal framework components that emit events during strategy execution, risk validation, and progress tracking. Understanding producers helps debug event flow and build custom event-driven logic.\n\n```mermaid\ngraph LR\n    subgraph \"Strategy Layer\"\n        CS[\"ClientStrategy<br/>tick() / backtest()\"]\n        CR[\"ClientRisk<br/>checkSignal()\"]\n        CP[\"ClientPartial<br/>profit() / loss()\"]\n    end\n    \n    subgraph \"Logic Layer\"\n        BLP[\"BacktestLogicPrivateService<br/>run()\"]\n        LLP[\"LiveLogicPrivateService<br/>run()\"]\n        WLP[\"WalkerLogicPrivateService<br/>run()\"]\n    end\n    \n    subgraph \"Global Layer\"\n        OPT[\"OptimizerGlobalService<br/>optimize()\"]\n    end\n    \n    CS -->|\"IStrategyTickResult\"| SE[\"signalEmitter\"]\n    CS -->|\"IStrategyTickResult\"| SLE[\"signalLiveEmitter\"]\n    CS -->|\"IStrategyTickResult\"| SBE[\"signalBacktestEmitter\"]\n    \n    CR -->|\"RiskContract\"| RS[\"riskSubject\"]\n    CR -->|\"Error\"| VAL[\"validationSubject\"]\n    \n    CP -->|\"PartialProfitContract\"| PP[\"partialProfitSubject\"]\n    CP -->|\"PartialLossContract\"| PL[\"partialLossSubject\"]\n    \n    BLP -->|\"ProgressBacktestContract\"| PB[\"progressBacktestEmitter\"]\n    BLP -->|\"DoneContract\"| DB[\"doneBacktestSubject\"]\n    BLP -->|\"PerformanceContract\"| PERF[\"performanceEmitter\"]\n    BLP -->|\"Error\"| ERR[\"errorEmitter / exitEmitter\"]\n    \n    LLP -->|\"DoneContract\"| DL[\"doneLiveSubject\"]\n    LLP -->|\"PerformanceContract\"| PERF\n    LLP -->|\"Error\"| ERR\n    \n    WLP -->|\"WalkerContract\"| WE[\"walkerEmitter\"]\n    WLP -->|\"IWalkerResults\"| WC[\"walkerCompleteSubject\"]\n    WLP -->|\"ProgressWalkerContract\"| PW[\"progressWalkerEmitter\"]\n    WLP -->|\"DoneContract\"| DW[\"doneWalkerSubject\"]\n    WLP -->|\"Error\"| ERR\n    \n    OPT -->|\"ProgressOptimizerContract\"| PO[\"progressOptimizerEmitter\"]\n```\n\n**Producer Emission Points:**\n\n| Producer | Method | Emitter | When | Line Reference |\n|----------|--------|---------|------|----------------|\n| ClientStrategy | `tick()` | `signalEmitter` | Every tick (idle/opened/active/closed/scheduled/cancelled) | Implementation in Client layer |\n| ClientStrategy | `tick()` | `signalLiveEmitter` | Only during Live.run() | Filtered by Logic service |\n| ClientStrategy | `tick()` | `signalBacktestEmitter` | Only during Backtest.run() | Filtered by Logic service |\n| ClientRisk | `checkSignal()` | `riskSubject` | When signal rejected by validation | Via onRejected callback |\n| ClientRisk | `checkSignal()` | `validationSubject` | When validation throws error | Exception handling |\n| ClientPartial | `profit()` | `partialProfitSubject` | When reaching 10%, 20%, 30%... profit | Set-based deduplication |\n| ClientPartial | `loss()` | `partialLossSubject` | When reaching 10%, 20%, 30%... loss | Set-based deduplication |\n| BacktestLogicPrivateService | `run()` | `progressBacktestEmitter` | After each timeframe | Loop iteration |\n| BacktestLogicPrivateService | `run()` | `doneBacktestSubject` | After all timeframes | Generator completion |\n| LiveLogicPrivateService | `run()` | `doneLiveSubject` | After stop() called | Graceful shutdown |\n| WalkerLogicPrivateService | `run()` | `walkerEmitter` | After each strategy backtest | Sequential execution |\n| WalkerLogicPrivateService | `run()` | `walkerCompleteSubject` | After all strategies | Final results |\n| WalkerLogicPrivateService | `run()` | `progressWalkerEmitter` | After each strategy | Progress tracking |\n| WalkerLogicPrivateService | `run()` | `doneWalkerSubject` | After completion | Generator done |\n\n**Signal Event Flow Example:**\n\nThe most common event flow is signal events from strategy execution:\n\n```mermaid\nsequenceDiagram\n    participant User as User Code\n    participant BLP as BacktestLogicPrivateService\n    participant SCS as StrategyCoreService\n    participant CS as ClientStrategy\n    participant SE as signalEmitter\n    participant SBE as signalBacktestEmitter\n    participant BMS as BacktestMarkdownService\n    \n    User->>BLP: Backtest.run(...)\n    activate BLP\n    loop Each Timeframe\n        BLP->>SCS: tick(symbol, when)\n        activate SCS\n        SCS->>CS: tick()\n        activate CS\n        CS->>CS: Generate/monitor signal\n        CS-->>SCS: IStrategyTickResult\n        deactivate CS\n        SCS->>SE: emit(result)\n        SCS->>SBE: emit(result)\n        SCS-->>BLP: result\n        deactivate SCS\n    end\n    BLP->>BLP: doneBacktestSubject.emit(...)\n    deactivate BLP\n    \n    SE->>BMS: subscribe callback\n    SBE->>BMS: subscribe callback\n    BMS->>BMS: Accumulate statistics\n```\n\nSources: [src/lib/services/logic/private/BacktestLogicPrivateService.ts](), [src/lib/services/logic/private/LiveLogicPrivateService.ts](), [src/lib/services/logic/private/WalkerLogicPrivateService.ts](), [src/lib/services/markdown/BacktestMarkdownService.ts:564-567]()\n\n## Event Listeners and Public API\n\nUser code subscribes to events via listener functions exported from [src/function/event.ts](). Each listener function wraps a Subject subscription with queued async processing to ensure sequential execution even when callbacks are async.\n\n```mermaid\ngraph TB\n    subgraph \"User Code\"\n        UC[\"User Callbacks<br/>async functions\"]\n    end\n    \n    subgraph \"Public API - src/function/event.ts\"\n        LS[\"listenSignal(fn)\"]\n        LSO[\"listenSignalOnce(filter, fn)\"]\n        LSL[\"listenSignalLive(fn)\"]\n        LSLO[\"listenSignalLiveOnce(filter, fn)\"]\n        LSB[\"listenSignalBacktest(fn)\"]\n        LSBO[\"listenSignalBacktestOnce(filter, fn)\"]\n        LE[\"listenError(fn)\"]\n        LEX[\"listenExit(fn)\"]\n        LDL[\"listenDoneLive(fn)\"]\n        LDLO[\"listenDoneLiveOnce(filter, fn)\"]\n        LDB[\"listenDoneBacktest(fn)\"]\n        LDBO[\"listenDoneBacktestOnce(filter, fn)\"]\n        LDW[\"listenDoneWalker(fn)\"]\n        LDWO[\"listenDoneWalkerOnce(filter, fn)\"]\n        LBP[\"listenBacktestProgress(fn)\"]\n        LWP[\"listenWalkerProgress(fn)\"]\n        LOP[\"listenOptimizerProgress(fn)\"]\n        LPF[\"listenPerformance(fn)\"]\n        LW[\"listenWalker(fn)\"]\n        LWO[\"listenWalkerOnce(filter, fn)\"]\n        LWC[\"listenWalkerComplete(fn)\"]\n        LV[\"listenValidation(fn)\"]\n        LPP[\"listenPartialProfit(fn)\"]\n        LPPO[\"listenPartialProfitOnce(filter, fn)\"]\n        LPL[\"listenPartialLoss(fn)\"]\n        LPLO[\"listenPartialLossOnce(filter, fn)\"]\n        LR[\"listenRisk(fn)\"]\n        LRO[\"listenRiskOnce(filter, fn)\"]\n    end\n    \n    subgraph \"Queued Wrapper - functools-kit\"\n        Q[\"queued(async fn)<br/>Sequential execution<br/>Order preservation\"]\n    end\n    \n    subgraph \"Event Emitters\"\n        SE[\"signalEmitter\"]\n        SLE[\"signalLiveEmitter\"]\n        SBE[\"signalBacktestEmitter\"]\n        ERR[\"errorEmitter\"]\n        EXIT[\"exitEmitter\"]\n        DL[\"doneLiveSubject\"]\n        DB[\"doneBacktestSubject\"]\n        DW[\"doneWalkerSubject\"]\n        PB[\"progressBacktestEmitter\"]\n        PW[\"progressWalkerEmitter\"]\n        PO[\"progressOptimizerEmitter\"]\n        PERF[\"performanceEmitter\"]\n        WE[\"walkerEmitter\"]\n        WC[\"walkerCompleteSubject\"]\n        VAL[\"validationSubject\"]\n        PP[\"partialProfitSubject\"]\n        PL[\"partialLossSubject\"]\n        RS[\"riskSubject\"]\n    end\n    \n    UC --> LS\n    UC --> LSO\n    UC --> LSL\n    UC --> LSLO\n    \n    LS --> Q\n    LSO --> Q\n    LSL --> Q\n    LSLO --> Q\n    \n    Q --> SE\n    Q --> SLE\n    Q --> SBE\n    Q --> ERR\n    \n    SE --> LS\n    SE --> LSO\n    SLE --> LSL\n    SLE --> LSLO\n    SBE --> LSB\n    SBE --> LSBO\n```\n\n**Listener Function Patterns:**\n\n| Pattern | Functions | Purpose | Example |\n|---------|-----------|---------|---------|\n| **Standard** | `listenSignal`, `listenError`, etc. | Subscribe to all events, runs on each | Monitor all signals |\n| **Once** | `listenSignalOnce`, `listenDoneLiveOnce`, etc. | Subscribe with filter, runs once, auto-unsubscribe | Wait for specific signal |\n| **Filtered** | `listenSignalLive`, `listenSignalBacktest` | Subscribe to subset of events | Separate live/backtest handling |\n| **Once + Filtered** | `listenSignalLiveOnce`, `listenSignalBacktestOnce` | Filtered subset, runs once | Wait for first live take profit |\n\n**Complete Listener API:**\n\n```typescript\n// Signal listeners - src/function/event.ts:70-221\nlistenSignal(fn: (event: IStrategyTickResult) => void) // All signals\nlistenSignalOnce(filter, fn) // Filtered, once\nlistenSignalLive(fn) // Live only\nlistenSignalLiveOnce(filter, fn) // Live only, once\nlistenSignalBacktest(fn) // Backtest only\nlistenSignalBacktestOnce(filter, fn) // Backtest only, once\n\n// Error listeners - src/function/event.ts:247-278\nlistenError(fn: (error: Error) => void) // Recoverable errors\nlistenExit(fn: (error: Error) => void) // Fatal errors\n\n// Completion listeners - src/function/event.ts:308-405\nlistenDoneLive(fn: (event: DoneContract) => void)\nlistenDoneLiveOnce(filter, fn)\nlistenDoneBacktest(fn: (event: DoneContract) => void)\nlistenDoneBacktestOnce(filter, fn)\nlistenDoneWalker(fn: (event: DoneContract) => void)\nlistenDoneWalkerOnce(filter, fn)\n\n// Progress listeners - src/function/event.ts:423-476\nlistenBacktestProgress(fn: (event: ProgressBacktestContract) => void)\nlistenWalkerProgress(fn: (event: ProgressWalkerContract) => void)\nlistenOptimizerProgress(fn: (event: ProgressOptimizerContract) => void)\n\n// Performance listeners - src/function/event.ts:491-500\nlistenPerformance(fn: (event: PerformanceContract) => void)\n\n// Walker listeners - src/function/event.ts:515-548\nlistenWalker(fn: (event: WalkerContract) => void)\nlistenWalkerOnce(filter, fn)\nlistenWalkerComplete(fn: (event: IWalkerResults) => void)\n\n// Validation listeners - src/function/event.ts\nlistenValidation(fn: (error: Error) => void)\n\n// Partial tracking listeners - src/function/event.ts\nlistenPartialProfit(fn: (event: PartialProfitContract) => void)\nlistenPartialProfitOnce(filter, fn)\nlistenPartialLoss(fn: (event: PartialLossContract) => void)\nlistenPartialLossOnce(filter, fn)\n\n// Risk listeners - src/function/event.ts\nlistenRisk(fn: (event: RiskContract) => void)\nlistenRiskOnce(filter, fn)\n```\n\nAll listener functions return an unsubscribe function to stop listening:\n\n```typescript\nconst unsubscribe = listenSignal((event) => {\n  console.log('Signal event:', event.action);\n});\n\n// Later: stop listening\nunsubscribe();\n```\n\nSources: [src/function/event.ts:45-548](), [types.d.ts:1-6000]()\n\n## Queued Async Processing\n\nAll listener functions wrap user callbacks with `queued()` from `functools-kit` to ensure sequential async execution. This prevents race conditions and maintains event ordering even when callbacks perform async operations like database writes or API calls.\n\n```mermaid\ngraph TB\n    subgraph \"Without Queued Wrapper - RACE CONDITION\"\n        E1[\"Event 1<br/>emitted\"]\n        E2[\"Event 2<br/>emitted\"]\n        E3[\"Event 3<br/>emitted\"]\n        C1[\"Callback 1<br/>starts async\"]\n        C2[\"Callback 2<br/>starts async\"]\n        C3[\"Callback 3<br/>starts async\"]\n        F1[\"Callback 2<br/>finishes first\"]\n        F2[\"Callback 3<br/>finishes second\"]\n        F3[\"Callback 1<br/>finishes last\"]\n        \n        E1 --> C1\n        E2 --> C2\n        E3 --> C3\n        C1 -.-> F3\n        C2 -.-> F1\n        C3 -.-> F2\n        \n        style F1 fill:#ffcccc\n        style F2 fill:#ffcccc\n        style F3 fill:#ffcccc\n    end\n    \n    subgraph \"With Queued Wrapper - ORDERED EXECUTION\"\n        Q1[\"Event 1<br/>emitted\"]\n        Q2[\"Event 2<br/>emitted\"]\n        Q3[\"Event 3<br/>emitted\"]\n        QC1[\"Callback 1<br/>starts\"]\n        QF1[\"Callback 1<br/>finishes\"]\n        QC2[\"Callback 2<br/>starts\"]\n        QF2[\"Callback 2<br/>finishes\"]\n        QC3[\"Callback 3<br/>starts\"]\n        QF3[\"Callback 3<br/>finishes\"]\n        \n        Q1 --> QC1\n        QC1 --> QF1\n        QF1 --> Q2\n        Q2 --> QC2\n        QC2 --> QF2\n        QF2 --> Q3\n        Q3 --> QC3\n        QC3 --> QF3\n        \n        style QF1 fill:#ccffcc\n        style QF2 fill:#ccffcc\n        style QF3 fill:#ccffcc\n    end\n```\n\n**Implementation Pattern:**\n\nEvery listener function in [src/function/event.ts]() follows this pattern:\n\n```typescript\n// Example from listenSignal - src/function/event.ts:70-73\nexport function listenSignal(fn: (event: IStrategyTickResult) => void) {\n  backtest.loggerService.log(LISTEN_SIGNAL_METHOD_NAME);\n  return signalEmitter.subscribe(queued(async (event) => fn(event)));\n  //                              ^^^^^^ Wraps callback for sequential execution\n}\n\n// Example from listenError - src/function/event.ts:247-250\nexport function listenError(fn: (error: Error) => void) {\n  backtest.loggerService.log(LISTEN_ERROR_METHOD_NAME);\n  return errorEmitter.subscribe(queued(async (error) => fn(error)));\n}\n```\n\n**Queued Processing Guarantees:**\n\n| Guarantee | Mechanism | Benefit |\n|-----------|-----------|---------|\n| **Sequential Execution** | Callbacks wait for previous to complete | No concurrent execution |\n| **Order Preservation** | Events processed in emission order | Predictable state transitions |\n| **Async Support** | Handles Promise-returning callbacks | Database writes, API calls |\n| **Error Isolation** | Errors in one callback don't block queue | Resilient processing |\n\n**Example Use Case - Database Persistence:**\n\n```typescript\n// Without queued: race condition on writes\nlistenSignal(async (event) => {\n  await database.write(event); // These writes can overlap and conflict!\n});\n\n// With queued (built-in): sequential writes\nlistenSignal(async (event) => {\n  await database.write(event); // Waits for previous write to complete\n});\n```\n\nThe `queued()` wrapper is critical for internal framework consumers like markdown services that accumulate events:\n\n```typescript\n// BacktestMarkdownService.init() - src/lib/services/markdown/BacktestMarkdownService.ts:564-567\nprotected init = singleshot(async () => {\n  this.loggerService.log(\"backtestMarkdownService init\");\n  signalBacktestEmitter.subscribe(this.tick);\n  //                                ^^^^^^^^^ Already uses queued internally\n});\n```\n\nSources: [src/function/event.ts:70-548](), [docs/internals.md:84-89]()\n\n## Event Payload Contracts\n\nEvent payloads are strongly typed interfaces (contracts) that define the data structure emitted by each event. All contracts are defined in [types.d.ts]() and exported contract files in [src/contract/]().\n\n```mermaid\ngraph TB\n    subgraph \"Signal Events\"\n        STR[\"IStrategyTickResult<br/>(Discriminated Union)\"]\n        IDLE[\"IStrategyTickResultIdle<br/>action: 'idle'\"]\n        SCHED[\"IStrategyTickResultScheduled<br/>action: 'scheduled'\"]\n        OPEN[\"IStrategyTickResultOpened<br/>action: 'opened'\"]\n        ACTV[\"IStrategyTickResultActive<br/>action: 'active'\"]\n        CLSD[\"IStrategyTickResultClosed<br/>action: 'closed'\"]\n        CNCL[\"IStrategyTickResultCancelled<br/>action: 'cancelled'\"]\n        \n        STR --> IDLE\n        STR --> SCHED\n        STR --> OPEN\n        STR --> ACTV\n        STR --> CLSD\n        STR --> CNCL\n    end\n    \n    subgraph \"Completion Events\"\n        DONE[\"DoneContract<br/>backtest, symbol, strategyName<br/>exchangeName, frameName\"]\n    end\n    \n    subgraph \"Progress Events\"\n        PB[\"ProgressBacktestContract<br/>symbol, strategyName<br/>processed, total\"]\n        PW[\"ProgressWalkerContract<br/>symbol, walkerName<br/>strategiesCompleted, totalStrategies\"]\n        PO[\"ProgressOptimizerContract<br/>symbol, optimizerName<br/>sourcesCompleted, totalSources\"]\n    end\n    \n    subgraph \"Walker Events\"\n        WC[\"WalkerContract<br/>symbol, walkerName<br/>strategyName, stats<br/>bestStrategy, bestMetric\"]\n        WR[\"IWalkerResults<br/>walkerName, symbol<br/>bestStrategy, bestMetric<br/>bestStats\"]\n    end\n    \n    subgraph \"Portfolio Events\"\n        PP[\"PartialProfitContract<br/>symbol, data, price<br/>level, backtest\"]\n        PL[\"PartialLossContract<br/>symbol, data, price<br/>level, backtest\"]\n        RS[\"RiskContract<br/>symbol, params<br/>activePositionCount<br/>comment\"]\n    end\n    \n    subgraph \"Performance Events\"\n        PERF[\"PerformanceContract<br/>strategyName, metricType<br/>duration, timestamp\"]\n    end\n```\n\n**Contract Definitions:**\n\n| Contract | File | Key Fields | Purpose |\n|----------|------|-----------|---------|\n| `IStrategyTickResult` | types.d.ts:974-1007 | `action`, `signal`, `strategyName`, `symbol` | Discriminated union for all signal states |\n| `DoneContract` | src/contract/Done.contract.ts | `backtest`, `symbol`, `strategyName`, `exchangeName`, `frameName` | Execution completion notification |\n| `ProgressBacktestContract` | src/contract/ProgressBacktest.contract.ts | `symbol`, `strategyName`, `exchangeName`, `frameName`, `processed`, `total` | Backtest timeframe progress |\n| `ProgressWalkerContract` | src/contract/ProgressWalker.contract.ts | `symbol`, `walkerName`, `strategiesCompleted`, `totalStrategies` | Walker strategy progress |\n| `ProgressOptimizerContract` | src/contract/ProgressOptimizer.contract.ts | `symbol`, `optimizerName`, `sourcesCompleted`, `totalSources` | Optimizer source progress |\n| `PerformanceContract` | src/contract/Performance.contract.ts | `strategyName`, `metricType`, `duration`, `timestamp`, `previousTimestamp` | Performance profiling |\n| `WalkerContract` | src/contract/Walker.contract.ts | `symbol`, `walkerName`, `strategyName`, `stats`, `metricValue`, `bestStrategy`, `bestMetric` | Walker strategy result |\n| `IWalkerResults` | types.d.ts:1326-1356 | `walkerName`, `symbol`, `bestStrategy`, `bestMetric`, `bestStats` | Walker final results |\n| `PartialProfitContract` | src/contract/PartialProfit.contract.ts | `symbol`, `data`, `currentPrice`, `level`, `backtest`, `timestamp` | Profit milestone reached |\n| `PartialLossContract` | src/contract/PartialLoss.contract.ts | `symbol`, `data`, `currentPrice`, `level`, `backtest`, `timestamp` | Loss milestone reached |\n| `RiskContract` | src/contract/Risk.contract.ts | `symbol`, `params`, `activePositionCount`, `comment`, `timestamp` | Risk validation rejection |\n\n**Signal Event Discriminated Union:**\n\nThe most complex contract is `IStrategyTickResult`, which uses TypeScript discriminated unions for type-safe signal state handling:\n\n```typescript\n// Type guard example\nif (event.action === 'closed') {\n  // TypeScript knows event is IStrategyTickResultClosed\n  console.log(event.pnl.pnlPercentage); // Type-safe access\n  console.log(event.closeReason); // 'take_profit' | 'stop_loss' | 'time_expired'\n} else if (event.action === 'opened') {\n  // TypeScript knows event is IStrategyTickResultOpened\n  console.log(event.signal.priceOpen);\n}\n```\n\nSources: [types.d.ts:974-1007](), [src/contract/Done.contract.ts](), [src/contract/ProgressBacktest.contract.ts](), [src/contract/Walker.contract.ts](), [src/contract/PartialProfit.contract.ts](), [src/contract/PartialLoss.contract.ts](), [src/contract/Risk.contract.ts](), [src/contract/Performance.contract.ts]()\n\n## Internal Event Consumers\n\nInternal framework components subscribe to events for automated report generation and statistics collection. These consumers run transparently without user configuration.\n\n```mermaid\ngraph LR\n    subgraph \"Event Emitters\"\n        SBE[\"signalBacktestEmitter\"]\n        SLE[\"signalLiveEmitter\"]\n        SE[\"signalEmitter\"]\n        PP[\"partialProfitSubject\"]\n        PL[\"partialLossSubject\"]\n        RS[\"riskSubject\"]\n        PERF[\"performanceEmitter\"]\n        WE[\"walkerEmitter\"]\n    end\n    \n    subgraph \"Markdown Services - Internal Consumers\"\n        BMS[\"BacktestMarkdownService<br/>MAX_EVENTS: 250<br/>Closed signals only\"]\n        LMS[\"LiveMarkdownService<br/>MAX_EVENTS: 250<br/>All tick types\"]\n        SMS[\"ScheduleMarkdownService<br/>MAX_EVENTS: 250<br/>Scheduled/cancelled\"]\n        PMS[\"PartialMarkdownService<br/>MAX_EVENTS: 250<br/>Profit/loss milestones\"]\n        RMS[\"RiskMarkdownService<br/>Unbounded<br/>Risk rejections\"]\n        HMS[\"HeatMarkdownService<br/>Unbounded<br/>Symbol statistics\"]\n        PERMS[\"PerformanceMarkdownService<br/>MAX_EVENTS: 10000<br/>Execution metrics\"]\n        WMS[\"WalkerMarkdownService<br/>Unbounded<br/>Strategy comparison\"]\n    end\n    \n    subgraph \"Report Generation\"\n        RPT[\"getData()<br/>getReport()<br/>dump()\"]\n    end\n    \n    SBE -->|\"subscribe(tick)\"| BMS\n    SLE -->|\"subscribe(tick)\"| LMS\n    SE -->|\"subscribe(tick)\"| SMS\n    SE -->|\"subscribe(tick)\"| HMS\n    PP -->|\"subscribe\"| PMS\n    PL -->|\"subscribe\"| PMS\n    RS -->|\"subscribe\"| RMS\n    PERF -->|\"subscribe\"| PERMS\n    WE -->|\"subscribe\"| WMS\n    \n    BMS --> RPT\n    LMS --> RPT\n    SMS --> RPT\n    PMS --> RPT\n    RMS --> RPT\n    HMS --> RPT\n    PERMS --> RPT\n    WMS --> RPT\n```\n\n**Markdown Service Subscriptions:**\n\n| Service | Subscribed Emitters | Event Filter | Storage Limit | Purpose |\n|---------|-------------------|--------------|---------------|---------|\n| BacktestMarkdownService | `signalBacktestEmitter` | `action === 'closed'` | 250 events | Closed signal statistics |\n| LiveMarkdownService | `signalLiveEmitter` | All actions | 250 events | Live trading log |\n| ScheduleMarkdownService | `signalEmitter` | `action === 'scheduled' \\| 'opened' \\| 'cancelled'` | 250 events | Scheduled signal tracking |\n| HeatMarkdownService | `signalEmitter` | `action === 'closed'` | Unbounded (per symbol) | Portfolio heatmap |\n| PartialMarkdownService | `partialProfitSubject`, `partialLossSubject` | All | 250 events | Partial profit/loss log |\n| RiskMarkdownService | `riskSubject` | All | Unbounded | Risk rejection log |\n| PerformanceMarkdownService | `performanceEmitter` | All | 10000 events | Performance profiling |\n| WalkerMarkdownService | `walkerEmitter` | All | Unbounded | Strategy comparison |\n\n**Initialization Pattern:**\n\nAll markdown services use the `singleshot` pattern to subscribe on first use:\n\n```typescript\n// BacktestMarkdownService - src/lib/services/markdown/BacktestMarkdownService.ts:564-567\nprotected init = singleshot(async () => {\n  this.loggerService.log(\"backtestMarkdownService init\");\n  signalBacktestEmitter.subscribe(this.tick);\n});\n\n// LiveMarkdownService - src/lib/services/markdown/LiveMarkdownService.ts:771-774\nprotected init = singleshot(async () => {\n  this.loggerService.log(\"liveMarkdownService init\");\n  signalLiveEmitter.subscribe(this.tick);\n});\n```\n\n**Bounded Queue Pattern:**\n\nServices with `MAX_EVENTS` limits use a bounded queue to prevent memory leaks:\n\n```typescript\n// LiveMarkdownService - src/lib/services/markdown/LiveMarkdownService.ts:296-300\nthis._eventList.unshift(newEvent);\nif (this._eventList.length > MAX_EVENTS) {\n  this._eventList.pop(); // Remove oldest event\n}\n```\n\nThis ensures long-running live trading sessions don't accumulate unbounded event history.\n\n**Report Access:**\n\nUser code accesses accumulated statistics via public classes:\n\n```typescript\nimport { Backtest, Live, Schedule, Heat, Partial, Risk, Performance, Walker } from 'backtest-kit';\n\n// Get statistics\nconst backtestStats = await Backtest.getData(\"BTCUSDT\", \"my-strategy\");\nconst liveStats = await Live.getData(\"BTCUSDT\", \"my-strategy\");\n\n// Generate markdown report\nconst report = await Backtest.getReport(\"BTCUSDT\", \"my-strategy\");\n\n// Save to disk\nawait Backtest.dump(\"BTCUSDT\", \"my-strategy\", \"./reports\");\n```\n\nSources: [src/lib/services/markdown/BacktestMarkdownService.ts:564-567](), [src/lib/services/markdown/LiveMarkdownService.ts:771-774](), [src/lib/services/markdown/LiveMarkdownService.ts:258-300](), [src/lib/services/markdown/ScheduleMarkdownService.ts](), [src/lib/services/markdown/HeatMarkdownService.ts](), [src/lib/services/markdown/PartialMarkdownService.ts](), [src/lib/services/markdown/RiskMarkdownService.ts](), [src/lib/services/markdown/PerformanceMarkdownService.ts](), [src/lib/services/markdown/WalkerMarkdownService.ts]()\n\n## Common Event Flow Patterns\n\nThis section demonstrates common event flow patterns for typical use cases.\n\n### Pattern 1: Monitoring All Signals\n\nSubscribe to all signals regardless of execution mode:\n\n```mermaid\nsequenceDiagram\n    participant User as User Code\n    participant SE as signalEmitter\n    participant Q as queued()\n    participant CB as User Callback\n    \n    User->>SE: listenSignal(callback)\n    Note over User,SE: Returns unsubscribe function\n    \n    loop Strategy Execution\n        Note over SE: Signal emitted (any mode)\n        SE->>Q: emit(event)\n        Q->>Q: Wait for previous callback\n        Q->>CB: invoke(event)\n        CB-->>Q: complete\n    end\n    \n    User->>SE: unsubscribe()\n```\n\nSources: [src/function/event.ts:70-73]()\n\n### Pattern 2: Waiting for Specific Event\n\nUse `listenSignalOnce` to wait for a specific condition:\n\n```mermaid\nsequenceDiagram\n    participant User as User Code\n    participant SE as signalEmitter\n    participant F as filter()\n    participant O as once()\n    participant CB as User Callback\n    \n    User->>SE: listenSignalOnce(filter, callback)\n    Note over User,SE: Auto-unsubscribes after one match\n    \n    loop Until Match\n        SE->>F: emit(event)\n        alt Filter matches\n            F->>O: pass through\n            O->>CB: invoke(event)\n            CB-->>O: complete\n            O->>O: Auto-unsubscribe\n        else Filter rejects\n            F->>F: Discard event\n        end\n    end\n```\n\nSources: [src/function/event.ts:107-113]()\n\n### Pattern 3: Background Execution with Completion\n\nStart background task and wait for completion:\n\n```mermaid\nsequenceDiagram\n    participant User as User Code\n    participant BG as Backtest.background()\n    participant BLP as BacktestLogicPrivateService\n    participant DBS as doneBacktestSubject\n    participant CB as Completion Callback\n    \n    User->>DBS: listenDoneBacktest(callback)\n    User->>BG: start execution\n    \n    BG->>BLP: async generator execution\n    \n    loop Timeframes\n        BLP->>BLP: Process timeframe\n    end\n    \n    BLP->>DBS: emit(DoneContract)\n    DBS->>CB: invoke({ backtest: true, symbol, ... })\n    CB-->>User: Notify completion\n```\n\nSources: [src/function/event.ts:375-382](), [src/classes/Backtest.ts]()\n\n### Pattern 4: Progress Tracking\n\nMonitor backtest or walker progress:\n\n```mermaid\nsequenceDiagram\n    participant User as User Code\n    participant PBE as progressBacktestEmitter\n    participant UI as Progress UI\n    \n    User->>PBE: listenBacktestProgress(callback)\n    \n    loop Each Timeframe\n        Note over PBE: Timeframe processed\n        PBE->>UI: { symbol, processed, total }\n        UI->>UI: Update progress bar\n        Note over UI: processed/total * 100%\n    end\n```\n\nSources: [src/function/event.ts:423-432]()\n\n### Pattern 5: Risk Rejection Monitoring\n\nTrack signals rejected by risk management:\n\n```mermaid\nsequenceDiagram\n    participant CS as ClientStrategy\n    participant CR as ClientRisk\n    participant RS as riskSubject\n    participant Log as Logging System\n    \n    CS->>CR: checkSignal(params)\n    CR->>CR: Run validations\n    \n    alt Validation Fails\n        CR->>RS: emit(RiskContract)\n        Note over RS: Only rejections emitted\n        RS->>Log: { symbol, comment, activePositionCount }\n        Log->>Log: Record rejection\n        CR-->>CS: return false\n    else Validation Passes\n        Note over CR: No event emitted\n        CR-->>CS: return true\n    end\n```\n\nThe `riskSubject` only emits rejection events to prevent spam from allowed signals.\n\nSources: [src/config/emitters.ts:127-132](), [types.d.ts:2244-2267]()\n\n### Pattern 6: Partial Profit/Loss Tracking\n\nMonitor profit/loss milestones:\n\n```mermaid\nsequenceDiagram\n    participant CS as ClientStrategy\n    participant CP as ClientPartial\n    participant PP as partialProfitSubject\n    participant PL as partialLossSubject\n    participant User as User Callback\n    \n    CS->>CP: profit(symbol, data, price, 15.5%, ...)\n    \n    CP->>CP: Check levels reached\n    Note over CP: 10% threshold crossed\n    CP->>PP: emit({ level: 10, ... })\n    PP->>User: Notify +10% profit\n    \n    Note over CP: Store in Set (dedup)\n    \n    CS->>CP: profit(symbol, data, price, 22.3%, ...)\n    CP->>CP: Check levels reached\n    Note over CP: 20% threshold crossed\n    CP->>PP: emit({ level: 20, ... })\n    PP->>User: Notify +20% profit\n    \n    Note over CP: 10% already emitted, skip\n```\n\nSources: [src/config/emitters.ts:115-124](), [types.d.ts:694-847]()\n\n## Bidirectional Event: Walker Stop\n\nThe `walkerStopSubject` is unique—it's bidirectional, allowing both user code and internal logic to communicate stop signals.\n\n```mermaid\ngraph TB\n    subgraph \"User Code\"\n        UC[\"User Code<br/>Walker.stop(symbol, walkerName)\"]\n    end\n    \n    subgraph \"Walker Stop Subject\"\n        WSS[\"walkerStopSubject<br/>(Bidirectional)\"]\n    end\n    \n    subgraph \"Walker Logic\"\n        WLP[\"WalkerLogicPrivateService<br/>Subscribes to stop signals\"]\n    end\n    \n    UC -->|\"emit(WalkerStopContract)\"| WSS\n    WSS -->|\"subscribe\"| WLP\n    WLP -->|\"Checks symbol + walkerName\"| WLP\n    WLP -->|\"Break execution loop\"| WLP\n```\n\n**Stop Signal Flow:**\n\n```typescript\n// User initiates stop - src/classes/Walker.ts\nWalker.stop(\"BTCUSDT\", \"my-walker\");\n// Emits: { symbol: \"BTCUSDT\", walkerName: \"my-walker\" }\n\n// WalkerLogicPrivateService subscribes\nwalkerStopSubject.subscribe((stop) => {\n  if (stop.symbol === symbol && stop.walkerName === walkerName) {\n    // Break execution loop\n    return;\n  }\n});\n```\n\nThis enables graceful cancellation of long-running walker comparisons without process termination.\n\nSources: [src/config/emitters.ts:100-107](), [src/contract/WalkerStop.contract.ts]()\n\n## Summary\n\nThe event-driven architecture in backtest-kit provides:\n\n| Feature | Implementation | Benefit |\n|---------|---------------|---------|\n| **Decoupling** | Subject-based pub/sub | Producers independent of consumers |\n| **Type Safety** | Strongly typed contracts | Compile-time validation |\n| **Ordering** | Queued async processing | Sequential event handling |\n| **Filtering** | Separate emitters + filter predicates | Targeted subscriptions |\n| **Once Semantics** | `Once` listener variants | Single-shot reactions |\n| **Bounded Queues** | MAX_EVENTS limits | Memory leak prevention |\n| **Automated Reports** | Internal markdown consumers | Zero-config statistics |\n| **Bidirectional** | walkerStopSubject | Graceful cancellation |\n\nThe architecture supports both internal framework operations (markdown reports, statistics) and user-defined event-driven logic (monitoring, alerting, custom analytics) through a consistent API.\n\nSources: [src/config/emitters.ts:1-133](), [src/function/event.ts:1-548](), [docs/internals.md:83-90]()"
                    },
                    {
                        "page_plan": {
                            "id": "3",
                            "title": "System Architecture"
                        },
                        "content": "# System Architecture\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [assets/uml.svg](assets/uml.svg)\n- [docs/classes/WalkerCommandService.md](docs/classes/WalkerCommandService.md)\n- [docs/interfaces/BacktestStatistics.md](docs/interfaces/BacktestStatistics.md)\n- [docs/interfaces/IStrategyCallbacks.md](docs/interfaces/IStrategyCallbacks.md)\n- [docs/interfaces/LiveStatistics.md](docs/interfaces/LiveStatistics.md)\n- [docs/internals.md](docs/internals.md)\n- [docs/types/IStrategyTickResult.md](docs/types/IStrategyTickResult.md)\n- [docs/uml.puml](docs/uml.puml)\n- [scripts/uml.mjs](scripts/uml.mjs)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/add.ts](src/function/add.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/function/list.ts](src/function/list.ts)\n- [src/index.ts](src/index.ts)\n- [src/lib/core/provide.ts](src/lib/core/provide.ts)\n- [src/lib/core/types.ts](src/lib/core/types.ts)\n- [src/lib/index.ts](src/lib/index.ts)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\nThis document provides an overview of the backtest-kit framework's architectural patterns, including its layered design, dependency injection system, service organization, and the central `backtest` aggregation object. This page focuses on structural patterns and component organization rather than specific features or execution flows.\n\nFor detailed information about:\n- Individual layer responsibilities, see [Layered Architecture](#3.1)\n- The DI container implementation, see [Dependency Injection System](#3.2)\n- Service category descriptions and responsibilities, see [Service Categories](#3.3)\n- Client implementations and business logic, see [Client Layer](#3.4)\n\n---\n\n## Architectural Overview\n\nThe framework follows clean architecture principles with strict separation of concerns. The architecture consists of five distinct layers that interact through well-defined interfaces, with dependency injection managing component lifecycle and dependencies.\n\n**Overall System Layers**\n\n```mermaid\ngraph TB\n    subgraph \"Layer 1: Public API\"\n        PublicAPI[\"Public Functions<br/>addStrategy, addExchange, addFrame<br/>Backtest.run, Live.run, Walker.run<br/>listenSignal, listenError\"]\n    end\n    \n    subgraph \"Layer 2: Orchestration\"\n        Backtest[\"Backtest<br/>Historical simulation\"]\n        Live[\"Live<br/>Real-time trading\"]\n        Walker[\"Walker<br/>Strategy comparison\"]\n        Optimizer[\"Optimizer<br/>LLM code generation\"]\n    end\n    \n    subgraph \"Layer 3: Service (Dependency Injection)\"\n        CommandServices[\"Command Services<br/>BacktestCommandService<br/>LiveCommandService<br/>WalkerCommandService\"]\n        LogicServices[\"Logic Services<br/>BacktestLogicPublicService<br/>BacktestLogicPrivateService<br/>Generator patterns\"]\n        GlobalServices[\"Global Services<br/>SizingGlobalService<br/>RiskGlobalService<br/>Context wrappers\"]\n        CoreServices[\"Core Services<br/>StrategyCoreService<br/>ExchangeCoreService<br/>FrameCoreService\"]\n        ConnectionServices[\"Connection Services<br/>StrategyConnectionService<br/>Memoized client factories\"]\n        ValidationServices[\"Validation Services<br/>StrategyValidationService<br/>Schema enforcement\"]\n        SchemaServices[\"Schema Services<br/>StrategySchemaService<br/>Configuration registry\"]\n        MarkdownServices[\"Markdown Services<br/>BacktestMarkdownService<br/>Report generation\"]\n    end\n    \n    subgraph \"Layer 4: Client (Business Logic)\"\n        ClientStrategy[\"ClientStrategy<br/>Signal lifecycle<br/>tick, backtest methods\"]\n        ClientExchange[\"ClientExchange<br/>Data fetching<br/>VWAP calculation\"]\n        ClientFrame[\"ClientFrame<br/>Timeframe generation\"]\n        ClientRisk[\"ClientRisk<br/>Portfolio validation\"]\n        ClientOptimizer[\"ClientOptimizer<br/>LLM integration\"]\n        ClientPartial[\"ClientPartial<br/>P/L tracking\"]\n    end\n    \n    subgraph \"Layer 5: Persistence\"\n        PersistSignal[\"PersistSignalAdapter<br/>JSON file I/O<br/>Atomic writes\"]\n        PersistSchedule[\"PersistScheduleAdapter<br/>Scheduled signals\"]\n        PersistRisk[\"PersistRiskAdapter<br/>Risk state\"]\n        PersistPartial[\"PersistPartialAdapter<br/>Partial levels\"]\n    end\n    \n    PublicAPI --> Backtest\n    PublicAPI --> Live\n    PublicAPI --> Walker\n    PublicAPI --> Optimizer\n    \n    Backtest --> CommandServices\n    Live --> CommandServices\n    Walker --> CommandServices\n    \n    CommandServices --> LogicServices\n    LogicServices --> GlobalServices\n    LogicServices --> CoreServices\n    \n    GlobalServices --> ConnectionServices\n    CoreServices --> ConnectionServices\n    ConnectionServices --> ValidationServices\n    ConnectionServices --> SchemaServices\n    \n    ConnectionServices --> ClientStrategy\n    ConnectionServices --> ClientExchange\n    ConnectionServices --> ClientFrame\n    ConnectionServices --> ClientRisk\n    ConnectionServices --> ClientOptimizer\n    ConnectionServices --> ClientPartial\n    \n    ClientStrategy --> PersistSignal\n    ClientStrategy --> PersistSchedule\n    ClientRisk --> PersistRisk\n    ClientPartial --> PersistPartial\n    \n    LogicServices --> MarkdownServices\n```\n\n**Sources:** [docs/internals.md:28-40](), [src/lib/index.ts:1-242]()\n\n---\n\n## Layered Architecture\n\nThe framework implements a five-layer architecture where each layer has distinct responsibilities and dependencies flow in one direction (top to bottom). Higher layers depend on lower layers, but not vice versa.\n\n| Layer | Purpose | Key Characteristics |\n|-------|---------|---------------------|\n| **Public API** | User-facing functions for configuration and execution | Simple function exports, validation-only logic, delegates to orchestration layer |\n| **Orchestration** | Execution mode implementations (Backtest, Live, Walker, Optimizer) | Class-based, background/run methods, async generators, event emission |\n| **Service** | Dependency-injected business logic organized by responsibility | 11 service categories, Symbol-based DI, singleton instances |\n| **Client** | Pure business logic without DI dependencies | Prototype-based classes, memoized instances, domain logic |\n| **Persistence** | Crash-safe state storage and recovery | Atomic writes, JSON serialization, extensible adapters |\n\nThe layered design ensures:\n- **Testability**: Each layer can be tested in isolation\n- **Maintainability**: Changes to one layer don't cascade to others\n- **Scalability**: New features added at appropriate layers\n- **Clarity**: Responsibilities clearly separated\n\n**Sources:** [docs/internals.md:28-40](), [types.d.ts:1-100]()\n\nFor detailed layer descriptions, see [Layered Architecture](#3.1).\n\n---\n\n## Dependency Injection System\n\nThe framework uses a custom dependency injection container built around Symbol-based keys. The DI system consists of three core components:\n\n**Dependency Injection Components**\n\n```mermaid\ngraph LR\n    subgraph \"types.ts\"\n        TYPES[\"TYPES object<br/>Symbol definitions\"]\n        baseServices[\"baseServices<br/>loggerService: Symbol\"]\n        contextServices[\"contextServices<br/>executionContextService: Symbol<br/>methodContextService: Symbol\"]\n        schemaServices[\"schemaServices<br/>7 schema service Symbols\"]\n        validationServices[\"validationServices<br/>8 validation service Symbols\"]\n        connectionServices[\"connectionServices<br/>7 connection service Symbols\"]\n        coreServices[\"coreServices<br/>3 core service Symbols\"]\n        globalServices[\"globalServices<br/>4 global service Symbols\"]\n        commandServices[\"commandServices<br/>3 command service Symbols\"]\n        logicServices[\"logicPrivateServices + logicPublicServices<br/>6 logic service Symbols\"]\n        markdownServices[\"markdownServices<br/>9 markdown service Symbols\"]\n        templateServices[\"templateServices<br/>optimizerTemplateService: Symbol\"]\n    end\n    \n    subgraph \"provide.ts\"\n        provideLoggerService[\"provide(TYPES.loggerService, () => new LoggerService())\"]\n        provideStrategySchema[\"provide(TYPES.strategySchemaService, () => new StrategySchemaService())\"]\n        provideStrategyConnection[\"provide(TYPES.strategyConnectionService, () => new StrategyConnectionService())\"]\n        provideBacktestCommand[\"provide(TYPES.backtestCommandService, () => new BacktestCommandService())\"]\n        provideMore[\"...50+ service registrations\"]\n    end\n    \n    subgraph \"lib/index.ts\"\n        backtestObject[\"backtest = {...}<br/>Singleton aggregation object\"]\n        inject[\"inject<T>(symbol: Symbol)<br/>Resolves service instances\"]\n        init[\"init()<br/>Initialize DI container\"]\n    end\n    \n    TYPES --> provideLoggerService\n    TYPES --> provideStrategySchema\n    TYPES --> provideStrategyConnection\n    TYPES --> provideBacktestCommand\n    TYPES --> provideMore\n    \n    provideLoggerService --> inject\n    provideStrategySchema --> inject\n    provideStrategyConnection --> inject\n    provideBacktestCommand --> inject\n    provideMore --> inject\n    \n    inject --> backtestObject\n    init --> backtestObject\n```\n\n**Sources:** [src/lib/core/types.ts:1-104](), [src/lib/core/provide.ts:1-141](), [src/lib/index.ts:1-242]()\n\n### Symbol-Based Keys\n\nEach service is registered using a unique Symbol identifier defined in [src/lib/core/types.ts:1-104](). Symbols prevent naming collisions and provide type-safe service resolution:\n\n```typescript\n// From types.ts\nconst baseServices = {\n    loggerService: Symbol('loggerService'),\n};\n\nconst schemaServices = {\n    strategySchemaService: Symbol('strategySchemaService'),\n    exchangeSchemaService: Symbol('exchangeSchemaService'),\n    // ...\n};\n```\n\n**Sources:** [src/lib/core/types.ts:1-28]()\n\n### Service Registration\n\nServices are registered via factory functions in [src/lib/core/provide.ts:1-141](). Each registration associates a Symbol key with a factory that creates the service instance:\n\n```typescript\n// From provide.ts\nprovide(TYPES.loggerService, () => new LoggerService());\nprovide(TYPES.strategySchemaService, () => new StrategySchemaService());\nprovide(TYPES.strategyConnectionService, () => new StrategyConnectionService());\n```\n\n**Sources:** [src/lib/core/provide.ts:55-141]()\n\n### The `backtest` Aggregation Object\n\nThe [src/lib/index.ts:221-234]() exports a singleton `backtest` object that aggregates all services. This object serves as the central service locator, providing typed access to every service in the system:\n\n```typescript\n// From lib/index.ts\nexport const backtest = {\n  ...baseServices,\n  ...contextServices,\n  ...connectionServices,\n  ...schemaServices,\n  ...coreServices,\n  ...globalServices,\n  ...commandServices,\n  ...logicPrivateServices,\n  ...logicPublicServices,\n  ...markdownServices,\n  ...validationServices,\n  ...templateServices,\n};\n```\n\nInternal services access dependencies through this object (e.g., `backtest.loggerService`, `backtest.strategyConnectionService`).\n\n**Sources:** [src/lib/index.ts:221-242]()\n\nFor implementation details, see [Dependency Injection System](#3.2).\n\n---\n\n## Service Categories\n\nThe service layer is organized into 11 categories, each with a specific responsibility. Services are implemented as classes with prototype methods for memory efficiency.\n\n| Category | Count | Responsibility | Example Services |\n|----------|-------|----------------|------------------|\n| **Base** | 1 | Core infrastructure | `LoggerService` |\n| **Context** | 2 | Execution context propagation | `ExecutionContextService`, `MethodContextService` |\n| **Schema** | 7 | Configuration registry (ToolRegistry pattern) | `StrategySchemaService`, `ExchangeSchemaService`, `FrameSchemaService`, `RiskSchemaService`, `SizingSchemaService`, `WalkerSchemaService`, `OptimizerSchemaService` |\n| **Validation** | 8 | Runtime validation and memoization | `StrategyValidationService`, `ExchangeValidationService`, `FrameValidationService`, `RiskValidationService`, `SizingValidationService`, `WalkerValidationService`, `OptimizerValidationService`, `ConfigValidationService` |\n| **Connection** | 7 | Memoized client instance factories | `StrategyConnectionService`, `ExchangeConnectionService`, `FrameConnectionService`, `RiskConnectionService`, `SizingConnectionService`, `OptimizerConnectionService`, `PartialConnectionService` |\n| **Core** | 3 | Domain logic execution | `StrategyCoreService`, `ExchangeCoreService`, `FrameCoreService` |\n| **Global** | 4 | Context-wrapped public API | `SizingGlobalService`, `RiskGlobalService`, `OptimizerGlobalService`, `PartialGlobalService` |\n| **Command** | 3 | High-level orchestration entry points | `BacktestCommandService`, `LiveCommandService`, `WalkerCommandService` |\n| **Logic** | 6 | Async generator execution flow (Public/Private splits) | `BacktestLogicPublicService`, `BacktestLogicPrivateService`, `LiveLogicPublicService`, `LiveLogicPrivateService`, `WalkerLogicPublicService`, `WalkerLogicPrivateService` |\n| **Markdown** | 9 | Report generation and statistics | `BacktestMarkdownService`, `LiveMarkdownService`, `ScheduleMarkdownService`, `WalkerMarkdownService`, `PerformanceMarkdownService`, `HeatMarkdownService`, `PartialMarkdownService`, `RiskMarkdownService`, `OutlineMarkdownService` |\n| **Template** | 1 | Code generation templates | `OptimizerTemplateService` |\n\n**Sources:** [src/lib/index.ts:60-219](), [src/lib/core/types.ts:1-104]()\n\n### Service Dependency Patterns\n\nServices follow consistent dependency patterns:\n\n1. **Schema Services** → Store configuration using ToolRegistry pattern, no dependencies\n2. **Validation Services** → Depend on Schema Services for existence checks\n3. **Connection Services** → Depend on Schema Services, create memoized client instances\n4. **Core Services** → Depend on Connection and Validation Services, execute domain logic\n5. **Global Services** → Wrap Core Services with ExecutionContext/MethodContext\n6. **Logic Services** → Depend on Core Services, implement async generators\n7. **Command Services** → Depend on Logic and Validation Services, validate and execute\n\n**Sources:** [docs/internals.md:31-37]()\n\nFor detailed service descriptions, see [Service Categories](#3.3).\n\n---\n\n## Client Layer\n\nThe client layer contains pure business logic implementations without DI dependencies. Clients are instantiated by Connection Services and cached using memoization.\n\n**Client Layer Architecture**\n\n```mermaid\ngraph TB\n    subgraph \"Connection Services (Memoized Factories)\"\n        StrategyConnectionService[\"StrategyConnectionService<br/>getStrategy(symbol, strategyName)<br/>Memoization key: symbol:strategyName\"]\n        ExchangeConnectionService[\"ExchangeConnectionService<br/>getExchange(exchangeName)<br/>Memoization key: exchangeName\"]\n        FrameConnectionService[\"FrameConnectionService<br/>getFrame(frameName)<br/>Memoization key: frameName\"]\n        RiskConnectionService[\"RiskConnectionService<br/>getRisk(riskName)<br/>Memoization key: riskName\"]\n        SizingConnectionService[\"SizingConnectionService<br/>getSizing(sizingName)<br/>Memoization key: sizingName\"]\n        OptimizerConnectionService[\"OptimizerConnectionService<br/>getOptimizer(optimizerName)<br/>Memoization key: optimizerName\"]\n        PartialConnectionService[\"PartialConnectionService<br/>getPartial(symbol)<br/>Memoization key: symbol\"]\n    end\n    \n    subgraph \"Client Implementations (Business Logic)\"\n        ClientStrategy[\"ClientStrategy<br/>tick() - Signal generation throttling<br/>backtest() - Fast candle processing<br/>waitForInit() - State recovery\"]\n        ClientExchange[\"ClientExchange<br/>getCandles() - Historical data<br/>getNextCandles() - Future data<br/>getAveragePrice() - VWAP calculation\"]\n        ClientFrame[\"ClientFrame<br/>getTimeframe() - Date iteration<br/>Interval-based generation\"]\n        ClientRisk[\"ClientRisk<br/>checkSignal() - Portfolio validation<br/>addSignal/removeSignal() - Position tracking\"]\n        ClientSizing[\"ClientSizing<br/>calculate() - Position size logic<br/>Fixed/Kelly/ATR methods\"]\n        ClientOptimizer[\"ClientOptimizer<br/>run() - Data collection<br/>generate() - LLM integration\"]\n        ClientPartial[\"ClientPartial<br/>profit/loss() - Milestone tracking<br/>clear() - State cleanup\"]\n    end\n    \n    subgraph \"Schema Services (Configuration)\"\n        StrategySchemaService[\"StrategySchemaService<br/>ToolRegistry pattern\"]\n        ExchangeSchemaService[\"ExchangeSchemaService<br/>ToolRegistry pattern\"]\n        FrameSchemaService[\"FrameSchemaService<br/>ToolRegistry pattern\"]\n        RiskSchemaService[\"RiskSchemaService<br/>ToolRegistry pattern\"]\n        SizingSchemaService[\"SizingSchemaService<br/>ToolRegistry pattern\"]\n        OptimizerSchemaService[\"OptimizerSchemaService<br/>ToolRegistry pattern\"]\n    end\n    \n    StrategySchemaService --> StrategyConnectionService\n    ExchangeSchemaService --> ExchangeConnectionService\n    FrameSchemaService --> FrameConnectionService\n    RiskSchemaService --> RiskConnectionService\n    SizingSchemaService --> SizingConnectionService\n    OptimizerSchemaService --> OptimizerConnectionService\n    \n    StrategyConnectionService --> ClientStrategy\n    ExchangeConnectionService --> ClientExchange\n    FrameConnectionService --> ClientFrame\n    RiskConnectionService --> ClientRisk\n    SizingConnectionService --> ClientSizing\n    OptimizerConnectionService --> ClientOptimizer\n    PartialConnectionService --> ClientPartial\n```\n\n**Sources:** [src/lib/services/connection/StrategyConnectionService.ts:1-100](), [src/client/ClientStrategy.ts:1-500](), [docs/internals.md:30-31]()\n\n### Client Characteristics\n\n1. **No DI Dependencies**: Clients receive dependencies via constructor parameters, not through the DI container\n2. **Prototype Methods**: Methods defined on prototype for memory efficiency (not arrow functions)\n3. **Memoization**: Connection Services cache client instances by key (e.g., `symbol:strategyName`)\n4. **Pure Business Logic**: Domain logic implementation without framework concerns\n5. **Stateful**: Clients maintain internal state (e.g., `ClientStrategy` tracks pending signals)\n\n**Key Client Implementations:**\n\n- **ClientStrategy** [src/client/ClientStrategy.ts](): Signal lifecycle management, tick throttling, backtest acceleration\n- **ClientExchange** [src/client/ClientExchange.ts](): Candle data fetching, VWAP calculation, retry logic\n- **ClientFrame** [src/client/ClientFrame.ts](): Timeframe generation, date iteration\n- **ClientRisk** [src/client/ClientRisk.ts](): Portfolio-level validation, position tracking\n- **ClientOptimizer** [src/client/ClientOptimizer.ts](): LLM integration, strategy code generation\n- **ClientPartial** [src/client/ClientPartial.ts](): Profit/loss milestone tracking\n\n**Sources:** [docs/internals.md:30-31]()\n\nFor detailed client implementations, see [Client Layer](#3.4).\n\n---\n\n## Data Flow Through Layers\n\nThis example shows how a backtest execution flows through the architectural layers:\n\n**Backtest Execution Flow**\n\n```mermaid\ngraph TB\n    User[\"User Code<br/>Backtest.run(symbol, context)\"]\n    \n    BacktestClass[\"Backtest class<br/>src/classes/Backtest.ts<br/>Public API wrapper\"]\n    \n    BacktestCommandService[\"BacktestCommandService<br/>src/lib/services/command/<br/>Validation + delegation\"]\n    \n    ValidationServices[\"Validation Services<br/>strategyValidationService<br/>exchangeValidationService<br/>frameValidationService\"]\n    \n    BacktestLogicPublic[\"BacktestLogicPublicService<br/>Context setup<br/>MethodContext wrapper\"]\n    \n    BacktestLogicPrivate[\"BacktestLogicPrivateService<br/>Async generator implementation<br/>Timeframe iteration\"]\n    \n    FrameCoreService[\"FrameCoreService<br/>Get timeframe array<br/>from FrameConnectionService\"]\n    \n    StrategyCoreService[\"StrategyCoreService<br/>Execute tick() and backtest()<br/>from StrategyConnectionService\"]\n    \n    ExchangeCoreService[\"ExchangeCoreService<br/>Fetch candles<br/>from ExchangeConnectionService\"]\n    \n    ClientFrame[\"ClientFrame<br/>Generate Date[] array<br/>based on interval\"]\n    \n    ClientStrategy[\"ClientStrategy<br/>tick() - Check for signal<br/>backtest() - Process candles\"]\n    \n    ClientExchange[\"ClientExchange<br/>getNextCandles()<br/>VWAP calculation\"]\n    \n    PersistSignal[\"PersistSignalAdapter<br/>JSON file writes<br/>(not used in backtest)\"]\n    \n    MarkdownServices[\"BacktestMarkdownService<br/>Collect closed signals<br/>Generate statistics\"]\n    \n    User --> BacktestClass\n    BacktestClass --> BacktestCommandService\n    BacktestCommandService --> ValidationServices\n    BacktestCommandService --> BacktestLogicPublic\n    BacktestLogicPublic --> BacktestLogicPrivate\n    \n    BacktestLogicPrivate --> FrameCoreService\n    BacktestLogicPrivate --> StrategyCoreService\n    BacktestLogicPrivate --> ExchangeCoreService\n    \n    FrameCoreService --> ClientFrame\n    StrategyCoreService --> ClientStrategy\n    ExchangeCoreService --> ClientExchange\n    \n    ClientStrategy -.->|backtest mode| PersistSignal\n    \n    BacktestLogicPrivate --> MarkdownServices\n```\n\n**Sources:** [src/classes/Backtest.ts:1-100](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:1-200](), [docs/internals.md:54-67]()\n\n### Execution Steps\n\n1. **Public API Layer**: User calls `Backtest.run(symbol, context)` from [src/classes/Backtest.ts]()\n2. **Orchestration Layer**: `Backtest` class delegates to `BacktestCommandService`\n3. **Service Layer - Command**: `BacktestCommandService` validates inputs and delegates to `BacktestLogicPublicService`\n4. **Service Layer - Logic (Public)**: Sets up `MethodContextService` with schema names\n5. **Service Layer - Logic (Private)**: Creates async generator, iterates timeframes\n6. **Service Layer - Core**: Fetches timeframe from `FrameCoreService`, executes strategy via `StrategyCoreService`\n7. **Client Layer**: `ClientFrame` generates dates, `ClientStrategy` executes tick/backtest logic, `ClientExchange` fetches candles\n8. **Service Layer - Markdown**: Collects signals and generates statistics\n9. **Orchestration Layer**: Yields results through generator back to user\n\n**Sources:** [docs/internals.md:54-67]()\n\n---\n\n## Summary\n\nThe backtest-kit architecture achieves separation of concerns through:\n\n1. **Five-Layer Design**: Clear boundaries between API, orchestration, services, clients, and persistence\n2. **Dependency Injection**: Symbol-based DI with centralized `backtest` aggregation object\n3. **Service Organization**: 11 service categories with specific responsibilities\n4. **Client Purity**: Business logic isolated from DI and framework concerns\n5. **Memoization**: Efficient resource usage through cached client instances\n\nThis architecture enables:\n- **Testability**: Each layer testable in isolation\n- **Maintainability**: Changes localized to appropriate layers\n- **Extensibility**: New features added without modifying existing code\n- **Performance**: Memoization and prototype methods minimize memory overhead\n\n**Sources:** [docs/internals.md:10-52](), [src/lib/index.ts:1-242](), [types.d.ts:1-500]()"
                    },
                    {
                        "page_plan": {
                            "id": "3.1",
                            "title": "Layered Architecture"
                        },
                        "content": "# Layered Architecture\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [assets/uml.svg](assets/uml.svg)\n- [docs/classes/WalkerCommandService.md](docs/classes/WalkerCommandService.md)\n- [docs/interfaces/BacktestStatistics.md](docs/interfaces/BacktestStatistics.md)\n- [docs/interfaces/IStrategyCallbacks.md](docs/interfaces/IStrategyCallbacks.md)\n- [docs/interfaces/LiveStatistics.md](docs/interfaces/LiveStatistics.md)\n- [docs/internals.md](docs/internals.md)\n- [docs/types/IStrategyTickResult.md](docs/types/IStrategyTickResult.md)\n- [docs/uml.puml](docs/uml.puml)\n- [scripts/uml.mjs](scripts/uml.mjs)\n- [src/function/add.ts](src/function/add.ts)\n- [src/function/list.ts](src/function/list.ts)\n- [src/lib/core/provide.ts](src/lib/core/provide.ts)\n- [src/lib/core/types.ts](src/lib/core/types.ts)\n- [src/lib/index.ts](src/lib/index.ts)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis document describes the five-layer architecture of backtest-kit, explaining the responsibilities and boundaries of each layer: Public API, Orchestration, Service, Client, and Persistence. Each layer has specific concerns and dependencies flow unidirectionally from top to bottom.\n\nFor information about the dependency injection system that wires these layers together, see [Dependency Injection System](#3.2). For details on individual service categories, see [Service Categories](#3.3). For client implementations, see [Client Layer](#3.4).\n\n---\n\n## Architectural Overview\n\nThe framework implements a strict layered architecture with five distinct layers. Each layer has clear responsibilities and dependencies flow downward only—higher layers depend on lower layers, but not vice versa.\n\n```mermaid\ngraph TB\n    subgraph \"Layer 1: Public API\"\n        API[\"Public Functions<br/>addStrategy(), addExchange(), addFrame()<br/>Backtest.run(), Live.run(), Walker.run()<br/>listenSignal(), listenError(), etc.\"]\n    end\n    \n    subgraph \"Layer 2: Orchestration\"\n        BT[\"Backtest Class<br/>Historical simulation\"]\n        LV[\"Live Class<br/>Real-time trading\"]\n        WK[\"Walker Class<br/>Strategy comparison\"]\n        OPT[\"Optimizer Class<br/>LLM code generation\"]\n    end\n    \n    subgraph \"Layer 3: Service\"\n        CMD[\"Command Services<br/>BacktestCommandService<br/>LiveCommandService<br/>WalkerCommandService\"]\n        LOGIC[\"Logic Services<br/>Public/Private split<br/>Generator patterns\"]\n        GLOBAL[\"Global Services<br/>Strategy, Risk, Sizing<br/>Partial, Optimizer\"]\n        CORE[\"Core Services<br/>Strategy, Exchange, Frame<br/>Domain logic\"]\n        CONN[\"Connection Services<br/>Memoized factories<br/>7 connection types\"]\n        VAL[\"Validation Services<br/>Schema enforcement<br/>8 validators\"]\n        SCHEMA[\"Schema Services<br/>Registry pattern<br/>7 schema types\"]\n        MD[\"Markdown Services<br/>Report generation<br/>9 report types\"]\n    end\n    \n    subgraph \"Layer 4: Client\"\n        CS[\"ClientStrategy<br/>Signal lifecycle\"]\n        CE[\"ClientExchange<br/>Data fetching\"]\n        CF[\"ClientFrame<br/>Timeframe generation\"]\n        CR[\"ClientRisk<br/>Validation logic\"]\n        CO[\"ClientOptimizer<br/>LLM integration\"]\n        CP[\"ClientPartial<br/>P/L tracking\"]\n    end\n    \n    subgraph \"Layer 5: Persistence\"\n        PSA[\"PersistSignalAdapter<br/>JSON file I/O\"]\n        PSchA[\"PersistScheduleAdapter<br/>Scheduled signals\"]\n        PRA[\"PersistRiskAdapter<br/>Risk state\"]\n        PPA[\"PersistPartialAdapter<br/>Partial levels\"]\n    end\n    \n    API --> BT\n    API --> LV\n    API --> WK\n    API --> OPT\n    \n    BT --> CMD\n    LV --> CMD\n    WK --> CMD\n    OPT --> GLOBAL\n    \n    CMD --> LOGIC\n    LOGIC --> GLOBAL\n    LOGIC --> CORE\n    GLOBAL --> CONN\n    CORE --> CONN\n    CONN --> CS\n    CONN --> CE\n    CONN --> CF\n    CONN --> CR\n    CONN --> CO\n    CONN --> CP\n    \n    CS --> PSA\n    CS --> PSchA\n    CR --> PRA\n    CP --> PPA\n```\n\n**Sources:** [docs/internals.md:28-40](), High-Level System Architecture Diagram 1\n\n---\n\n## Layer 1: Public API\n\nThe Public API Layer provides user-facing functions that serve as the framework's entry points. This layer has no business logic—it delegates immediately to the Orchestration Layer.\n\n### Registration Functions\n\n| Function | Purpose | Target Service |\n|----------|---------|----------------|\n| `addStrategy()` | Register trading strategy | `StrategySchemaService` |\n| `addExchange()` | Register data source | `ExchangeSchemaService` |\n| `addFrame()` | Register timeframe | `FrameSchemaService` |\n| `addWalker()` | Register strategy walker | `WalkerSchemaService` |\n| `addSizing()` | Register position sizing | `SizingSchemaService` |\n| `addRisk()` | Register risk profile | `RiskSchemaService` |\n| `addOptimizer()` | Register LLM optimizer | `OptimizerSchemaService` |\n\n### Execution Functions\n\n| Function | Purpose | Target Class |\n|----------|---------|--------------|\n| `Backtest.run()` | Historical simulation | `BacktestCommandService` |\n| `Live.run()` | Real-time trading | `LiveCommandService` |\n| `Walker.run()` | Strategy comparison | `WalkerCommandService` |\n| `Optimizer.run()` | LLM code generation | `OptimizerGlobalService` |\n\n### Event Listeners\n\n| Function | Purpose | Event Emitter |\n|----------|---------|---------------|\n| `listenSignal()` | All signal events | `signalEmitter` |\n| `listenSignalBacktest()` | Backtest signals only | `signalBacktestEmitter` |\n| `listenSignalLive()` | Live signals only | `signalLiveEmitter` |\n| `listenError()` | Recoverable errors | `errorEmitter` |\n| `listenExit()` | Fatal errors | `exitEmitter` |\n\n**Sources:** [src/function/add.ts:1-444](), [src/function/list.ts:1-261](), [docs/internals.md:133-389]()\n\n---\n\n## Layer 2: Orchestration\n\nThe Orchestration Layer implements the four execution modes as public classes. Each class validates inputs and delegates to Command Services.\n\n```mermaid\ngraph LR\n    subgraph \"Backtest\"\n        BT_CLASS[\"Backtest\"]\n        BT_RUN[\"run(symbol, context)\"]\n        BT_BG[\"background(symbol, context)\"]\n    end\n    \n    subgraph \"Live\"\n        LV_CLASS[\"Live\"]\n        LV_RUN[\"run(symbol, context)\"]\n        LV_BG[\"background(symbol, context)\"]\n    end\n    \n    subgraph \"Walker\"\n        WK_CLASS[\"Walker\"]\n        WK_RUN[\"run(symbol, context)\"]\n        WK_BG[\"background(symbol, context)\"]\n    end\n    \n    subgraph \"Optimizer\"\n        OPT_CLASS[\"Optimizer\"]\n        OPT_RUN[\"run(symbol, optimizerName)\"]\n        OPT_DUMP[\"dump(symbol, optimizerName)\"]\n    end\n    \n    BT_CLASS --> BT_RUN\n    BT_CLASS --> BT_BG\n    LV_CLASS --> LV_RUN\n    LV_CLASS --> LV_BG\n    WK_CLASS --> WK_RUN\n    WK_CLASS --> WK_BG\n    OPT_CLASS --> OPT_RUN\n    OPT_CLASS --> OPT_DUMP\n```\n\n### Execution Patterns\n\nEach orchestration class implements two execution patterns:\n\n1. **Synchronous Pattern** (`run()`) - Returns async generator, caller controls iteration\n2. **Background Pattern** (`background()`) - Runs in background with error emitters\n\nThe background pattern wraps the generator in error handling and emits completion events via `doneBacktestSubject`, `doneLiveSubject`, or `doneWalkerSubject`.\n\n**Sources:** [src/classes/Backtest.ts](), [src/classes/Live.ts](), [src/classes/Walker.ts](), [src/classes/Optimizer.ts](), [docs/internals.md:54-82]()\n\n---\n\n## Layer 3: Service Layer\n\nThe Service Layer is the most complex layer, implementing dependency injection with 11 service categories. All services are registered via [src/lib/core/provide.ts:1-141]() and aggregated into the `backtest` singleton at [src/lib/index.ts:221-234]().\n\n### Service Aggregation Structure\n\n```mermaid\ngraph TB\n    BACKTEST[\"backtest object<br/>[src/lib/index.ts:221-234]()\"]\n    \n    BASE[\"baseServices<br/>loggerService\"]\n    CTX[\"contextServices<br/>executionContextService<br/>methodContextService\"]\n    SCHEMA[\"schemaServices<br/>7 schema registries\"]\n    VAL[\"validationServices<br/>8 validators\"]\n    CONN[\"connectionServices<br/>7 memoized factories\"]\n    CORE[\"coreServices<br/>3 domain services\"]\n    GLOBAL[\"globalServices<br/>4 shared state managers\"]\n    CMD[\"commandServices<br/>3 orchestrators\"]\n    LOGIC[\"logicPublicServices<br/>logicPrivateServices<br/>6 execution services\"]\n    MD[\"markdownServices<br/>9 report generators\"]\n    TMPL[\"templateServices<br/>optimizerTemplateService\"]\n    \n    BACKTEST --> BASE\n    BACKTEST --> CTX\n    BACKTEST --> SCHEMA\n    BACKTEST --> VAL\n    BACKTEST --> CONN\n    BACKTEST --> CORE\n    BACKTEST --> GLOBAL\n    BACKTEST --> CMD\n    BACKTEST --> LOGIC\n    BACKTEST --> MD\n    BACKTEST --> TMPL\n```\n\n### 3.1 Base Services\n\nProvides foundational logging functionality used by all other services.\n\n| Service | Symbol | Purpose |\n|---------|--------|---------|\n| `LoggerService` | `TYPES.loggerService` | Structured logging with context injection |\n\n**Sources:** [src/lib/index.ts:60-62](), [src/lib/core/types.ts:1-3](), [src/lib/core/provide.ts:55-57]()\n\n### 3.2 Context Services\n\nManages execution context propagation using `di-scoped` pattern.\n\n| Service | Symbol | Purpose |\n|---------|--------|---------|\n| `ExecutionContextService` | `TYPES.executionContextService` | `symbol`, `when`, `backtest` flag |\n| `MethodContextService` | `TYPES.methodContextService` | `strategyName`, `exchangeName`, `frameName` routing |\n\n**Sources:** [src/lib/index.ts:64-71](), [src/lib/core/types.ts:5-8](), [src/lib/core/provide.ts:59-62]()\n\n### 3.3 Schema Services\n\nImplements registry pattern for configuration storage using `ToolRegistry` from `functools-kit`.\n\n| Service | Symbol | Stores |\n|---------|--------|--------|\n| `StrategySchemaService` | `TYPES.strategySchemaService` | `IStrategySchema` |\n| `ExchangeSchemaService` | `TYPES.exchangeSchemaService` | `IExchangeSchema` |\n| `FrameSchemaService` | `TYPES.frameSchemaService` | `IFrameSchema` |\n| `WalkerSchemaService` | `TYPES.walkerSchemaService` | `IWalkerSchema` |\n| `SizingSchemaService` | `TYPES.sizingSchemaService` | `ISizingSchema` |\n| `RiskSchemaService` | `TYPES.riskSchemaService` | `IRiskSchema` |\n| `OptimizerSchemaService` | `TYPES.optimizerSchemaService` | `IOptimizerSchema` |\n\n**Sources:** [src/lib/index.ts:97-111](), [src/lib/core/types.ts:20-28](), [src/lib/core/provide.ts:74-82]()\n\n### 3.4 Validation Services\n\nEnforces schema existence and structural validation with memoization for performance.\n\n| Service | Symbol | Validates |\n|---------|--------|-----------|\n| `StrategyValidationService` | `TYPES.strategyValidationService` | Strategy schema structure |\n| `ExchangeValidationService` | `TYPES.exchangeValidationService` | Exchange schema structure |\n| `FrameValidationService` | `TYPES.frameValidationService` | Frame date ranges |\n| `WalkerValidationService` | `TYPES.walkerValidationService` | Walker strategy lists |\n| `SizingValidationService` | `TYPES.sizingValidationService` | Sizing parameters |\n| `RiskValidationService` | `TYPES.riskValidationService` | Risk profile existence |\n| `OptimizerValidationService` | `TYPES.optimizerValidationService` | Optimizer configuration |\n| `ConfigValidationService` | `TYPES.configValidationService` | Global config viability |\n\n**Sources:** [src/lib/index.ts:188-213](), [src/lib/core/types.ts:73-82](), [src/lib/core/provide.ts:127-136]()\n\n### 3.5 Connection Services\n\nProvides memoized client instance factories. Each service caches client instances by unique keys.\n\n| Service | Symbol | Key Pattern | Creates |\n|---------|--------|-------------|---------|\n| `StrategyConnectionService` | `TYPES.strategyConnectionService` | `symbol:strategyName` | `ClientStrategy` |\n| `ExchangeConnectionService` | `TYPES.exchangeConnectionService` | `exchangeName` | `ClientExchange` |\n| `FrameConnectionService` | `TYPES.frameConnectionService` | `frameName` | `ClientFrame` |\n| `SizingConnectionService` | `TYPES.sizingConnectionService` | `sizingName` | `ClientSizing` |\n| `RiskConnectionService` | `TYPES.riskConnectionService` | `riskName` | `ClientRisk` |\n| `OptimizerConnectionService` | `TYPES.optimizerConnectionService` | `optimizerName` | `ClientOptimizer` |\n| `PartialConnectionService` | `TYPES.partialConnectionService` | `symbol` | `ClientPartial` |\n\n**Sources:** [src/lib/index.ts:73-95](), [src/lib/core/types.ts:10-18](), [src/lib/core/provide.ts:64-72]()\n\n### 3.6 Core Services\n\nImplements domain logic for strategy execution, exchange data, and timeframe generation.\n\n| Service | Symbol | Purpose |\n|---------|--------|---------|\n| `StrategyCoreService` | `TYPES.strategyCoreService` | `tick()`, `backtest()` signal lifecycle |\n| `ExchangeCoreService` | `TYPES.exchangeCoreService` | `getCandles()`, VWAP calculation |\n| `FrameCoreService` | `TYPES.frameCoreService` | `getTimeframe()` date iteration |\n\n**Sources:** [src/lib/index.ts:113-117](), [src/lib/core/types.ts:30-34](), [src/lib/core/provide.ts:84-88]()\n\n### 3.7 Global Services\n\nManages shared state across multiple strategy instances.\n\n| Service | Symbol | Manages |\n|---------|--------|---------|\n| `SizingGlobalService` | `TYPES.sizingGlobalService` | Position size calculation |\n| `RiskGlobalService` | `TYPES.riskGlobalService` | Active positions tracking |\n| `OptimizerGlobalService` | `TYPES.optimizerGlobalService` | LLM orchestration |\n| `PartialGlobalService` | `TYPES.partialGlobalService` | P/L milestone tracking |\n\n**Sources:** [src/lib/index.ts:119-128](), [src/lib/core/types.ts:36-41](), [src/lib/core/provide.ts:90-95]()\n\n### 3.8 Command Services\n\nHigh-level orchestrators that validate inputs and delegate to Logic Services.\n\n| Service | Symbol | Orchestrates |\n|---------|--------|--------------|\n| `BacktestCommandService` | `TYPES.backtestCommandService` | Backtest execution |\n| `LiveCommandService` | `TYPES.liveCommandService` | Live execution |\n| `WalkerCommandService` | `TYPES.walkerCommandService` | Walker execution |\n\n**Sources:** [src/lib/index.ts:130-138](), [src/lib/core/types.ts:43-47](), [src/lib/core/provide.ts:97-101]()\n\n### 3.9 Logic Services\n\nImplements execution flow as async generators with public/private split. Public services handle context setup, private services implement generator logic.\n\n| Service | Symbol | Pattern |\n|---------|--------|---------|\n| `BacktestLogicPublicService` | `TYPES.backtestLogicPublicService` | Context wrapper |\n| `BacktestLogicPrivateService` | `TYPES.backtestLogicPrivateService` | Timeframe iteration |\n| `LiveLogicPublicService` | `TYPES.liveLogicPublicService` | Context wrapper |\n| `LiveLogicPrivateService` | `TYPES.liveLogicPrivateService` | Infinite loop |\n| `WalkerLogicPublicService` | `TYPES.walkerLogicPublicService` | Context wrapper |\n| `WalkerLogicPrivateService` | `TYPES.walkerLogicPrivateService` | Sequential backtests |\n\n**Sources:** [src/lib/index.ts:140-162](), [src/lib/core/types.ts:49-59](), [src/lib/core/provide.ts:103-113]()\n\n### 3.10 Markdown Services\n\nGenerates reports by subscribing to event emitters and accumulating data with bounded queues.\n\n| Service | Symbol | Subscribes To | MAX_EVENTS |\n|---------|--------|---------------|------------|\n| `BacktestMarkdownService` | `TYPES.backtestMarkdownService` | `signalBacktestEmitter` | 250 |\n| `LiveMarkdownService` | `TYPES.liveMarkdownService` | `signalLiveEmitter` | 250 |\n| `ScheduleMarkdownService` | `TYPES.scheduleMarkdownService` | `signalEmitter` | 250 |\n| `PerformanceMarkdownService` | `TYPES.performanceMarkdownService` | `performanceEmitter` | 10000 |\n| `WalkerMarkdownService` | `TYPES.walkerMarkdownService` | `walkerEmitter` | Unbounded |\n| `HeatMarkdownService` | `TYPES.heatMarkdownService` | `signalEmitter` | Unbounded |\n| `PartialMarkdownService` | `TYPES.partialMarkdownService` | `partialProfitSubject`, `partialLossSubject` | 250 |\n| `OutlineMarkdownService` | `TYPES.outlineMarkdownService` | N/A | N/A |\n| `RiskMarkdownService` | `TYPES.riskMarkdownService` | `riskSubject` | Unbounded |\n\n**Sources:** [src/lib/index.ts:164-186](), [src/lib/core/types.ts:61-71](), [src/lib/core/provide.ts:115-125]()\n\n### 3.11 Template Services\n\nGenerates code templates for optimizer output.\n\n| Service | Symbol | Purpose |\n|---------|--------|---------|\n| `OptimizerTemplateService` | `TYPES.optimizerTemplateService` | Default code templates |\n\n**Sources:** [src/lib/index.ts:215-219](), [src/lib/core/types.ts:84-86](), [src/lib/core/provide.ts:138-140]()\n\n---\n\n## Layer 4: Client Layer\n\nThe Client Layer contains pure business logic without dependency injection. Client classes use prototype methods for memory efficiency and are instantiated by Connection Services.\n\n```mermaid\ngraph TB\n    subgraph \"Client Instances\"\n        CS[\"ClientStrategy<br/>Per symbol+strategy<br/>Memoized by StrategyConnectionService\"]\n        CE[\"ClientExchange<br/>Per exchange<br/>Memoized by ExchangeConnectionService\"]\n        CF[\"ClientFrame<br/>Per frame<br/>Memoized by FrameConnectionService\"]\n        CR[\"ClientRisk<br/>Per risk profile<br/>Memoized by RiskConnectionService\"]\n        CSZ[\"ClientSizing<br/>Per sizing config<br/>Memoized by SizingConnectionService\"]\n        CO[\"ClientOptimizer<br/>Per optimizer<br/>Memoized by OptimizerConnectionService\"]\n        CP[\"ClientPartial<br/>Per symbol<br/>Memoized by PartialConnectionService\"]\n    end\n    \n    subgraph \"Key Methods\"\n        CS_TICK[\"tick()\"]\n        CS_BT[\"backtest()\"]\n        CS_INIT[\"waitForInit()\"]\n        CE_CANDLES[\"getCandles()\"]\n        CE_VWAP[\"getAveragePrice()\"]\n        CF_TIME[\"getTimeframe()\"]\n        CR_VALIDATE[\"validate()\"]\n    end\n    \n    CS --> CS_TICK\n    CS --> CS_BT\n    CS --> CS_INIT\n    CE --> CE_CANDLES\n    CE --> CE_VWAP\n    CF --> CF_TIME\n    CR --> CR_VALIDATE\n```\n\n### Client Responsibilities\n\n| Client | Purpose | Key Methods |\n|--------|---------|-------------|\n| `ClientStrategy` | Signal lifecycle management | `tick()`, `backtest()`, `waitForInit()` |\n| `ClientExchange` | Data fetching and VWAP | `getCandles()`, `getAveragePrice()`, `getNextCandles()` |\n| `ClientFrame` | Timeframe generation | `getTimeframe()` |\n| `ClientRisk` | Portfolio validation | `validate()`, `getActivePositions()` |\n| `ClientSizing` | Position size calculation | `calculate()` |\n| `ClientOptimizer` | LLM integration | `run()`, Template merging |\n| `ClientPartial` | P/L milestone tracking | `check()`, Set-based deduplication |\n\n**Sources:** [docs/internals.md:30](), High-Level System Architecture Diagram 1\n\n---\n\n## Layer 5: Persistence Layer\n\nThe Persistence Layer implements crash-safe state storage using atomic JSON file writes. All persistence adapters extend `PersistBase` and follow the singleshot initialization pattern.\n\n```mermaid\ngraph LR\n    subgraph \"Persistence Adapters\"\n        PSA[\"PersistSignalAdapter<br/>./signals/{symbol}_{strategyName}.json\"]\n        PSchA[\"PersistScheduleAdapter<br/>./schedules/{symbol}_{strategyName}.json\"]\n        PRA[\"PersistRiskAdapter<br/>./risk/{riskName}.json\"]\n        PPA[\"PersistPartialAdapter<br/>./partial/{symbol}_{strategyName}.json\"]\n    end\n    \n    subgraph \"Operations\"\n        READ[\"readSignalData()\"]\n        WRITE[\"writeSignalData()\"]\n        DELETE[\"deleteSignalData()\"]\n    end\n    \n    PSA --> READ\n    PSA --> WRITE\n    PSA --> DELETE\n    PSchA --> READ\n    PSchA --> WRITE\n    PRA --> READ\n    PRA --> WRITE\n    PPA --> READ\n    PPA --> WRITE\n```\n\n### Persistence Patterns\n\n1. **Atomic Writes** - Write to temporary file, then rename to target path\n2. **Singleshot Init** - `waitForInit()` loads persisted state once per instance\n3. **Crash Recovery** - Live mode reads persisted signals on startup\n4. **Pluggable Adapters** - Extend `PersistBase` for custom storage backends\n\n### File Locations\n\n| Adapter | File Pattern | Purpose |\n|---------|--------------|---------|\n| `PersistSignalAdapter` | `./signals/{symbol}_{strategyName}.json` | Open signal state |\n| `PersistScheduleAdapter` | `./schedules/{symbol}_{strategyName}.json` | Scheduled signals |\n| `PersistRiskAdapter` | `./risk/{riskName}.json` | Active positions |\n| `PersistPartialAdapter` | `./partial/{symbol}_{strategyName}.json` | P/L milestones |\n\n**Sources:** [docs/internals.md:38](), [docs/internals.md:50]()\n\n---\n\n## Layer Interaction Flow\n\nThis diagram shows how a typical Backtest execution flows through all five layers:\n\n```mermaid\nsequenceDiagram\n    participant API as \"Layer 1: Public API<br/>Backtest.run()\"\n    participant CMD as \"Layer 2: Orchestration<br/>BacktestCommandService\"\n    participant LOGIC as \"Layer 3: Service<br/>BacktestLogicPrivateService\"\n    participant CORE as \"Layer 3: Service<br/>StrategyCoreService\"\n    participant CONN as \"Layer 3: Service<br/>StrategyConnectionService\"\n    participant CLIENT as \"Layer 4: Client<br/>ClientStrategy\"\n    participant PERSIST as \"Layer 5: Persistence<br/>PersistSignalAdapter\"\n    \n    API->>CMD: run(symbol, context)\n    CMD->>CMD: Validate strategyName, exchangeName, frameName\n    CMD->>LOGIC: run(symbol)\n    LOGIC->>LOGIC: Generate timeframe array\n    \n    loop For each timeframe\n        LOGIC->>CORE: tick(symbol, when)\n        CORE->>CONN: Get or create ClientStrategy instance\n        CONN->>CLIENT: new ClientStrategy()\n        CONN-->>CORE: Return memoized instance\n        CORE->>CLIENT: tick(symbol, when)\n        CLIENT->>CLIENT: Check signal generation throttle\n        CLIENT->>CLIENT: Call getSignal()\n        CLIENT-->>CORE: Return IStrategyTickResult\n        CORE-->>LOGIC: Return tick result\n        \n        alt Signal opened\n            CLIENT->>PERSIST: writeSignalData()\n            PERSIST->>PERSIST: Atomic file write\n            LOGIC->>CORE: backtest(signal, candles)\n            CORE->>CLIENT: backtest(candles)\n            CLIENT->>CLIENT: Fast candle processing\n            CLIENT->>PERSIST: deleteSignalData()\n            CLIENT-->>CORE: Return closed signal\n            LOGIC->>LOGIC: Skip to closeTimestamp\n        end\n        \n        LOGIC-->>CMD: yield tick result\n    end\n    \n    CMD-->>API: Return async generator\n```\n\n**Sources:** [docs/internals.md:54-66](), High-Level System Architecture Diagram 2\n\n---\n\n## Dependency Flow\n\nDependencies flow strictly downward. This table shows which layers depend on which:\n\n| Layer | Depends On | Does Not Depend On |\n|-------|------------|--------------------|\n| Public API | Orchestration | Service, Client, Persistence |\n| Orchestration | Service (Command) | Client, Persistence |\n| Service | Service (lower categories), Client, Persistence | Orchestration, Public API |\n| Client | Persistence | Service, Orchestration, Public API |\n| Persistence | None | All other layers |\n\n### Service Category Dependencies\n\nWithin the Service Layer, dependencies flow in this order:\n\n```mermaid\ngraph TB\n    CMD[\"Command Services\"]\n    LOGIC_PUB[\"Logic Public Services\"]\n    LOGIC_PRIV[\"Logic Private Services\"]\n    GLOBAL[\"Global Services\"]\n    CORE[\"Core Services\"]\n    CONN[\"Connection Services\"]\n    VAL[\"Validation Services\"]\n    SCHEMA[\"Schema Services\"]\n    CTX[\"Context Services\"]\n    BASE[\"Base Services\"]\n    \n    CMD --> LOGIC_PUB\n    LOGIC_PUB --> LOGIC_PRIV\n    LOGIC_PRIV --> GLOBAL\n    LOGIC_PRIV --> CORE\n    GLOBAL --> CONN\n    CORE --> CONN\n    CONN --> VAL\n    CONN --> SCHEMA\n    VAL --> SCHEMA\n    VAL --> CTX\n    SCHEMA --> CTX\n    CTX --> BASE\n```\n\n**Sources:** [src/lib/index.ts:221-234](), High-Level System Architecture Diagram 3\n\n---\n\n## Summary\n\nThe five-layer architecture ensures clear separation of concerns:\n\n1. **Public API Layer** - User-facing functions with no business logic\n2. **Orchestration Layer** - Execution mode implementations (Backtest, Live, Walker, Optimizer)\n3. **Service Layer** - 11 service categories implementing dependency injection\n4. **Client Layer** - Pure business logic without DI, memoized by Connection Services\n5. **Persistence Layer** - Crash-safe storage with atomic writes\n\nThis architecture enables:\n- **Testability** - Each layer can be tested in isolation\n- **Extensibility** - New execution modes can be added without changing lower layers\n- **Memory Efficiency** - Connection Services memoize client instances\n- **Type Safety** - Discriminated unions and TypeScript throughout\n- **Crash Recovery** - Persistence Layer enables state restoration\n\n**Sources:** [docs/internals.md:10-52](), [src/lib/index.ts:1-242](), [src/lib/core/types.ts:1-104](), [src/lib/core/provide.ts:1-141]()"
                    },
                    {
                        "page_plan": {
                            "id": "3.2",
                            "title": "Dependency Injection System"
                        },
                        "content": "# Dependency Injection System\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/add.ts](src/function/add.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/function/list.ts](src/function/list.ts)\n- [src/index.ts](src/index.ts)\n- [src/lib/core/provide.ts](src/lib/core/provide.ts)\n- [src/lib/core/types.ts](src/lib/core/types.ts)\n- [src/lib/index.ts](src/lib/index.ts)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThe Dependency Injection (DI) system provides centralized service management for the backtest-kit framework. It uses Symbol-based keys for type-safe service registration and retrieval, aggregating all services into a single `backtest` object that serves as the framework's service locator. This page documents the DI container implementation, service registration patterns, the aggregation object structure, and the 11 service categories.\n\nFor information about how services use scoped context propagation, see [Layered Architecture](#3.1). For details on individual service implementations, see [Service Categories](#3.3).\n\n**Sources:** [src/lib/core/types.ts](), [src/lib/core/provide.ts](), [src/lib/index.ts]()\n\n---\n\n## Architecture Overview\n\nThe DI system consists of three core components:\n\n1. **Symbol Registry** - Unique Symbol keys for each service type\n2. **Service Provider** - Registration mechanism using factory functions\n3. **Service Aggregation** - The `backtest` singleton object exposing all services\n\n```mermaid\ngraph TB\n    subgraph \"Symbol Registry (types.ts)\"\n        TYPES_BASE[\"baseServices<br/>loggerService: Symbol\"]\n        TYPES_CONTEXT[\"contextServices<br/>executionContextService: Symbol<br/>methodContextService: Symbol\"]\n        TYPES_SCHEMA[\"schemaServices<br/>exchangeSchemaService: Symbol<br/>strategySchemaService: Symbol<br/>frameSchemaService: Symbol<br/>+4 more\"]\n        TYPES_VALIDATION[\"validationServices<br/>exchangeValidationService: Symbol<br/>strategyValidationService: Symbol<br/>+6 more\"]\n        TYPES_CONNECTION[\"connectionServices<br/>exchangeConnectionService: Symbol<br/>strategyConnectionService: Symbol<br/>+5 more\"]\n        TYPES_CORE[\"coreServices<br/>exchangeCoreService: Symbol<br/>strategyCoreService: Symbol<br/>frameCoreService: Symbol\"]\n        TYPES_GLOBAL[\"globalServices<br/>sizingGlobalService: Symbol<br/>riskGlobalService: Symbol<br/>+2 more\"]\n        TYPES_COMMAND[\"commandServices<br/>liveCommandService: Symbol<br/>backtestCommandService: Symbol<br/>walkerCommandService: Symbol\"]\n        TYPES_LOGIC[\"logicPrivateServices<br/>logicPublicServices<br/>6 symbols total\"]\n        TYPES_MARKDOWN[\"markdownServices<br/>9 symbols total\"]\n        TYPES_TEMPLATE[\"templateServices<br/>optimizerTemplateService: Symbol\"]\n    end\n    \n    subgraph \"Service Provider (provide.ts)\"\n        PROVIDE_BASE[\"provide(TYPES.loggerService,<br/>() => new LoggerService())\"]\n        PROVIDE_CONTEXT[\"provide(TYPES.executionContextService,<br/>() => new ExecutionContextService())<br/>provide(TYPES.methodContextService,<br/>() => new MethodContextService())\"]\n        PROVIDE_SCHEMA[\"7 provide() calls<br/>Factory functions instantiate<br/>Schema services\"]\n        PROVIDE_VALIDATION[\"8 provide() calls<br/>Factory functions instantiate<br/>Validation services\"]\n        PROVIDE_CONNECTION[\"7 provide() calls<br/>Factory functions instantiate<br/>Connection services\"]\n        PROVIDE_CORE[\"3 provide() calls<br/>Factory functions instantiate<br/>Core services\"]\n        PROVIDE_GLOBAL[\"4 provide() calls<br/>Factory functions instantiate<br/>Global services\"]\n        PROVIDE_COMMAND[\"3 provide() calls<br/>Factory functions instantiate<br/>Command services\"]\n        PROVIDE_LOGIC[\"12 provide() calls<br/>Public/Private split<br/>6 services each\"]\n        PROVIDE_MARKDOWN[\"9 provide() calls<br/>Factory functions instantiate<br/>Markdown services\"]\n        PROVIDE_TEMPLATE[\"1 provide() call<br/>OptimizerTemplateService\"]\n    end\n    \n    subgraph \"Service Aggregation (index.ts)\"\n        INJECT_BASE[\"baseServices<br/>inject<LoggerService>(TYPES.loggerService)\"]\n        INJECT_CONTEXT[\"contextServices<br/>inject<TExecutionContextService>(...)<br/>inject<TMethodContextService>(...)\"]\n        INJECT_SCHEMA[\"schemaServices<br/>7 inject() calls\"]\n        INJECT_VALIDATION[\"validationServices<br/>8 inject() calls\"]\n        INJECT_CONNECTION[\"connectionServices<br/>7 inject() calls\"]\n        INJECT_CORE[\"coreServices<br/>3 inject() calls\"]\n        INJECT_GLOBAL[\"globalServices<br/>4 inject() calls\"]\n        INJECT_COMMAND[\"commandServices<br/>3 inject() calls\"]\n        INJECT_LOGIC[\"logicPrivateServices<br/>logicPublicServices<br/>12 inject() calls\"]\n        INJECT_MARKDOWN[\"markdownServices<br/>9 inject() calls\"]\n        INJECT_TEMPLATE[\"templateServices<br/>1 inject() call\"]\n        \n        BACKTEST[\"export const backtest = {<br/>...baseServices,<br/>...contextServices,<br/>...connectionServices,<br/>...schemaServices,<br/>...coreServices,<br/>...globalServices,<br/>...commandServices,<br/>...logicPrivateServices,<br/>...logicPublicServices,<br/>...markdownServices,<br/>...validationServices,<br/>...templateServices<br/>}\"]\n    end\n    \n    TYPES_BASE --> PROVIDE_BASE\n    TYPES_CONTEXT --> PROVIDE_CONTEXT\n    TYPES_SCHEMA --> PROVIDE_SCHEMA\n    TYPES_VALIDATION --> PROVIDE_VALIDATION\n    TYPES_CONNECTION --> PROVIDE_CONNECTION\n    TYPES_CORE --> PROVIDE_CORE\n    TYPES_GLOBAL --> PROVIDE_GLOBAL\n    TYPES_COMMAND --> PROVIDE_COMMAND\n    TYPES_LOGIC --> PROVIDE_LOGIC\n    TYPES_MARKDOWN --> PROVIDE_MARKDOWN\n    TYPES_TEMPLATE --> PROVIDE_TEMPLATE\n    \n    PROVIDE_BASE --> INJECT_BASE\n    PROVIDE_CONTEXT --> INJECT_CONTEXT\n    PROVIDE_SCHEMA --> INJECT_SCHEMA\n    PROVIDE_VALIDATION --> INJECT_VALIDATION\n    PROVIDE_CONNECTION --> INJECT_CONNECTION\n    PROVIDE_CORE --> INJECT_CORE\n    PROVIDE_GLOBAL --> INJECT_GLOBAL\n    PROVIDE_COMMAND --> INJECT_COMMAND\n    PROVIDE_LOGIC --> INJECT_LOGIC\n    PROVIDE_MARKDOWN --> INJECT_MARKDOWN\n    PROVIDE_TEMPLATE --> INJECT_TEMPLATE\n    \n    INJECT_BASE --> BACKTEST\n    INJECT_CONTEXT --> BACKTEST\n    INJECT_SCHEMA --> BACKTEST\n    INJECT_VALIDATION --> BACKTEST\n    INJECT_CONNECTION --> BACKTEST\n    INJECT_CORE --> BACKTEST\n    INJECT_GLOBAL --> BACKTEST\n    INJECT_COMMAND --> BACKTEST\n    INJECT_LOGIC --> BACKTEST\n    INJECT_MARKDOWN --> BACKTEST\n    INJECT_TEMPLATE --> BACKTEST\n```\n\n**Sources:** [src/lib/core/types.ts:1-104](), [src/lib/core/provide.ts:1-141](), [src/lib/index.ts:1-242]()\n\n---\n\n## Symbol-Based Service Keys\n\nThe `TYPES` object in [src/lib/core/types.ts]() defines Symbol-based keys for type-safe service registration. Each service category is grouped into a sub-object, then merged into the exported `TYPES` constant.\n\n### Symbol Registry Structure\n\n| Category | Symbol Count | Examples |\n|----------|--------------|----------|\n| **baseServices** | 1 | `loggerService` |\n| **contextServices** | 2 | `executionContextService`, `methodContextService` |\n| **connectionServices** | 7 | `exchangeConnectionService`, `strategyConnectionService`, `frameConnectionService`, `sizingConnectionService`, `riskConnectionService`, `optimizerConnectionService`, `partialConnectionService` |\n| **schemaServices** | 7 | `exchangeSchemaService`, `strategySchemaService`, `frameSchemaService`, `walkerSchemaService`, `sizingSchemaService`, `riskSchemaService`, `optimizerSchemaService` |\n| **coreServices** | 3 | `exchangeCoreService`, `strategyCoreService`, `frameCoreService` |\n| **globalServices** | 4 | `sizingGlobalService`, `riskGlobalService`, `optimizerGlobalService`, `partialGlobalService` |\n| **commandServices** | 3 | `liveCommandService`, `backtestCommandService`, `walkerCommandService` |\n| **logicPrivateServices** | 3 | `backtestLogicPrivateService`, `liveLogicPrivateService`, `walkerLogicPrivateService` |\n| **logicPublicServices** | 3 | `backtestLogicPublicService`, `liveLogicPublicService`, `walkerLogicPublicService` |\n| **markdownServices** | 9 | `backtestMarkdownService`, `liveMarkdownService`, `scheduleMarkdownService`, `performanceMarkdownService`, `walkerMarkdownService`, `heatMarkdownService`, `partialMarkdownService`, `outlineMarkdownService`, `riskMarkdownService` |\n| **validationServices** | 8 | `exchangeValidationService`, `strategyValidationService`, `frameValidationService`, `walkerValidationService`, `sizingValidationService`, `riskValidationService`, `optimizerValidationService`, `configValidationService` |\n| **templateServices** | 1 | `optimizerTemplateService` |\n\n### Symbol Definition Pattern\n\n```typescript\n// src/lib/core/types.ts\nconst baseServices = {\n    loggerService: Symbol('loggerService'),\n};\n\nconst contextServices = {\n    executionContextService: Symbol('executionContextService'),\n    methodContextService: Symbol('methodContextService'),\n};\n\nconst connectionServices = {\n    exchangeConnectionService: Symbol('exchangeConnectionService'),\n    strategyConnectionService: Symbol('strategyConnectionService'),\n    frameConnectionService: Symbol('frameConnectionService'),\n    // ... 4 more\n};\n\n// Merge all service categories\nexport const TYPES = {\n    ...baseServices,\n    ...contextServices,\n    ...connectionServices,\n    ...schemaServices,\n    ...coreServices,\n    ...globalServices,\n    ...commandServices,\n    ...logicPrivateServices,\n    ...logicPublicServices,\n    ...markdownServices,\n    ...validationServices,\n    ...templateServices,\n}\n```\n\nSymbols guarantee uniqueness at runtime, preventing key collisions even if string names clash. Each Symbol is created with a descriptive string for debugging purposes.\n\n**Sources:** [src/lib/core/types.ts:1-104]()\n\n---\n\n## Service Registration Pattern\n\nThe [src/lib/core/provide.ts]() file registers all services using the `provide()` function from the DI container. Each registration pairs a Symbol key with a factory function that instantiates the service.\n\n### Registration Flow\n\n```mermaid\ngraph LR\n    IMPORT[\"Import service classes<br/>LoggerService, ExchangeConnectionService,<br/>StrategySchemaService, etc.\"]\n    PROVIDE[\"provide(symbol, factory)<br/>Factory function returns<br/>new service instance\"]\n    CONTAINER[\"DI Container<br/>Stores symbol → factory mapping\"]\n    INIT[\"init()<br/>Called after all registrations<br/>Resolves dependencies\"]\n    \n    IMPORT --> PROVIDE\n    PROVIDE --> CONTAINER\n    CONTAINER --> INIT\n```\n\n### Registration Examples by Category\n\n**Base Services:**\n```typescript\n// src/lib/core/provide.ts:55-57\n{\n    provide(TYPES.loggerService, () => new LoggerService());\n}\n```\n\n**Context Services:**\n```typescript\n// src/lib/core/provide.ts:59-62\n{\n    provide(TYPES.executionContextService, () => new ExecutionContextService());\n    provide(TYPES.methodContextService, () => new MethodContextService());\n}\n```\n\n**Connection Services:**\n```typescript\n// src/lib/core/provide.ts:64-72\n{\n    provide(TYPES.exchangeConnectionService, () => new ExchangeConnectionService());\n    provide(TYPES.strategyConnectionService, () => new StrategyConnectionService());\n    provide(TYPES.frameConnectionService, () => new FrameConnectionService());\n    provide(TYPES.sizingConnectionService, () => new SizingConnectionService());\n    provide(TYPES.riskConnectionService, () => new RiskConnectionService());\n    provide(TYPES.optimizerConnectionService, () => new OptimizerConnectionService());\n    provide(TYPES.partialConnectionService, () => new PartialConnectionService());\n}\n```\n\n**Schema Services:**\n```typescript\n// src/lib/core/provide.ts:74-82\n{\n    provide(TYPES.exchangeSchemaService, () => new ExchangeSchemaService());\n    provide(TYPES.strategySchemaService, () => new StrategySchemaService());\n    provide(TYPES.frameSchemaService, () => new FrameSchemaService());\n    provide(TYPES.walkerSchemaService, () => new WalkerSchemaService());\n    provide(TYPES.sizingSchemaService, () => new SizingSchemaService());\n    provide(TYPES.riskSchemaService, () => new RiskSchemaService());\n    provide(TYPES.optimizerSchemaService, () => new OptimizerSchemaService());\n}\n```\n\nAll other service categories follow the same pattern. The factory functions are invoked lazily by the DI container when services are first injected.\n\n**Sources:** [src/lib/core/provide.ts:55-141]()\n\n---\n\n## Service Aggregation Object\n\nThe [src/lib/index.ts]() file creates the `backtest` aggregation object by injecting all registered services and merging them into a single export. This serves as the framework's primary service locator.\n\n### Aggregation Structure\n\n```mermaid\ngraph TB\n    subgraph \"Service Injection (index.ts:60-219)\"\n        BASE[\"baseServices = {<br/>loggerService: inject<LoggerService>(TYPES.loggerService)<br/>}\"]\n        CONTEXT[\"contextServices = {<br/>executionContextService: inject<TExecutionContextService>(...),<br/>methodContextService: inject<TMethodContextService>(...)<br/>}\"]\n        CONNECTION[\"connectionServices = {<br/>exchangeConnectionService: inject<ExchangeConnectionService>(...),<br/>strategyConnectionService: inject<StrategyConnectionService>(...),<br/>... 5 more<br/>}\"]\n        SCHEMA[\"schemaServices = {<br/>exchangeSchemaService: inject<ExchangeSchemaService>(...),<br/>strategySchemaService: inject<StrategySchemaService>(...),<br/>... 5 more<br/>}\"]\n        CORE[\"coreServices = {<br/>exchangeCoreService: inject<ExchangeCoreService>(...),<br/>strategyCoreService: inject<StrategyCoreService>(...),<br/>frameCoreService: inject<FrameCoreService>(...)<br/>}\"]\n        GLOBAL[\"globalServices = {<br/>sizingGlobalService: inject<SizingGlobalService>(...),<br/>riskGlobalService: inject<RiskGlobalService>(...),<br/>... 2 more<br/>}\"]\n        COMMAND[\"commandServices = {<br/>liveCommandService: inject<LiveCommandService>(...),<br/>backtestCommandService: inject<BacktestCommandService>(...),<br/>walkerCommandService: inject<WalkerCommandService>(...)<br/>}\"]\n        LOGIC_PRIV[\"logicPrivateServices = {<br/>backtestLogicPrivateService: inject<BacktestLogicPrivateService>(...),<br/>liveLogicPrivateService: inject<LiveLogicPrivateService>(...),<br/>walkerLogicPrivateService: inject<WalkerLogicPrivateService>(...)<br/>}\"]\n        LOGIC_PUB[\"logicPublicServices = {<br/>backtestLogicPublicService: inject<BacktestLogicPublicService>(...),<br/>liveLogicPublicService: inject<LiveLogicPublicService>(...),<br/>walkerLogicPublicService: inject<WalkerLogicPublicService>(...)<br/>}\"]\n        MARKDOWN[\"markdownServices = {<br/>backtestMarkdownService: inject<BacktestMarkdownService>(...),<br/>liveMarkdownService: inject<LiveMarkdownService>(...),<br/>... 7 more<br/>}\"]\n        VALIDATION[\"validationServices = {<br/>exchangeValidationService: inject<ExchangeValidationService>(...),<br/>strategyValidationService: inject<StrategyValidationService>(...),<br/>... 6 more<br/>}\"]\n        TEMPLATE[\"templateServices = {<br/>optimizerTemplateService: inject<OptimizerTemplateService>(...)<br/>}\"]\n    end\n    \n    subgraph \"Aggregation (index.ts:221-234)\"\n        BACKTEST_OBJ[\"export const backtest = {<br/>...baseServices,<br/>...contextServices,<br/>...connectionServices,<br/>...schemaServices,<br/>...coreServices,<br/>...globalServices,<br/>...commandServices,<br/>...logicPrivateServices,<br/>...logicPublicServices,<br/>...markdownServices,<br/>...validationServices,<br/>...templateServices,<br/>}<br/><br/>Total: 51 services\"]\n    end\n    \n    BASE --> BACKTEST_OBJ\n    CONTEXT --> BACKTEST_OBJ\n    CONNECTION --> BACKTEST_OBJ\n    SCHEMA --> BACKTEST_OBJ\n    CORE --> BACKTEST_OBJ\n    GLOBAL --> BACKTEST_OBJ\n    COMMAND --> BACKTEST_OBJ\n    LOGIC_PRIV --> BACKTEST_OBJ\n    LOGIC_PUB --> BACKTEST_OBJ\n    MARKDOWN --> BACKTEST_OBJ\n    VALIDATION --> BACKTEST_OBJ\n    TEMPLATE --> BACKTEST_OBJ\n```\n\n### Initialization and Export\n\n```typescript\n// src/lib/index.ts:221-236\nexport const backtest = {\n  ...baseServices,\n  ...contextServices,\n  ...connectionServices,\n  ...schemaServices,\n  ...coreServices,\n  ...globalServices,\n  ...commandServices,\n  ...logicPrivateServices,\n  ...logicPublicServices,\n  ...markdownServices,\n  ...validationServices,\n  ...templateServices,\n};\n\ninit(); // Resolves all lazy dependencies\n\nexport { ExecutionContextService };\nexport { MethodContextService };\n\nexport default backtest;\n```\n\nThe `init()` call triggers dependency resolution for all registered services. The `backtest` object is then exported as both a named export and default export.\n\n**Sources:** [src/lib/index.ts:60-242]()\n\n---\n\n## Service Categories\n\nThe DI system organizes services into 11 categories based on their architectural role. Each category has a specific responsibility in the overall system.\n\n### Base Services\n\nProvides foundational logging infrastructure.\n\n| Service | Symbol Key | Class | Responsibility |\n|---------|-----------|-------|----------------|\n| `loggerService` | `TYPES.loggerService` | `LoggerService` | Structured logging with context injection |\n\n**Sources:** [src/lib/core/types.ts:1-3](), [src/lib/core/provide.ts:55-57](), [src/lib/index.ts:60-62]()\n\n---\n\n### Context Services\n\nProvides scoped context propagation using the `di-scoped` library pattern. See [types.d.ts:246-285]() and [types.d.ts:505-544]() for interface definitions.\n\n| Service | Symbol Key | Class | Responsibility |\n|---------|-----------|-------|----------------|\n| `executionContextService` | `TYPES.executionContextService` | `ExecutionContextService` | Propagates `symbol`, `when`, and `backtest` flag through execution chain |\n| `methodContextService` | `TYPES.methodContextService` | `MethodContextService` | Propagates `strategyName`, `exchangeName`, `frameName` for schema routing |\n\nBoth services extend the `di-scoped` library's scoped class pattern, enabling implicit context passing without explicit parameters.\n\n```typescript\n// Example from types.d.ts:274-280\nExecutionContextService.runInContext(\n  async () => {\n    // Inside this callback, context is automatically available\n    return await someOperation();\n  },\n  { symbol: \"BTCUSDT\", when: new Date(), backtest: true }\n);\n```\n\n**Sources:** [src/lib/core/types.ts:5-8](), [src/lib/core/provide.ts:59-62](), [src/lib/index.ts:64-71](), [types.d.ts:246-285](), [types.d.ts:505-544]()\n\n---\n\n### Schema Services\n\nStore registered user configurations using the Tool Registry pattern (immutable Map-based storage).\n\n| Service | Symbol Key | Class | Stored Schema Type |\n|---------|-----------|-------|-------------------|\n| `exchangeSchemaService` | `TYPES.exchangeSchemaService` | `ExchangeSchemaService` | `IExchangeSchema` |\n| `strategySchemaService` | `TYPES.strategySchemaService` | `StrategySchemaService` | `IStrategySchema` |\n| `frameSchemaService` | `TYPES.frameSchemaService` | `FrameSchemaService` | `IFrameSchema` |\n| `walkerSchemaService` | `TYPES.walkerSchemaService` | `WalkerSchemaService` | `IWalkerSchema` |\n| `sizingSchemaService` | `TYPES.sizingSchemaService` | `SizingSchemaService` | `ISizingSchema` |\n| `riskSchemaService` | `TYPES.riskSchemaService` | `RiskSchemaService` | `IRiskSchema` |\n| `optimizerSchemaService` | `TYPES.optimizerSchemaService` | `OptimizerSchemaService` | `IOptimizerSchema` |\n\nEach Schema Service provides:\n- `register(name: string, schema: TSchema): void` - Store schema\n- `get(name: string): TSchema | null` - Retrieve schema\n- `has(name: string): boolean` - Check existence\n\n**Sources:** [src/lib/core/types.ts:20-28](), [src/lib/core/provide.ts:74-82](), [src/lib/index.ts:97-111]()\n\n---\n\n### Validation Services\n\nEnforce schema structure and business rules before registration.\n\n| Service | Symbol Key | Class | Validates |\n|---------|-----------|-------|-----------|\n| `exchangeValidationService` | `TYPES.exchangeValidationService` | `ExchangeValidationService` | `IExchangeSchema` structure, required fields |\n| `strategyValidationService` | `TYPES.strategyValidationService` | `StrategyValidationService` | `IStrategySchema` structure, interval validity, memoization |\n| `frameValidationService` | `TYPES.frameValidationService` | `FrameValidationService` | `IFrameSchema` structure, date range logic |\n| `walkerValidationService` | `TYPES.walkerValidationService` | `WalkerValidationService` | `IWalkerSchema` structure, strategy list, metric |\n| `sizingValidationService` | `TYPES.sizingValidationService` | `SizingValidationService` | `ISizingSchema` structure, method-specific params |\n| `riskValidationService` | `TYPES.riskValidationService` | `RiskValidationService` | `IRiskSchema` structure, validation array |\n| `optimizerValidationService` | `TYPES.optimizerValidationService` | `OptimizerValidationService` | `IOptimizerSchema` structure, source functions |\n| `configValidationService` | `TYPES.configValidationService` | `ConfigValidationService` | Global config economic viability |\n\nEach Validation Service provides:\n- `addXXX(name: string, schema: TSchema): void` - Validate and throw on error\n- `list(): Promise<TSchema[]>` - Return all registered schemas\n\n**Sources:** [src/lib/core/types.ts:73-82](), [src/lib/core/provide.ts:127-136](), [src/lib/index.ts:188-213]()\n\n---\n\n### Connection Services\n\nFactory pattern for creating memoized client instances. Each service maintains a cache keyed by identifier strings to prevent duplicate instantiation.\n\n| Service | Symbol Key | Class | Factory Return Type | Cache Key Pattern |\n|---------|-----------|-------|-------------------|------------------|\n| `exchangeConnectionService` | `TYPES.exchangeConnectionService` | `ExchangeConnectionService` | `IExchange` (ClientExchange) | `exchangeName` |\n| `strategyConnectionService` | `TYPES.strategyConnectionService` | `StrategyConnectionService` | `IStrategy` (ClientStrategy) | `symbol:strategyName` |\n| `frameConnectionService` | `TYPES.frameConnectionService` | `FrameConnectionService` | `IFrame` (ClientFrame) | `frameName` |\n| `sizingConnectionService` | `TYPES.sizingConnectionService` | `SizingConnectionService` | `ISizing` (ClientSizing) | `sizingName` |\n| `riskConnectionService` | `TYPES.riskConnectionService` | `RiskConnectionService` | `IRisk` (ClientRisk) | `riskName` |\n| `optimizerConnectionService` | `TYPES.optimizerConnectionService` | `OptimizerConnectionService` | `IOptimizer` (ClientOptimizer) | `optimizerName` |\n| `partialConnectionService` | `TYPES.partialConnectionService` | `PartialConnectionService` | `IPartial` (ClientPartial) | `symbol` |\n\n### Connection Service Pattern\n\n```typescript\n// Typical Connection Service structure\nclass ExchangeConnectionService {\n  private cache = new Map<string, IExchange>();\n\n  getExchange(exchangeName: string): IExchange {\n    if (!this.cache.has(exchangeName)) {\n      const schema = schemaService.get(exchangeName);\n      const client = new ClientExchange(schema, dependencies);\n      this.cache.set(exchangeName, client);\n    }\n    return this.cache.get(exchangeName)!;\n  }\n}\n```\n\nMemoization ensures that multiple calls with the same identifier return the same client instance, preserving internal state.\n\n**Sources:** [src/lib/core/types.ts:10-18](), [src/lib/core/provide.ts:64-72](), [src/lib/index.ts:73-95]()\n\n---\n\n### Core Services\n\nImplement domain logic for primary business entities.\n\n| Service | Symbol Key | Class | Responsibility |\n|---------|-----------|-------|----------------|\n| `exchangeCoreService` | `TYPES.exchangeCoreService` | `ExchangeCoreService` | Candle fetching (`getCandles`, `getNextCandles`), VWAP calculation |\n| `strategyCoreService` | `TYPES.strategyCoreService` | `StrategyCoreService` | Signal lifecycle management (`tick`, `backtest` methods) |\n| `frameCoreService` | `TYPES.frameCoreService` | `FrameCoreService` | Timeframe generation, date iteration |\n\nCore Services are invoked by Logic Services to execute domain operations. They consume Connection Services to access client instances.\n\n**Sources:** [src/lib/core/types.ts:30-34](), [src/lib/core/provide.ts:84-88](), [src/lib/index.ts:113-117]()\n\n---\n\n### Global Services\n\nProvide portfolio-level orchestration and shared state management.\n\n| Service | Symbol Key | Class | Responsibility |\n|---------|-----------|-------|----------------|\n| `sizingGlobalService` | `TYPES.sizingGlobalService` | `SizingGlobalService` | Position size calculation across strategies |\n| `riskGlobalService` | `TYPES.riskGlobalService` | `RiskGlobalService` | Risk state management, position tracking |\n| `optimizerGlobalService` | `TYPES.optimizerGlobalService` | `OptimizerGlobalService` | Optimizer orchestration, validation wrapper |\n| `partialGlobalService` | `TYPES.partialGlobalService` | `PartialGlobalService` | Partial profit/loss tracking, milestone management |\n\nGlobal Services coordinate between multiple client instances and provide cross-cutting concerns like risk limits and position sizing.\n\n**Sources:** [src/lib/core/types.ts:36-41](), [src/lib/core/provide.ts:90-95](), [src/lib/index.ts:119-128]()\n\n---\n\n### Command Services\n\nHigh-level orchestration layer that coordinates validation, context setup, and execution.\n\n| Service | Symbol Key | Class | Orchestrates |\n|---------|-----------|-------|-------------|\n| `liveCommandService` | `TYPES.liveCommandService` | `LiveCommandService` | Live trading execution workflow |\n| `backtestCommandService` | `TYPES.backtestCommandService` | `BacktestCommandService` | Backtest execution workflow |\n| `walkerCommandService` | `TYPES.walkerCommandService` | `WalkerCommandService` | Walker comparison workflow |\n\nCommand Services delegate to Logic Services after performing validation and context initialization.\n\n**Sources:** [src/lib/core/types.ts:43-47](), [src/lib/core/provide.ts:97-101](), [src/lib/index.ts:130-138]()\n\n---\n\n### Logic Services\n\nImplement execution flow with public/private split. Public services wrap private services with context setup.\n\n| Service | Symbol Key | Class | Execution Pattern |\n|---------|-----------|-------|------------------|\n| `backtestLogicPublicService` | `TYPES.backtestLogicPublicService` | `BacktestLogicPublicService` | Sets up `MethodContextService` context |\n| `backtestLogicPrivateService` | `TYPES.backtestLogicPrivateService` | `BacktestLogicPrivateService` | Generator implementation with timeframe iteration |\n| `liveLogicPublicService` | `TYPES.liveLogicPublicService` | `LiveLogicPublicService` | Sets up `MethodContextService` context |\n| `liveLogicPrivateService` | `TYPES.liveLogicPrivateService` | `LiveLogicPrivateService` | Generator implementation with infinite loop |\n| `walkerLogicPublicService` | `TYPES.walkerLogicPublicService` | `WalkerLogicPublicService` | Sets up `MethodContextService` context |\n| `walkerLogicPrivateService` | `TYPES.walkerLogicPrivateService` | `WalkerLogicPrivateService` | Generator implementation with sequential backtests |\n\n### Public/Private Pattern\n\n```typescript\n// Public Service (context wrapper)\nclass BacktestLogicPublicService {\n  async *run(symbol: string, options: BacktestOptions) {\n    yield* MethodContextService.runAsyncIterator(\n      () => this.privateService.run(symbol, options),\n      { strategyName: options.strategyName, exchangeName: options.exchangeName, frameName: options.frameName }\n    );\n  }\n}\n\n// Private Service (generator implementation)\nclass BacktestLogicPrivateService {\n  async *run(symbol: string, options: BacktestOptions) {\n    const timeframe = await this.frameService.getTimeframe(symbol, options.frameName);\n    for (const when of timeframe) {\n      // Execution logic\n      yield result;\n    }\n  }\n}\n```\n\n**Sources:** [src/lib/core/types.ts:49-59](), [src/lib/core/provide.ts:103-113](), [src/lib/index.ts:140-162]()\n\n---\n\n### Markdown Services\n\nGenerate reports and calculate statistics from accumulated events.\n\n| Service | Symbol Key | Class | Report Type |\n|---------|-----------|-------|------------|\n| `backtestMarkdownService` | `TYPES.backtestMarkdownService` | `BacktestMarkdownService` | Closed signals, PnL statistics (MAX_EVENTS: 250) |\n| `liveMarkdownService` | `TYPES.liveMarkdownService` | `LiveMarkdownService` | All tick types, live monitoring (MAX_EVENTS: 250) |\n| `scheduleMarkdownService` | `TYPES.scheduleMarkdownService` | `ScheduleMarkdownService` | Scheduled signals, activation tracking (MAX_EVENTS: 250) |\n| `performanceMarkdownService` | `TYPES.performanceMarkdownService` | `PerformanceMarkdownService` | Execution metrics, duration tracking (MAX_EVENTS: 10000) |\n| `walkerMarkdownService` | `TYPES.walkerMarkdownService` | `WalkerMarkdownService` | Comparison tables, best strategy (unbounded) |\n| `heatMarkdownService` | `TYPES.heatMarkdownService` | `HeatMarkdownService` | Portfolio heatmap, symbol statistics (unbounded) |\n| `partialMarkdownService` | `TYPES.partialMarkdownService` | `PartialMarkdownService` | Partial P/L, milestone events (MAX_EVENTS: 250) |\n| `outlineMarkdownService` | `TYPES.outlineMarkdownService` | `OutlineMarkdownService` | System outline, configuration dump (unbounded) |\n| `riskMarkdownService` | `TYPES.riskMarkdownService` | `RiskMarkdownService` | Risk rejections, validation stats (unbounded) |\n\nEach Markdown Service subscribes to relevant event emitters and provides:\n- `getData(): TData[]` - Return accumulated event data\n- `getReport(): string` - Generate markdown report\n- `dump(filepath: string): Promise<void>` - Write report to file\n\n**Sources:** [src/lib/core/types.ts:61-71](), [src/lib/core/provide.ts:115-125](), [src/lib/index.ts:164-186]()\n\n---\n\n### Template Services\n\nGenerate code artifacts for strategy creation.\n\n| Service | Symbol Key | Class | Responsibility |\n|---------|-----------|-------|----------------|\n| `optimizerTemplateService` | `TYPES.optimizerTemplateService` | `OptimizerTemplateService` | Code generation for optimizer output, default templates |\n\nThe Optimizer Template Service merges user-provided template overrides with default templates to generate complete executable `.mjs` files containing strategy implementations.\n\n**Sources:** [src/lib/core/types.ts:84-86](), [src/lib/core/provide.ts:138-140](), [src/lib/index.ts:215-219]()\n\n---\n\n## Service Dependency Flow\n\nThe following diagram illustrates how services depend on each other within the DI system.\n\n```mermaid\ngraph TB\n    subgraph \"Public API Layer (function/)\"\n        ADD[\"addStrategy, addExchange,<br/>addFrame, addWalker,<br/>addSizing, addRisk,<br/>addOptimizer\"]\n        LIST[\"listStrategies,<br/>listExchanges,<br/>listFrames, etc.\"]\n        EVENT[\"listenSignal,<br/>listenError,<br/>listenPartialProfit, etc.\"]\n    end\n    \n    subgraph \"Command Services\"\n        LIVE_CMD[\"LiveCommandService\"]\n        BACKTEST_CMD[\"BacktestCommandService\"]\n        WALKER_CMD[\"WalkerCommandService\"]\n    end\n    \n    subgraph \"Logic Services (Public)\"\n        LIVE_PUB[\"LiveLogicPublicService\"]\n        BACKTEST_PUB[\"BacktestLogicPublicService\"]\n        WALKER_PUB[\"WalkerLogicPublicService\"]\n    end\n    \n    subgraph \"Logic Services (Private)\"\n        LIVE_PRIV[\"LiveLogicPrivateService\"]\n        BACKTEST_PRIV[\"BacktestLogicPrivateService\"]\n        WALKER_PRIV[\"WalkerLogicPrivateService\"]\n    end\n    \n    subgraph \"Core Services\"\n        STRATEGY_CORE[\"StrategyCoreService<br/>tick(), backtest()\"]\n        EXCHANGE_CORE[\"ExchangeCoreService<br/>getCandles(), VWAP\"]\n        FRAME_CORE[\"FrameCoreService<br/>getTimeframe()\"]\n    end\n    \n    subgraph \"Connection Services\"\n        STRATEGY_CONN[\"StrategyConnectionService<br/>Memoized ClientStrategy\"]\n        EXCHANGE_CONN[\"ExchangeConnectionService<br/>Memoized ClientExchange\"]\n        FRAME_CONN[\"FrameConnectionService<br/>Memoized ClientFrame\"]\n        SIZING_CONN[\"SizingConnectionService<br/>Memoized ClientSizing\"]\n        RISK_CONN[\"RiskConnectionService<br/>Memoized ClientRisk\"]\n        OPTIMIZER_CONN[\"OptimizerConnectionService<br/>Memoized ClientOptimizer\"]\n        PARTIAL_CONN[\"PartialConnectionService<br/>Memoized ClientPartial\"]\n    end\n    \n    subgraph \"Schema Services\"\n        STRATEGY_SCHEMA[\"StrategySchemaService<br/>ToolRegistry pattern\"]\n        EXCHANGE_SCHEMA[\"ExchangeSchemaService<br/>ToolRegistry pattern\"]\n        FRAME_SCHEMA[\"FrameSchemaService<br/>ToolRegistry pattern\"]\n        SIZING_SCHEMA[\"SizingSchemaService<br/>ToolRegistry pattern\"]\n        RISK_SCHEMA[\"RiskSchemaService<br/>ToolRegistry pattern\"]\n        OPTIMIZER_SCHEMA[\"OptimizerSchemaService<br/>ToolRegistry pattern\"]\n        WALKER_SCHEMA[\"WalkerSchemaService<br/>ToolRegistry pattern\"]\n    end\n    \n    subgraph \"Validation Services\"\n        STRATEGY_VAL[\"StrategyValidationService\"]\n        EXCHANGE_VAL[\"ExchangeValidationService\"]\n        FRAME_VAL[\"FrameValidationService\"]\n        SIZING_VAL[\"SizingValidationService\"]\n        RISK_VAL[\"RiskValidationService\"]\n        OPTIMIZER_VAL[\"OptimizerValidationService\"]\n        WALKER_VAL[\"WalkerValidationService\"]\n        CONFIG_VAL[\"ConfigValidationService\"]\n    end\n    \n    subgraph \"Global Services\"\n        SIZING_GLOBAL[\"SizingGlobalService\"]\n        RISK_GLOBAL[\"RiskGlobalService\"]\n        OPTIMIZER_GLOBAL[\"OptimizerGlobalService\"]\n        PARTIAL_GLOBAL[\"PartialGlobalService\"]\n    end\n    \n    subgraph \"Markdown Services\"\n        BACKTEST_MD[\"BacktestMarkdownService\"]\n        LIVE_MD[\"LiveMarkdownService\"]\n        WALKER_MD[\"WalkerMarkdownService\"]\n        PARTIAL_MD[\"PartialMarkdownService\"]\n        RISK_MD[\"RiskMarkdownService\"]\n    end\n    \n    subgraph \"Context Services\"\n        EXEC_CTX[\"ExecutionContextService<br/>symbol, when, backtest\"]\n        METHOD_CTX[\"MethodContextService<br/>strategyName, exchangeName,<br/>frameName\"]\n    end\n    \n    subgraph \"Base Services\"\n        LOGGER[\"LoggerService\"]\n    end\n    \n    ADD --> STRATEGY_VAL\n    ADD --> EXCHANGE_VAL\n    ADD --> STRATEGY_SCHEMA\n    ADD --> EXCHANGE_SCHEMA\n    \n    LIST --> STRATEGY_VAL\n    LIST --> EXCHANGE_VAL\n    \n    LIVE_CMD --> LIVE_PUB\n    BACKTEST_CMD --> BACKTEST_PUB\n    WALKER_CMD --> WALKER_PUB\n    \n    LIVE_PUB --> METHOD_CTX\n    LIVE_PUB --> LIVE_PRIV\n    BACKTEST_PUB --> METHOD_CTX\n    BACKTEST_PUB --> BACKTEST_PRIV\n    WALKER_PUB --> METHOD_CTX\n    WALKER_PUB --> WALKER_PRIV\n    \n    LIVE_PRIV --> STRATEGY_CORE\n    BACKTEST_PRIV --> STRATEGY_CORE\n    BACKTEST_PRIV --> EXCHANGE_CORE\n    BACKTEST_PRIV --> FRAME_CORE\n    WALKER_PRIV --> BACKTEST_PUB\n    \n    STRATEGY_CORE --> STRATEGY_CONN\n    STRATEGY_CORE --> EXEC_CTX\n    EXCHANGE_CORE --> EXCHANGE_CONN\n    EXCHANGE_CORE --> EXEC_CTX\n    FRAME_CORE --> FRAME_CONN\n    \n    STRATEGY_CONN --> STRATEGY_SCHEMA\n    STRATEGY_CONN --> RISK_CONN\n    STRATEGY_CONN --> PARTIAL_CONN\n    EXCHANGE_CONN --> EXCHANGE_SCHEMA\n    FRAME_CONN --> FRAME_SCHEMA\n    SIZING_CONN --> SIZING_SCHEMA\n    RISK_CONN --> RISK_SCHEMA\n    OPTIMIZER_CONN --> OPTIMIZER_SCHEMA\n    \n    STRATEGY_VAL --> STRATEGY_SCHEMA\n    EXCHANGE_VAL --> EXCHANGE_SCHEMA\n    FRAME_VAL --> FRAME_SCHEMA\n    SIZING_VAL --> SIZING_SCHEMA\n    RISK_VAL --> RISK_SCHEMA\n    OPTIMIZER_VAL --> OPTIMIZER_SCHEMA\n    WALKER_VAL --> WALKER_SCHEMA\n    \n    SIZING_GLOBAL --> SIZING_CONN\n    RISK_GLOBAL --> RISK_CONN\n    OPTIMIZER_GLOBAL --> OPTIMIZER_CONN\n    PARTIAL_GLOBAL --> PARTIAL_CONN\n    \n    BACKTEST_MD -.->|subscribes| EVENT\n    LIVE_MD -.->|subscribes| EVENT\n    WALKER_MD -.->|subscribes| EVENT\n    PARTIAL_MD -.->|subscribes| EVENT\n    RISK_MD -.->|subscribes| EVENT\n    \n    LOGGER -.->|used by| STRATEGY_CORE\n    LOGGER -.->|used by| EXCHANGE_CORE\n    LOGGER -.->|used by| LIVE_PRIV\n    LOGGER -.->|used by| BACKTEST_PRIV\n```\n\n### Dependency Resolution Order\n\n1. **Base Services** - No dependencies, instantiated first\n2. **Context Services** - No dependencies, instantiated early\n3. **Schema Services** - No dependencies, instantiated to store configurations\n4. **Validation Services** - Depend on Schema Services for existence checks\n5. **Connection Services** - Depend on Schema Services for client instantiation\n6. **Core Services** - Depend on Connection Services and Context Services\n7. **Global Services** - Depend on Connection Services\n8. **Logic Services** - Depend on Core Services and Context Services\n9. **Command Services** - Depend on Logic Services\n10. **Markdown Services** - Subscribe to event emitters (no direct dependencies)\n11. **Template Services** - No dependencies\n\n**Sources:** [src/lib/index.ts:1-242](), [src/lib/core/provide.ts:1-141]()\n\n---\n\n## Usage Patterns\n\n### Accessing Services Internally\n\nServices access other services by importing the `backtest` aggregation object:\n\n```typescript\n// Example from a Core Service\nimport backtest from \"../index\";\n\nclass StrategyCoreService {\n  async tick(symbol: string, when: Date) {\n    // Access connection service\n    const strategy = backtest.strategyConnectionService.getStrategy(symbol, \"my-strategy\");\n    \n    // Access logger\n    backtest.loggerService.log(\"StrategyCoreService.tick\", { symbol, when });\n    \n    // ... implementation\n  }\n}\n```\n\n### Accessing Services Externally\n\nExternal code (public API functions, user code) imports the `backtest` object from the main library export:\n\n```typescript\n// Example from function/add.ts\nimport backtest from \"../lib/index\";\n\nexport function addStrategy(strategySchema: IStrategySchema) {\n  // Use validation service\n  backtest.strategyValidationService.addStrategy(\n    strategySchema.strategyName,\n    strategySchema\n  );\n  \n  // Use schema service\n  backtest.strategySchemaService.register(\n    strategySchema.strategyName,\n    strategySchema\n  );\n}\n```\n\n### Service Initialization\n\nThe `init()` function must be called after all `provide()` registrations but before any service usage:\n\n```typescript\n// src/lib/index.ts:236\ninit();\n```\n\nThis resolves any circular dependencies and ensures all services are properly instantiated in the container.\n\n**Sources:** [src/lib/index.ts:221-242](), [src/function/add.ts:52-64]()\n\n---\n\n## Summary\n\nThe Dependency Injection system provides:\n\n1. **Type-Safe Service Keys** - Symbol-based keys prevent collisions and enable type inference\n2. **Lazy Instantiation** - Services are created only when first requested\n3. **Centralized Access** - The `backtest` aggregation object serves as the single service locator\n4. **Organized Structure** - 11 service categories with clear architectural boundaries\n5. **Memoization** - Connection Services cache client instances by identifier\n6. **Context Propagation** - Scoped services enable implicit parameter passing\n\nThis architecture enables loose coupling, testability, and modular service composition across the 51 registered services in the framework.\n\n**Sources:** [src/lib/core/types.ts](), [src/lib/core/provide.ts](), [src/lib/index.ts]()"
                    },
                    {
                        "page_plan": {
                            "id": "3.3",
                            "title": "Service Categories"
                        },
                        "content": "# Service Categories\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [assets/uml.svg](assets/uml.svg)\n- [docs/classes/WalkerCommandService.md](docs/classes/WalkerCommandService.md)\n- [docs/interfaces/BacktestStatistics.md](docs/interfaces/BacktestStatistics.md)\n- [docs/interfaces/IStrategyCallbacks.md](docs/interfaces/IStrategyCallbacks.md)\n- [docs/interfaces/LiveStatistics.md](docs/interfaces/LiveStatistics.md)\n- [docs/internals.md](docs/internals.md)\n- [docs/types/IStrategyTickResult.md](docs/types/IStrategyTickResult.md)\n- [docs/uml.puml](docs/uml.puml)\n- [scripts/uml.mjs](scripts/uml.mjs)\n- [src/function/add.ts](src/function/add.ts)\n- [src/function/list.ts](src/function/list.ts)\n- [src/lib/core/provide.ts](src/lib/core/provide.ts)\n- [src/lib/core/types.ts](src/lib/core/types.ts)\n- [src/lib/index.ts](src/lib/index.ts)\n\n</details>\n\n\n\nThis page documents the 11 service categories that comprise the Service Layer in the backtest-kit architecture. Each category serves a distinct architectural role, from configuration storage to business logic execution. For information about the overall layered architecture, see [Layered Architecture](#3.1). For details on how services are registered via dependency injection, see [Dependency Injection System](#3.2).\n\n---\n\n## Service Layer Organization\n\nThe Service Layer implements a dependency injection architecture where services are organized into 11 functional categories. All services are registered in the `backtest` aggregation object, which serves as the central service locator throughout the codebase. The categories follow a clear separation of concerns: **Schema** services store configuration, **Validation** services enforce rules, **Connection** services create memoized client instances, **Core** services implement domain logic, **Global** services wrap public APIs, **Command** services orchestrate execution modes, **Logic** services manage execution flow, **Markdown** services generate reports, **Template** services handle code generation, **Context** services manage execution state, and **Base** services provide foundational utilities.\n\nSources: [src/lib/index.ts:60-234](), [src/lib/core/types.ts:1-104](), [docs/internals.md:28-52]()\n\n---\n\n## Service Category Diagram\n\n```mermaid\ngraph TB\n    subgraph \"11 Service Categories\"\n        BASE[\"Base Services<br/>1 service\"]\n        CONTEXT[\"Context Services<br/>2 services\"]\n        SCHEMA[\"Schema Services<br/>7 services\"]\n        VALIDATION[\"Validation Services<br/>8 services\"]\n        CONNECTION[\"Connection Services<br/>7 services\"]\n        CORE[\"Core Services<br/>3 services\"]\n        GLOBAL[\"Global Services<br/>4 services\"]\n        COMMAND[\"Command Services<br/>3 services\"]\n        LOGIC[\"Logic Services<br/>6 services (3 public + 3 private)\"]\n        MARKDOWN[\"Markdown Services<br/>9 services\"]\n        TEMPLATE[\"Template Services<br/>1 service\"]\n    end\n    \n    subgraph \"Dependency Flow\"\n        COMMAND --> LOGIC\n        LOGIC --> CORE\n        LOGIC --> GLOBAL\n        VALIDATION --> SCHEMA\n        CONNECTION --> SCHEMA\n        CORE --> CONNECTION\n        GLOBAL --> CONNECTION\n        MARKDOWN -.-> \"Event Emitters\"\n    end\n    \n    BASE -.->|\"Used by all\"| CONTEXT\n    CONTEXT -.->|\"Used by all\"| SCHEMA\n```\n\nSources: [src/lib/index.ts:60-234](), [src/lib/core/types.ts:1-104]()\n\n---\n\n## 1. Base Services\n\nThe Base category contains foundational services used throughout the framework.\n\n| Service | Symbol | Purpose |\n|---------|--------|---------|\n| `LoggerService` | `TYPES.loggerService` | Structured logging with context injection |\n\n### LoggerService\n\nProvides structured logging capabilities with automatic context injection. All log messages include `methodContextService` and `executionContextService` data (strategy name, symbol, timestamp) for traceability.\n\n**Registration:** [src/lib/core/provide.ts:55-57]()\n\n**Key Methods:**\n- `log(methodName, data)` - Standard logging\n- `info(methodName, data)` - Info-level logging\n- `error(methodName, error)` - Error logging\n\nSources: [src/lib/index.ts:60-62](), [src/lib/core/types.ts:1-3](), [src/lib/core/provide.ts:55-57]()\n\n---\n\n## 2. Context Services\n\nContext services manage execution state that flows through service calls. They use `di-scoped` to maintain nested execution contexts.\n\n| Service | Symbol | Purpose |\n|---------|--------|---------|\n| `ExecutionContextService` | `TYPES.executionContextService` | Symbol, timestamp, backtest flag |\n| `MethodContextService` | `TYPES.methodContextService` | Strategy, exchange, frame names |\n\n### ExecutionContextService\n\nProvides scoped execution context for each tick/timeframe. The context includes:\n- `symbol: string` - Trading pair (e.g., \"BTCUSDT\")\n- `when: Date` - Current timeframe or live timestamp\n- `backtest: boolean` - Execution mode flag\n\n**Registration:** [src/lib/core/provide.ts:60]()\n\n**Usage Pattern:**\n```typescript\nExecutionContextService.runInContext(() => {\n  // All services access context via ExecutionContextService.getContext()\n}, { symbol, when, backtest });\n```\n\n### MethodContextService\n\nProvides scoped method context for routing to registered schemas. The context includes:\n- `strategyName: string` - Current strategy identifier\n- `exchangeName: string` - Current exchange identifier\n- `frameName: string` - Current frame identifier (backtest only)\n\n**Registration:** [src/lib/core/provide.ts:61]()\n\n**Usage Pattern:**\n```typescript\nMethodContextService.runInContext(() => {\n  // Services use context to look up correct schema\n}, { strategyName, exchangeName, frameName });\n```\n\nSources: [src/lib/index.ts:64-71](), [src/lib/core/types.ts:5-8](), [src/lib/core/provide.ts:59-62]()\n\n---\n\n## 3. Schema Services\n\nSchema services implement a **ToolRegistry** pattern for immutable configuration storage. Each schema service stores configurations registered via `add*()` functions.\n\n| Service | Symbol | Domain |\n|---------|--------|--------|\n| `StrategySchemaService` | `TYPES.strategySchemaService` | Strategy configurations |\n| `ExchangeSchemaService` | `TYPES.exchangeSchemaService` | Exchange data sources |\n| `FrameSchemaService` | `TYPES.frameSchemaService` | Timeframe definitions |\n| `WalkerSchemaService` | `TYPES.walkerSchemaService` | Strategy comparison configs |\n| `SizingSchemaService` | `TYPES.sizingSchemaService` | Position sizing logic |\n| `RiskSchemaService` | `TYPES.riskSchemaService` | Risk management rules |\n| `OptimizerSchemaService` | `TYPES.optimizerSchemaService` | LLM strategy generation |\n\n### Schema Service Pattern\n\nAll schema services follow the same interface:\n\n```typescript\nclass XSchemaService {\n  register(name: string, schema: IXSchema): void;\n  lookup(name: string): IXSchema | undefined;\n  list(): IXSchema[];\n}\n```\n\n**Registration:** [src/lib/core/provide.ts:74-82]()\n\n**Storage:** Uses `ToolRegistry` from `functools-kit` for immutable storage with shallow validation.\n\nSources: [src/lib/index.ts:97-111](), [src/lib/core/types.ts:20-28](), [src/lib/core/provide.ts:74-82](), [docs/internals.md:32-33]()\n\n---\n\n## 4. Validation Services\n\nValidation services enforce existence checks and runtime validation. They are **memoized** to optimize repeated checks.\n\n| Service | Symbol | Validates |\n|---------|--------|-----------|\n| `StrategyValidationService` | `TYPES.strategyValidationService` | Strategy schema structure, risk dependency |\n| `ExchangeValidationService` | `TYPES.exchangeValidationService` | Exchange schema required fields |\n| `FrameValidationService` | `TYPES.frameValidationService` | Frame date range and interval logic |\n| `WalkerValidationService` | `TYPES.walkerValidationService` | Walker strategy list and metric |\n| `SizingValidationService` | `TYPES.sizingValidationService` | Sizing schema parameters |\n| `RiskValidationService` | `TYPES.riskValidationService` | Risk schema validation array |\n| `OptimizerValidationService` | `TYPES.optimizerValidationService` | Optimizer source and prompt validation |\n| `ConfigValidationService` | `TYPES.configValidationService` | Global config economic viability |\n\n### Validation Service Pattern\n\n```typescript\nclass XValidationService {\n  addX(name: string, schema: IXSchema): void;  // Called by add*() functions\n  validateX(name: string): void;                // Throws if invalid\n  list(): IXSchema[];                           // Returns all registered\n}\n```\n\n**Registration:** [src/lib/core/provide.ts:127-136]()\n\n**Memoization:** Validation results are cached to prevent redundant checks during execution loops.\n\n**Dependency:** Validation services read from corresponding schema services to verify existence.\n\nSources: [src/lib/index.ts:188-213](), [src/lib/core/types.ts:73-82](), [src/lib/core/provide.ts:127-136](), [docs/internals.md:33-34]()\n\n---\n\n## 5. Connection Services\n\nConnection services are **memoized client factories** that create and cache client instances. Each connection service maintains a cache keyed by schema names or composite keys.\n\n| Service | Symbol | Creates | Cache Key |\n|---------|--------|---------|-----------|\n| `StrategyConnectionService` | `TYPES.strategyConnectionService` | `ClientStrategy` | `symbol:strategyName` |\n| `ExchangeConnectionService` | `TYPES.exchangeConnectionService` | `ClientExchange` | `exchangeName` |\n| `FrameConnectionService` | `TYPES.frameConnectionService` | `ClientFrame` | `frameName` |\n| `SizingConnectionService` | `TYPES.sizingConnectionService` | `ClientSizing` | `sizingName` |\n| `RiskConnectionService` | `TYPES.riskConnectionService` | `ClientRisk` | `riskName` |\n| `OptimizerConnectionService` | `TYPES.optimizerConnectionService` | `ClientOptimizer` | `optimizerName` |\n| `PartialConnectionService` | `TYPES.partialConnectionService` | `ClientPartial` | `symbol` |\n\n### Connection Service Diagram\n\n```mermaid\ngraph LR\n    CONN_STRAT[\"StrategyConnectionService\"]\n    CONN_EXCH[\"ExchangeConnectionService\"]\n    CONN_FRAME[\"FrameConnectionService\"]\n    CONN_RISK[\"RiskConnectionService\"]\n    \n    SCHEMA_STRAT[\"StrategySchemaService\"]\n    SCHEMA_EXCH[\"ExchangeSchemaService\"]\n    SCHEMA_FRAME[\"FrameSchemaService\"]\n    SCHEMA_RISK[\"RiskSchemaService\"]\n    \n    CLIENT_STRAT[\"ClientStrategy\"]\n    CLIENT_EXCH[\"ClientExchange\"]\n    CLIENT_FRAME[\"ClientFrame\"]\n    CLIENT_RISK[\"ClientRisk\"]\n    \n    CONN_STRAT -->|\"lookup schema\"| SCHEMA_STRAT\n    CONN_STRAT -->|\"create + cache\"| CLIENT_STRAT\n    \n    CONN_EXCH -->|\"lookup schema\"| SCHEMA_EXCH\n    CONN_EXCH -->|\"create + cache\"| CLIENT_EXCH\n    \n    CONN_FRAME -->|\"lookup schema\"| SCHEMA_FRAME\n    CONN_FRAME -->|\"create + cache\"| CLIENT_FRAME\n    \n    CONN_RISK -->|\"lookup schema\"| SCHEMA_RISK\n    CONN_RISK -->|\"create + cache\"| CLIENT_RISK\n```\n\n### Memoization Pattern\n\nConnection services use `memoizeOneArg` from `functools-kit` to cache client instances:\n\n```typescript\nclass StrategyConnectionService {\n  private readonly _getClient = memoizeOneArg((key: string) => {\n    const schema = this.strategySchemaService.lookup(strategyName);\n    return new ClientStrategy(schema, dependencies);\n  });\n  \n  getClient(symbol: string, strategyName: string): ClientStrategy {\n    return this._getClient(`${symbol}:${strategyName}`);\n  }\n}\n```\n\n**Registration:** [src/lib/core/provide.ts:64-72]()\n\n**Purpose:** Prevents creating duplicate client instances during execution loops, optimizing memory usage.\n\nSources: [src/lib/index.ts:73-95](), [src/lib/core/types.ts:10-18](), [src/lib/core/provide.ts:64-72](), [docs/internals.md:34-35]()\n\n---\n\n## 6. Core Services\n\nCore services implement **domain logic** for the three main business entities: Strategy, Exchange, and Frame.\n\n| Service | Symbol | Responsibilities |\n|---------|--------|------------------|\n| `StrategyCoreService` | `TYPES.strategyCoreService` | Signal generation, lifecycle management |\n| `ExchangeCoreService` | `TYPES.exchangeCoreService` | Candle fetching, VWAP calculation |\n| `FrameCoreService` | `TYPES.frameCoreService` | Timeframe generation, date iteration |\n\n### StrategyCoreService\n\nOrchestrates signal lifecycle by delegating to `ClientStrategy`:\n\n**Key Methods:**\n- `tick(symbol: string): Promise<IStrategyTickResult>` - Generate or monitor signal for current timeframe\n- Uses `StrategyConnectionService` to get cached `ClientStrategy` instance\n- Delegates to `ClientStrategy.tick()` and `ClientStrategy.backtest()`\n\n**Registration:** [src/lib/core/provide.ts:86]()\n\n### ExchangeCoreService\n\nManages market data fetching and price calculations:\n\n**Key Methods:**\n- `getCandles(symbol: string, interval: string, since: number, limit: number): Promise<ICandleData[]>`\n- `getNextCandles(symbol: string, interval: string, since: number, limit: number): Promise<ICandleData[]>`\n- `getAveragePrice(symbol: string): Promise<number>` - VWAP from last 5 1m candles\n\n**Registration:** [src/lib/core/provide.ts:85]()\n\n### FrameCoreService\n\nGenerates timeframe arrays for backtest iteration:\n\n**Key Methods:**\n- `getTimeframe(frameName: string): Date[]` - Generate array of Date objects for backtest loop\n\n**Registration:** [src/lib/core/provide.ts:87]()\n\nSources: [src/lib/index.ts:113-117](), [src/lib/core/types.ts:30-34](), [src/lib/core/provide.ts:84-88](), [docs/internals.md:35-36]()\n\n---\n\n## 7. Global Services\n\nGlobal services are **context wrappers** that combine validation and core service calls for public API exports.\n\n| Service | Symbol | Purpose |\n|---------|--------|---------|\n| `SizingGlobalService` | `TYPES.sizingGlobalService` | Position size calculation with validation |\n| `RiskGlobalService` | `TYPES.riskGlobalService` | Risk state management and validation |\n| `OptimizerGlobalService` | `TYPES.optimizerGlobalService` | LLM orchestration with validation |\n| `PartialGlobalService` | `TYPES.partialGlobalService` | Partial P/L tracking wrapper |\n\n### Global Service Pattern\n\nGlobal services validate input, set context, and delegate to core/connection services:\n\n```typescript\nclass SizingGlobalService {\n  async calculate(params: ISizingParams): Promise<number> {\n    // 1. Validate sizingName exists\n    this.sizingValidationService.validateSizing(params.sizingName);\n    \n    // 2. Get client via connection service\n    const client = this.sizingConnectionService.getClient(params.sizingName);\n    \n    // 3. Delegate to client\n    return await client.calculate(params);\n  }\n}\n```\n\n**Registration:** [src/lib/core/provide.ts:90-94]()\n\n**Purpose:** Provide validated, context-aware access to business logic for public API functions.\n\nSources: [src/lib/index.ts:119-128](), [src/lib/core/types.ts:36-41](), [src/lib/core/provide.ts:90-94](), [docs/internals.md:35]()\n\n---\n\n## 8. Command Services\n\nCommand services are **high-level orchestrators** for the three execution modes. They validate inputs and delegate to logic services.\n\n| Service | Symbol | Execution Mode |\n|---------|--------|----------------|\n| `BacktestCommandService` | `TYPES.backtestCommandService` | Historical simulation |\n| `LiveCommandService` | `TYPES.liveCommandService` | Real-time trading |\n| `WalkerCommandService` | `TYPES.walkerCommandService` | Strategy comparison |\n\n### Command Service Workflow\n\n```mermaid\ngraph TB\n    API[\"Public API<br/>(Backtest.run, Live.run, Walker.run)\"]\n    CMD[\"Command Service<br/>(BacktestCommandService, etc)\"]\n    VAL[\"Validation Services\"]\n    LOGIC[\"Logic Service<br/>(Public)\"]\n    \n    API --> CMD\n    CMD -->|\"1. Validate inputs\"| VAL\n    CMD -->|\"2. Set context\"| LOGIC\n    LOGIC -->|\"3. Return generator\"| CMD\n    CMD -->|\"4. Return generator\"| API\n```\n\n### BacktestCommandService\n\n**Key Method:**\n- `run(symbol: string, context: { strategyName, exchangeName, frameName }): AsyncGenerator<IStrategyTickResult>`\n\n**Workflow:**\n1. Validate `strategyName`, `exchangeName`, `frameName` exist\n2. Validate risk dependencies\n3. Delegate to `BacktestLogicPublicService.run()`\n\n**Registration:** [src/lib/core/provide.ts:99]()\n\n### LiveCommandService\n\n**Key Method:**\n- `run(symbol: string, context: { strategyName, exchangeName }): AsyncGenerator<IStrategyTickResult>`\n\n**Workflow:**\n1. Validate `strategyName`, `exchangeName` exist\n2. Validate risk dependencies\n3. Delegate to `LiveLogicPublicService.run()`\n\n**Registration:** [src/lib/core/provide.ts:98]()\n\n### WalkerCommandService\n\n**Key Method:**\n- `run(symbol: string, context: { walkerName, exchangeName, frameName }): AsyncGenerator<WalkerContract>`\n\n**Workflow:**\n1. Validate `walkerName`, `exchangeName`, `frameName` exist\n2. Validate all strategies in walker exist\n3. Delegate to `WalkerLogicPublicService.run()`\n\n**Registration:** [src/lib/core/provide.ts:100]()\n\nSources: [src/lib/index.ts:130-138](), [src/lib/core/types.ts:43-47](), [src/lib/core/provide.ts:97-101]()\n\n---\n\n## 9. Logic Services\n\nLogic services implement **execution flow** with a public/private split pattern. Public services handle context setup, while private services contain generator implementations.\n\n### Service Structure\n\n| Public Service | Private Service | Execution Mode |\n|----------------|-----------------|----------------|\n| `BacktestLogicPublicService` | `BacktestLogicPrivateService` | Historical simulation |\n| `LiveLogicPublicService` | `LiveLogicPrivateService` | Real-time trading |\n| `WalkerLogicPublicService` | `WalkerLogicPrivateService` | Strategy comparison |\n\n### Public/Private Split Pattern\n\n```mermaid\ngraph TB\n    PUBLIC[\"Logic Public Service<br/>(Context setup)\"]\n    PRIVATE[\"Logic Private Service<br/>(Generator implementation)\"]\n    METHOD_CTX[\"MethodContextService\"]\n    EXEC_CTX[\"ExecutionContextService\"]\n    \n    PUBLIC -->|\"1. Set MethodContext\"| METHOD_CTX\n    PUBLIC -->|\"2. Delegate\"| PRIVATE\n    PRIVATE -->|\"3. Set ExecutionContext per iteration\"| EXEC_CTX\n    PRIVATE -->|\"4. Yield results\"| PUBLIC\n```\n\n### BacktestLogicPublicService\n\n**Registration:** [src/lib/core/provide.ts:110]()\n\n**Key Method:**\n```typescript\nasync *run(symbol: string, context: IMethodContext): AsyncGenerator<IStrategyTickResult> {\n  yield* this.methodContextService.runInContext(() => {\n    return this.backtestLogicPrivateService.run(symbol);\n  }, context);\n}\n```\n\n### BacktestLogicPrivateService\n\n**Registration:** [src/lib/core/provide.ts:104]()\n\n**Key Method:**\n```typescript\nasync *run(symbol: string): AsyncGenerator<IStrategyTickResult> {\n  const timeframe = this.frameCoreService.getTimeframe();\n  \n  for (const when of timeframe) {\n    yield* this.executionContextService.runInContext(() => {\n      return this.strategyCoreService.tick(symbol);\n    }, { symbol, when, backtest: true });\n  }\n}\n```\n\n### LiveLogicPrivateService\n\n**Registration:** [src/lib/core/provide.ts:105]()\n\n**Key Pattern:**\n```typescript\nasync *run(symbol: string): AsyncGenerator<IStrategyTickResult> {\n  await this.clientStrategy.waitForInit(symbol);  // Load persisted state\n  \n  while (true) {\n    const when = new Date();\n    yield* this.executionContextService.runInContext(() => {\n      return this.strategyCoreService.tick(symbol);\n    }, { symbol, when, backtest: false });\n    \n    await sleep(TICK_TTL);\n  }\n}\n```\n\n### WalkerLogicPrivateService\n\n**Registration:** [src/lib/core/provide.ts:106]()\n\n**Key Pattern:**\n```typescript\nasync *run(symbol: string): AsyncGenerator<WalkerContract> {\n  const walker = this.walkerSchemaService.lookup(walkerName);\n  let bestStrategy = null;\n  let bestMetric = -Infinity;\n  \n  for (const strategyName of walker.strategies) {\n    // Run backtest for each strategy\n    const generator = this.backtestLogicPublicService.run(symbol, context);\n    for await (const result of generator) { /* collect results */ }\n    \n    // Get statistics and compare\n    const stats = this.backtestMarkdownService.getData();\n    if (stats.sharpeRatio > bestMetric) {\n      bestMetric = stats.sharpeRatio;\n      bestStrategy = strategyName;\n    }\n    \n    yield { strategyName, stats, bestStrategy, bestMetric };\n  }\n}\n```\n\nSources: [src/lib/index.ts:140-162](), [src/lib/core/types.ts:49-59](), [src/lib/core/provide.ts:103-113](), [docs/internals.md:36-37]()\n\n---\n\n## 10. Markdown Services\n\nMarkdown services generate **auto-generated reports** by subscribing to event emitters and accumulating data with bounded queues.\n\n| Service | Symbol | Tracks | MAX_EVENTS |\n|---------|--------|--------|------------|\n| `BacktestMarkdownService` | `TYPES.backtestMarkdownService` | Closed signals | 250 |\n| `LiveMarkdownService` | `TYPES.liveMarkdownService` | All tick types | 250 |\n| `ScheduleMarkdownService` | `TYPES.scheduleMarkdownService` | Scheduled signals | 250 |\n| `PerformanceMarkdownService` | `TYPES.performanceMarkdownService` | Execution metrics | 10000 |\n| `WalkerMarkdownService` | `TYPES.walkerMarkdownService` | Strategy comparison | Unbounded |\n| `HeatMarkdownService` | `TYPES.heatMarkdownService` | Portfolio stats | Unbounded |\n| `PartialMarkdownService` | `TYPES.partialMarkdownService` | Partial P/L | 250 |\n| `RiskMarkdownService` | `TYPES.riskMarkdownService` | Risk rejections | Unbounded |\n| `OutlineMarkdownService` | `TYPES.outlineMarkdownService` | System outline | N/A |\n\n### Markdown Service Pattern\n\nAll markdown services follow the `ReportStorage` pattern:\n\n```typescript\nclass XMarkdownService {\n  constructor() {\n    // Subscribe to relevant emitter\n    signalEmitter.subscribe((event) => {\n      this.events.push(event);\n      if (this.events.length > MAX_EVENTS) {\n        this.events.shift();  // Bounded queue\n      }\n    });\n  }\n  \n  getData(): XStatistics;           // Return processed statistics\n  getReport(): string;              // Return markdown report\n  dump(filename?: string): void;    // Write report to filesystem\n}\n```\n\n**Registration:** [src/lib/core/provide.ts:115-125]()\n\n### BacktestMarkdownService\n\n**Subscribes to:** `signalBacktestEmitter`\n\n**Collects:** Closed signals only (`action === 'closed'`)\n\n**Statistics:** `BacktestStatistics` - win rate, Sharpe ratio, total PNL, etc.\n\n**MAX_EVENTS:** 250 closed signals\n\n### LiveMarkdownService\n\n**Subscribes to:** `signalLiveEmitter`\n\n**Collects:** All tick types (idle, opened, active, closed)\n\n**Statistics:** `LiveStatistics` - includes all events, not just closed\n\n**MAX_EVENTS:** 250 events (all types)\n\n### HeatMarkdownService\n\n**Subscribes to:** `signalEmitter` (all signals)\n\n**Collects:** Per-symbol statistics across all strategies\n\n**Output:** Portfolio heatmap with per-symbol metrics\n\n**MAX_EVENTS:** Unbounded (aggregates data)\n\nSources: [src/lib/index.ts:164-186](), [src/lib/core/types.ts:61-71](), [src/lib/core/provide.ts:115-125](), [docs/internals.md:37-38]()\n\n---\n\n## 11. Template Services\n\nTemplate services handle **code generation** for the Optimizer execution mode.\n\n| Service | Symbol | Purpose |\n|---------|--------|---------|\n| `OptimizerTemplateService` | `TYPES.optimizerTemplateService` | Generate .mjs files with strategy code |\n\n### OptimizerTemplateService\n\nGenerates complete executable backtest files by merging:\n- Default templates (top banner, helper functions, strategy logic)\n- Custom overrides from `IOptimizerSchema.template`\n- LLM-generated strategy prompts\n\n**Registration:** [src/lib/core/provide.ts:139]()\n\n**Output Format:**\n```javascript\n// Generated .mjs file\nimport { addExchange, addStrategy, addFrame, Walker } from 'backtest-kit';\n\naddExchange({ /* ... */ });\naddFrame({ /* ... */ });\n\n// Multiple strategies generated from training periods\naddStrategy({ strategyName: 'llm-strategy-1', /* ... */ });\naddStrategy({ strategyName: 'llm-strategy-2', /* ... */ });\naddStrategy({ strategyName: 'llm-strategy-3', /* ... */ });\n\nWalker.background('BTCUSDT', {\n  walkerName: 'compare',\n  strategies: ['llm-strategy-1', 'llm-strategy-2', 'llm-strategy-3'],\n  metric: 'sharpeRatio',\n});\n```\n\n**Key Method:**\n```typescript\ngenerate(symbol: string, strategyData: IOptimizerStrategyData[]): string;\n```\n\nSources: [src/lib/index.ts:215-219](), [src/lib/core/types.ts:84-86](), [src/lib/core/provide.ts:138-140]()\n\n---\n\n## Service Registration Flow\n\nThe following diagram shows how services are registered via the DI system:\n\n```mermaid\ngraph TB\n    TYPES[\"types.ts<br/>Symbol definitions\"]\n    PROVIDE[\"provide.ts<br/>Service registration\"]\n    INDEX[\"index.ts<br/>Service aggregation\"]\n    BACKTEST[\"backtest object<br/>(exported)\"]\n    \n    TYPES -->|\"Define Symbols\"| PROVIDE\n    PROVIDE -->|\"provide(TYPES.x, () => new XService())\"| INDEX\n    INDEX -->|\"inject<XService>(TYPES.x)\"| BACKTEST\n    \n    BACKTEST -->|\"Used by\"| PUBLIC_API[\"Public API Functions<br/>(addStrategy, Backtest.run, etc)\"]\n```\n\n### Registration Pattern\n\n**Step 1:** Define Symbol in [src/lib/core/types.ts]()\n```typescript\nconst schemaServices = {\n  strategySchemaService: Symbol('strategySchemaService'),\n  // ...\n};\n```\n\n**Step 2:** Register factory in [src/lib/core/provide.ts]()\n```typescript\nprovide(TYPES.strategySchemaService, () => new StrategySchemaService());\n```\n\n**Step 3:** Inject into aggregation in [src/lib/index.ts]()\n```typescript\nconst schemaServices = {\n  strategySchemaService: inject<StrategySchemaService>(TYPES.strategySchemaService),\n  // ...\n};\n\nexport const backtest = {\n  ...schemaServices,\n  // ...other categories\n};\n```\n\n**Step 4:** Use in public API\n```typescript\nexport function addStrategy(schema: IStrategySchema) {\n  backtest.strategyValidationService.addStrategy(schema.strategyName, schema);\n  backtest.strategySchemaService.register(schema.strategyName, schema);\n}\n```\n\nSources: [src/lib/core/types.ts:1-104](), [src/lib/core/provide.ts:1-141](), [src/lib/index.ts:1-242](), [src/function/add.ts:52-64]()\n\n---\n\n## Service Category Summary Table\n\n| Category | Count | Key Responsibilities | Registration Lines |\n|----------|-------|---------------------|-------------------|\n| Base | 1 | Logging infrastructure | [src/lib/core/provide.ts:55-57]() |\n| Context | 2 | Execution state management | [src/lib/core/provide.ts:59-62]() |\n| Schema | 7 | Configuration storage (ToolRegistry) | [src/lib/core/provide.ts:74-82]() |\n| Validation | 8 | Runtime existence checks (memoized) | [src/lib/core/provide.ts:127-136]() |\n| Connection | 7 | Memoized client factories | [src/lib/core/provide.ts:64-72]() |\n| Core | 3 | Domain logic implementation | [src/lib/core/provide.ts:84-88]() |\n| Global | 4 | Context wrappers for public API | [src/lib/core/provide.ts:90-94]() |\n| Command | 3 | High-level orchestration | [src/lib/core/provide.ts:97-101]() |\n| Logic | 6 | Execution flow (public/private) | [src/lib/core/provide.ts:103-113]() |\n| Markdown | 9 | Report generation (bounded queues) | [src/lib/core/provide.ts:115-125]() |\n| Template | 1 | Code generation for Optimizer | [src/lib/core/provide.ts:138-140]() |\n\nSources: [src/lib/index.ts:60-234](), [src/lib/core/types.ts:1-104](), [src/lib/core/provide.ts:1-141]()"
                    },
                    {
                        "page_plan": {
                            "id": "3.4",
                            "title": "Client Layer"
                        },
                        "content": "# Client Layer\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [docs/classes/StrategyConnectionService.md](docs/classes/StrategyConnectionService.md)\n- [docs/index.md](docs/index.md)\n- [docs/interfaces/IStrategy.md](docs/interfaces/IStrategy.md)\n- [docs/interfaces/IStrategySchema.md](docs/interfaces/IStrategySchema.md)\n- [docs/types/IStrategyBacktestResult.md](docs/types/IStrategyBacktestResult.md)\n- [src/client/ClientStrategy.ts](src/client/ClientStrategy.ts)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [src/interfaces/Strategy.interface.ts](src/interfaces/Strategy.interface.ts)\n- [src/lib/services/connection/StrategyConnectionService.ts](src/lib/services/connection/StrategyConnectionService.ts)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThe Client Layer contains the six core business logic implementations that execute domain operations. These clients are instantiated and managed by ConnectionServices in the Service Layer (see [Service Categories](#3.3)) and consume configuration from Schema services. Each client encapsulates a specific domain responsibility: strategy execution, exchange data access, timeframe generation, risk validation, optimizer orchestration, and partial profit/loss tracking.\n\nFor information about how these clients are orchestrated in different execution modes, see [Execution Modes Overview](#2.2). For details on the service architecture that manages client instantiation, see [Dependency Injection System](#3.2).\n\n---\n\n## Architecture Overview\n\nThe Client Layer implements the business logic for six distinct domains. Each client is instantiated by its corresponding ConnectionService, which applies memoization for performance optimization. Clients receive dependencies through constructor injection and access execution context via scoped services.\n\n### Client Layer Structure\n\n```mermaid\ngraph TB\n    subgraph \"Connection Services - Client Factories\"\n        CONN_STRAT[\"StrategyConnectionService<br/>Memoized by symbol:strategyName\"]\n        CONN_EXCH[\"ExchangeConnectionService<br/>Memoized by exchangeName\"]\n        CONN_FRAME[\"FrameConnectionService<br/>Memoized by frameName\"]\n        CONN_RISK[\"RiskConnectionService<br/>Memoized by riskName\"]\n        CONN_OPT[\"OptimizerConnectionService<br/>Template merging\"]\n        CONN_PARTIAL[\"PartialConnectionService<br/>Per-symbol tracking\"]\n    end\n    \n    subgraph \"Client Implementations - Business Logic\"\n        CS[\"ClientStrategy<br/>src/client/ClientStrategy.ts<br/>Signal lifecycle management\"]\n        CE[\"ClientExchange<br/>src/client/ClientExchange.ts<br/>Data fetching & VWAP\"]\n        CF[\"ClientFrame<br/>src/client/ClientFrame.ts<br/>Timeframe generation\"]\n        CR[\"ClientRisk<br/>src/client/ClientRisk.ts<br/>Portfolio validation\"]\n        CO[\"ClientOptimizer<br/>src/client/ClientOptimizer.ts<br/>LLM code generation\"]\n        CP[\"ClientPartial<br/>src/client/ClientPartial.ts<br/>Milestone tracking\"]\n    end\n    \n    subgraph \"Key Operations\"\n        CS_OPS[\"tick()<br/>backtest()<br/>getPendingSignal()<br/>stop()\"]\n        CE_OPS[\"getCandles()<br/>getNextCandles()<br/>getAveragePrice()<br/>formatPrice/Quantity()\"]\n        CF_OPS[\"getTimeframe()\"]\n        CR_OPS[\"checkSignal()<br/>addSignal()<br/>removeSignal()\"]\n        CO_OPS[\"run()<br/>dump()\"]\n        CP_OPS[\"profit()<br/>loss()<br/>clear()\"]\n    end\n    \n    CONN_STRAT --> CS\n    CONN_EXCH --> CE\n    CONN_FRAME --> CF\n    CONN_RISK --> CR\n    CONN_OPT --> CO\n    CONN_PARTIAL --> CP\n    \n    CS --> CS_OPS\n    CE --> CE_OPS\n    CF --> CF_OPS\n    CR --> CR_OPS\n    CO --> CO_OPS\n    CP --> CP_OPS\n    \n    style CS fill:#fff4e1,stroke:#333,stroke-width:2px\n    style CE fill:#fff4e1,stroke:#333,stroke-width:2px\n    style CF fill:#fff4e1,stroke:#333,stroke-width:2px\n    style CR fill:#fff4e1,stroke:#333,stroke-width:2px\n    style CO fill:#fff4e1,stroke:#333,stroke-width:2px\n    style CP fill:#fff4e1,stroke:#333,stroke-width:2px\n```\n\n**Sources**: [src/client/ClientStrategy.ts:1-1000](), [src/lib/services/connection/StrategyConnectionService.ts:89-309](), [types.d.ts:318-413]()\n\n### Memoization Pattern\n\nAll ConnectionServices use `memoize` from `functools-kit` to cache client instances. The cache keys are constructed from schema names (e.g., `symbol:strategyName` for ClientStrategy, `exchangeName` for ClientExchange). This pattern optimizes resource usage by ensuring only one client instance exists per unique configuration.\n\n| ConnectionService | Cache Key Pattern | Instantiated Class |\n|-------------------|-------------------|-------------------|\n| StrategyConnectionService | `${symbol}:${strategyName}` | ClientStrategy |\n| ExchangeConnectionService | `${exchangeName}` | ClientExchange |\n| FrameConnectionService | `${frameName}` | ClientFrame |\n| RiskConnectionService | `${riskName}` | ClientRisk |\n| OptimizerConnectionService | `${optimizerName}` | ClientOptimizer |\n| PartialConnectionService | `${symbol}` | ClientPartial |\n\n**Sources**: [src/lib/services/connection/StrategyConnectionService.ts:120-151](), [types.d.ts:1-239]()\n\n---\n\n## ClientStrategy\n\nClientStrategy implements the `IStrategy` interface and manages the complete signal lifecycle from generation through monitoring to closure. It handles both immediate and scheduled signals, integrates with risk management, and supports both live trading (via `tick()`) and fast backtesting (via `backtest()`).\n\n### Signal Lifecycle State Machine\n\n```mermaid\nstateDiagram-v2\n    [*] --> Idle\n    \n    Idle --> Scheduled: getSignal returns with priceOpen\n    Idle --> Opened: getSignal returns without priceOpen\n    \n    Scheduled --> Opened: Price reaches priceOpen\n    Scheduled --> Cancelled: Timeout or StopLoss breached\n    Scheduled --> Idle: Risk rejection on activation\n    \n    Opened --> Active: Monitoring begins\n    \n    Active --> Closed_TP: Price hits priceTakeProfit\n    Active --> Closed_SL: Price hits priceStopLoss\n    Active --> Closed_Time: minuteEstimatedTime exceeded\n    \n    Closed_TP --> Idle\n    Closed_SL --> Idle\n    Closed_Time --> Idle\n    Cancelled --> Idle\n```\n\n**Sources**: [src/client/ClientStrategy.ts:45-330](), [src/interfaces/Strategy.interface.ts:173-312]()\n\n### Key Methods\n\n#### tick()\n\nExecutes a single strategy iteration with VWAP monitoring. This method:\n\n1. Checks for scheduled signal timeout ([src/client/ClientStrategy.ts:554-608]())\n2. Checks for scheduled signal activation ([src/client/ClientStrategy.ts:610-644]())\n3. Monitors active signal TP/SL/time expiration\n4. Calls `getSignal()` with interval throttling ([src/client/ClientStrategy.ts:332-476]())\n5. Validates signals via `VALIDATE_SIGNAL_FN` ([src/client/ClientStrategy.ts:45-330]())\n6. Persists state changes via `PersistSignalAdapter` and `PersistScheduleAdapter`\n\nReturns discriminated union `IStrategyTickResult` with action: `\"idle\" | \"scheduled\" | \"opened\" | \"active\" | \"closed\" | \"cancelled\"`.\n\n**Sources**: [src/client/ClientStrategy.ts:332-1000](), [types.d.ts:852-1002]()\n\n#### backtest()\n\nPerforms fast historical simulation by iterating through candle data. For each candle:\n\n1. Calculates VWAP using `GET_AVG_PRICE_FN` ([src/client/ClientStrategy.ts:478-489]())\n2. For scheduled signals: checks activation/cancellation conditions\n3. For active signals: checks if TP/SL/time conditions met\n4. Returns immediately upon closure (optimization: skips remaining candles)\n\nReturns `IStrategyBacktestResult` (always `\"closed\"` or `\"cancelled\"`), never `\"idle\"` or `\"active\"`.\n\n**Sources**: [src/client/ClientStrategy.ts:1-1000](), [types.d.ts:310-312]()\n\n### Scheduled Signal Handling\n\nClientStrategy supports delayed entry signals where `priceOpen` is specified in `ISignalDto`. The signal enters `\"scheduled\"` state and waits for price to reach entry point:\n\n- **Long positions**: Activates when `currentPrice <= priceOpen`\n- **Short positions**: Activates when `currentPrice >= priceOpen`\n- **Cancellation**: Occurs if price breaches `priceStopLoss` before activation or timeout exceeds `CC_SCHEDULE_AWAIT_MINUTES`\n\nTimeout logic is implemented in `CHECK_SCHEDULED_SIGNAL_TIMEOUT_FN` ([src/client/ClientStrategy.ts:554-608]()), activation logic in `CHECK_SCHEDULED_SIGNAL_PRICE_ACTIVATION_FN` ([src/client/ClientStrategy.ts:610-644]()).\n\n**Sources**: [src/client/ClientStrategy.ts:389-443](), [src/client/ClientStrategy.ts:554-644]()\n\n### Signal Validation\n\nAll signals pass through `VALIDATE_SIGNAL_FN` which enforces:\n\n- Price sanity checks (finite, positive values)\n- Long position rules: `priceStopLoss < priceOpen < priceTakeProfit`\n- Short position rules: `priceTakeProfit < priceOpen < priceStopLoss`\n- Minimum TP distance: `>= CC_MIN_TAKEPROFIT_DISTANCE_PERCENT` ([src/client/ClientStrategy.ts:163-173]())\n- Minimum SL distance: `>= CC_MIN_STOPLOSS_DISTANCE_PERCENT` ([src/client/ClientStrategy.ts:176-186]())\n- Maximum SL distance: `<= CC_MAX_STOPLOSS_DISTANCE_PERCENT` ([src/client/ClientStrategy.ts:189-199]())\n- Maximum lifetime: `<= CC_MAX_SIGNAL_LIFETIME_MINUTES` ([src/client/ClientStrategy.ts:306-316]())\n- Immediate closure prevention: validates `currentPrice` is between SL and TP bounds\n\n**Sources**: [src/client/ClientStrategy.ts:45-330](), [types.d.ts:5-115]()\n\n### Integration Points\n\nClientStrategy receives dependencies via `IStrategyParams`:\n\n| Dependency | Type | Purpose |\n|------------|------|---------|\n| `exchange` | `IExchange` | VWAP calculation, candle fetching |\n| `risk` | `IRisk` | Signal validation via `checkSignal()` |\n| `partial` | `IPartial` | Milestone tracking for profit/loss levels |\n| `execution` | `TExecutionContextService` | Symbol, when (timestamp), backtest flag |\n| `method` | `TMethodContextService` | strategyName, exchangeName, frameName |\n\nRisk integration occurs at two points:\n1. Before signal creation in `GET_SIGNAL_FN` ([src/client/ClientStrategy.ts:374-387]())\n2. Before scheduled signal activation in `ACTIVATE_SCHEDULED_SIGNAL_FN` ([src/client/ClientStrategy.ts:711-729]())\n\n**Sources**: [src/interfaces/Strategy.interface.ts:76-94](), [src/client/ClientStrategy.ts:332-476](), [src/client/ClientStrategy.ts:681-774]()\n\n---\n\n## ClientExchange\n\nClientExchange implements the `IExchange` interface and provides market data access with retry logic, anomaly detection, and VWAP calculation. It wraps the user-provided `getCandles` implementation from `IExchangeSchema` with production-grade error handling.\n\n### Data Flow\n\n```mermaid\ngraph TB\n    SCHEMA[\"IExchangeSchema<br/>User-provided getCandles\"]\n    CLIENT[\"ClientExchange<br/>src/client/ClientExchange.ts\"]\n    RETRY[\"Retry Logic<br/>CC_GET_CANDLES_RETRY_COUNT\"]\n    ANOMALY[\"Anomaly Detection<br/>CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR\"]\n    VWAP[\"VWAP Calculation<br/>CC_AVG_PRICE_CANDLES_COUNT\"]\n    \n    SCHEMA -->|\"getCandles()\"| CLIENT\n    CLIENT --> RETRY\n    RETRY --> ANOMALY\n    ANOMALY --> VWAP\n    \n    RETRY -->|\"Fails after retries\"| ERROR[\"errorEmitter.next()\"]\n    ANOMALY -->|\"Price < median/1000\"| ERROR\n```\n\n**Sources**: [src/client/ClientExchange.ts:1-300](), [types.d.ts:329-413]()\n\n### Key Methods\n\n#### getCandles()\n\nFetches historical candles **backwards** from execution context time (`execution.context.when`). Implements:\n\n- Retry logic with exponential backoff (`CC_GET_CANDLES_RETRY_COUNT`, `CC_GET_CANDLES_RETRY_DELAY_MS`)\n- Price anomaly detection to filter incomplete candles ([types.d.ts:84-91]())\n- Median-based validation: rejects candles where `price < median / CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR`\n- Callback invocation: `callbacks.onCandleData` if provided\n\n**Sources**: [types.d.ts:370-377](), [types.d.ts:72-106]()\n\n#### getNextCandles()\n\nFetches future candles **forward** from execution context time (backtest mode only). Used by `ClientStrategy.backtest()` to simulate forward-looking price action. Same retry/anomaly logic as `getCandles()`.\n\n**Sources**: [types.d.ts:378-386]()\n\n#### getAveragePrice()\n\nCalculates VWAP from last `CC_AVG_PRICE_CANDLES_COUNT` candles (default: 5) using 1-minute interval:\n\n```\nTypical Price = (High + Low + Close) / 3\nVWAP = Σ(Typical Price × Volume) / Σ(Volume)\n```\n\nFalls back to simple average if total volume is zero.\n\n**Sources**: [types.d.ts:404-412](), [types.d.ts:14-15]()\n\n#### formatPrice() and formatQuantity()\n\nDelegate to user-provided formatting functions in `IExchangeSchema`. These enforce exchange-specific precision rules (e.g., Binance requires 8 decimal places for BTC prices).\n\n**Sources**: [types.d.ts:388-403]()\n\n### Anomaly Detection Rationale\n\nThe anomaly detection system addresses a known issue with incomplete candles from exchange APIs. When the API returns incomplete data, prices can be near zero (e.g., `$0.01` for BTC instead of `$50,000`). The threshold factor of 1000 catches these anomalies:\n\n- BTC at `$50,000` median → threshold `$50` → rejects `$0.01` candles\n- Factor 1000 is chosen as a balance: strict enough to catch incomplete data, permissive enough for normal volatility\n\n**Sources**: [types.d.ts:84-91]()\n\n---\n\n## ClientFrame\n\nClientFrame implements the `IFrame` interface and generates arrays of timestamps for backtest iteration. It converts date ranges and intervals from `IFrameSchema` into concrete `Date[]` arrays.\n\n### Timeframe Generation\n\n```mermaid\ngraph LR\n    SCHEMA[\"IFrameSchema<br/>startDate: Date<br/>endDate: Date<br/>interval: FrameInterval\"]\n    CLIENT[\"ClientFrame<br/>src/client/ClientFrame.ts\"]\n    ARRAY[\"Date[]<br/>Sequential timestamps\"]\n    \n    SCHEMA -->|\"getTimeframe()\"| CLIENT\n    CLIENT --> GENERATE[\"Generate timestamps<br/>with interval spacing\"]\n    GENERATE --> ARRAY\n    ARRAY -->|\"onTimeframe callback\"| USER[\"User notification\"]\n```\n\n**Sources**: [src/client/ClientFrame.ts:1-200](), [types.d.ts:419-502]()\n\n### Interval Mapping\n\nClientFrame converts `FrameInterval` strings into millisecond offsets:\n\n| FrameInterval | Milliseconds | Example Usage |\n|---------------|--------------|---------------|\n| `\"1m\"` | 60,000 | High-frequency scalping backtests |\n| `\"5m\"` | 300,000 | Short-term swing strategies |\n| `\"15m\"` | 900,000 | Intraday trend following |\n| `\"1h\"` | 3,600,000 | Multi-hour position strategies |\n| `\"4h\"` | 14,400,000 | Daily swing trading |\n| `\"1d\"` | 86,400,000 | Long-term position strategies |\n\n**Sources**: [types.d.ts:427]()\n\n### Callbacks\n\nIf `IFrameSchema.callbacks.onTimeframe` is provided, ClientFrame invokes it after generating the timeframe array. This allows inspection of generated timestamps for validation or logging purposes.\n\n**Sources**: [types.d.ts:438-450](), [types.d.ts:461-467]()\n\n---\n\n## ClientRisk\n\nClientRisk implements the `IRisk` interface and enforces portfolio-level risk controls via custom validation functions. It maintains in-memory tracking of active positions across all strategies and validates new signals against user-defined rules.\n\n### Risk Validation Flow\n\n```mermaid\ngraph TB\n    SIGNAL[\"New Signal<br/>ISignalDto\"]\n    CHECK[\"checkSignal()<br/>IRiskCheckArgs\"]\n    \n    VALIDATE[\"Execute Validations<br/>IRiskValidation[]\"]\n    \n    STATE[\"Active Positions<br/>IRiskActivePosition[]\"]\n    \n    PAYLOAD[\"IRiskValidationPayload<br/>pendingSignal<br/>activePositionCount<br/>activePositions\"]\n    \n    SIGNAL --> CHECK\n    CHECK --> STATE\n    STATE --> PAYLOAD\n    CHECK --> VALIDATE\n    PAYLOAD --> VALIDATE\n    \n    VALIDATE -->|\"All pass\"| ALLOWED[\"Return true<br/>callbacks.onAllowed\"]\n    VALIDATE -->|\"Any throws\"| REJECTED[\"Return false<br/>callbacks.onRejected<br/>riskSubject.next()\"]\n```\n\n**Sources**: [src/client/ClientRisk.ts:1-300](), [types.d.ts:546-691]()\n\n### Validation System\n\nRisk validations are defined as an array in `IRiskSchema.validations`. Each validation can be:\n\n1. Function directly: `(payload: IRiskValidationPayload) => void`\n2. Object with function + note: `{ validate: Function, note: string }`\n\nThe `note` field is included in rejection events emitted to `riskSubject`, allowing identification of which rule failed.\n\n**Sources**: [types.d.ts:599-634]()\n\n### Position Tracking\n\nClientRisk maintains three parallel data structures:\n\n| Method | Purpose | Timing |\n|--------|---------|--------|\n| `checkSignal()` | Pre-creation validation | Before signal opens |\n| `addSignal()` | Register opened position | After signal opens |\n| `removeSignal()` | Unregister closed position | After signal closes |\n\nThe active position count and list are passed to validation functions via `IRiskValidationPayload`, enabling rules like \"max 3 concurrent positions\" or \"no more than 1 position per symbol\".\n\n**Sources**: [types.d.ts:656-687]()\n\n### Integration with Persistence\n\nIn live mode, ClientRisk state is persisted via `PersistRiskAdapter` for crash recovery. The `_states` Map is serialized to JSON and restored on initialization via `waitForInit()`.\n\n**Sources**: [types.d.ts:637-654]()\n\n---\n\n## ClientPartial\n\nClientPartial implements the `IPartial` interface and tracks profit/loss milestones (10%, 20%, 30%, ..., 100%) for active signals. It uses Set-based deduplication to ensure each level is emitted exactly once per signal.\n\n### Milestone Tracking Architecture\n\n```mermaid\ngraph TB\n    SIGNAL[\"Active Signal<br/>ISignalRow\"]\n    \n    MONITOR[\"ClientStrategy monitoring<br/>Calculate revenuePercent\"]\n    \n    PROFIT[\"profit()<br/>revenuePercent > 0\"]\n    LOSS[\"loss()<br/>revenuePercent < 0\"]\n    \n    CHECK_PROF[\"Check profit levels<br/>10%, 20%, 30%, ...\"]\n    CHECK_LOSS[\"Check loss levels<br/>10%, 20%, 30%, ...\"]\n    \n    DEDUP_PROF[\"Set<PartialLevel><br/>profitLevels\"]\n    DEDUP_LOSS[\"Set<PartialLevel><br/>lossLevels\"]\n    \n    EMIT_PROF[\"partialProfitSubject.next()<br/>PartialProfitContract\"]\n    EMIT_LOSS[\"partialLossSubject.next()<br/>PartialLossContract\"]\n    \n    PERSIST[\"PersistPartialAdapter<br/>Serialize Sets to arrays\"]\n    \n    SIGNAL --> MONITOR\n    MONITOR -->|\"Profit\"| PROFIT\n    MONITOR -->|\"Loss\"| LOSS\n    \n    PROFIT --> CHECK_PROF\n    LOSS --> CHECK_LOSS\n    \n    CHECK_PROF --> DEDUP_PROF\n    CHECK_LOSS --> DEDUP_LOSS\n    \n    DEDUP_PROF -->|\"New level\"| EMIT_PROF\n    DEDUP_LOSS -->|\"New level\"| EMIT_LOSS\n    \n    EMIT_PROF --> PERSIST\n    EMIT_LOSS --> PERSIST\n```\n\n**Sources**: [src/client/ClientPartial.ts:1-300](), [types.d.ts:693-847]()\n\n### Deduplication Logic\n\nClientPartial maintains per-signal state:\n\n```typescript\ninterface IPartialState {\n  profitLevels: Set<PartialLevel>; // 10, 20, 30, ..., 100\n  lossLevels: Set<PartialLevel>;   // 10, 20, 30, ..., 100\n}\n```\n\nWhen `profit()` is called with `revenuePercent = 22.5`:\n1. Calculates which levels are reached: 10, 20\n2. Checks `profitLevels` Set: 10 already exists, 20 is new\n3. Emits event only for 20%\n4. Adds 20 to `profitLevels` Set\n\nThis ensures each milestone is reported exactly once even if price oscillates around threshold.\n\n**Sources**: [types.d.ts:756-789](), [types.d.ts:705]()\n\n### Persistence\n\nFor live mode crash recovery, ClientPartial serializes state via `PersistPartialAdapter`:\n\n- In-memory: `Map<signalId, IPartialState>` (Sets)\n- On disk: `Record<signalId, IPartialData>` (arrays)\n\nConversion happens in `waitForInit()` (deserialize) and on each emit (serialize).\n\n**Sources**: [types.d.ts:707-724]()\n\n### Clear Operation\n\nWhen a signal closes, `clear()` removes the signal's state from memory and disk. This prevents unbounded growth of the state map and ensures milestone tracking is reset for future signals.\n\n**Sources**: [types.d.ts:825-847]()\n\n---\n\n## ClientOptimizer\n\nClientOptimizer implements the `IOptimizer` interface and orchestrates LLM-based strategy code generation. It fetches multi-timeframe historical data, formats it for LLM consumption, sends prompts to Ollama API, and generates executable `.mjs` files.\n\n### Optimization Pipeline\n\n```mermaid\ngraph TB\n    SOURCES[\"Data Sources<br/>IOptimizerSource[]<br/>1h, 30m, 15m, 1m\"]\n    \n    FETCH[\"Fetch Historical Data<br/>CCXT_DUMPER_URL or<br/>ExchangeCoreService\"]\n    \n    FORMAT[\"Format for LLM<br/>Markdown tables<br/>MessageModel[]\"]\n    \n    PROMPT[\"getPrompt callback<br/>User-defined strategy logic\"]\n    \n    LLM[\"Ollama API<br/>deepseek-v3.1:671b<br/>Generate strategy code\"]\n    \n    TEMPLATE[\"OptimizerTemplateService<br/>Merge with template<br/>addExchange, addStrategy, Walker.background\"]\n    \n    OUTPUT[\"Generated Code<br/>Complete .mjs file\"]\n    \n    DUMP[\"Optimizer.dump()<br/>Write to filesystem<br/>./{optimizerName}_{symbol}.mjs\"]\n    \n    SOURCES --> FETCH\n    FETCH --> FORMAT\n    FORMAT --> PROMPT\n    PROMPT --> LLM\n    LLM --> TEMPLATE\n    TEMPLATE --> OUTPUT\n    OUTPUT --> DUMP\n```\n\n**Sources**: [src/client/ClientOptimizer.ts:1-500](), [types.d.ts:3000-3200]()\n\n### Data Source Iteration\n\nClientOptimizer iterates through `IOptimizerSource[]` defined in `IOptimizerSchema.sources`. Each source specifies:\n\n| Field | Type | Purpose |\n|-------|------|---------|\n| `interval` | `CandleInterval` | Candle timeframe (e.g., \"1h\", \"15m\") |\n| `range` | `IOptimizerRange` | Date range for data fetching |\n| `filter` | `(args: IOptimizerFilterArgs) => boolean` | Post-fetch filtering predicate |\n\nFor each source, optimizer fetches candles and formats them as markdown tables for LLM context window.\n\n**Sources**: [types.d.ts:3050-3100]()\n\n### LLM Prompt Construction\n\nThe user provides `getPrompt` callback which receives formatted data and returns `MessageModel[]`. This allows complete control over LLM instruction:\n\n```typescript\ngetPrompt: (data: IOptimizerData[]) => Promise<MessageModel[]>\n```\n\n`IOptimizerData` contains:\n- `interval`: Source timeframe\n- `candles`: Formatted markdown table\n- `range`: Date range metadata\n\n**Sources**: [types.d.ts:3150-3170]()\n\n### Template System\n\nClientOptimizer uses `OptimizerTemplateService` to merge LLM-generated strategy code with boilerplate:\n\n1. Default template includes `addExchange`, `addStrategy`, `Walker.background` calls\n2. User can override via `IOptimizerSchema.template.code`\n3. Template receives strategy code as `{{strategy}}` placeholder\n4. Result is executable Node.js module\n\n**Sources**: [src/lib/services/template/OptimizerTemplateService.ts:1-200]()\n\n### Code Export\n\nGenerated code is returned as string from `run()` method. To write to disk:\n\n```typescript\nconst code = await Optimizer.run(\"BTCUSDT\", { optimizerName: \"my-optimizer\" });\nawait Optimizer.dump(\"my-optimizer\", \"BTCUSDT\", code);\n// Writes to ./my-optimizer_BTCUSDT.mjs\n```\n\n**Sources**: [types.d.ts:3200-3250]()\n\n---\n\n## Instantiation and Lifecycle\n\nAll client instances are created and managed by their respective ConnectionServices, which implement consistent patterns for instantiation, dependency injection, and lifecycle management.\n\n### Factory Pattern\n\nConnectionServices act as factories with memoization:\n\n```mermaid\ngraph TB\n    CALL[\"Core/Logic Service calls<br/>strategyConnectionService.tick()\"]\n    \n    MEMO_CHECK[\"Memoization Check<br/>Key: symbol:strategyName\"]\n    \n    CACHE_HIT[\"Cache Hit<br/>Return existing ClientStrategy\"]\n    CACHE_MISS[\"Cache Miss<br/>Create new ClientStrategy\"]\n    \n    INJECT[\"Dependency Injection<br/>execution, method, logger,<br/>exchange, risk, partial\"]\n    \n    SCHEMA[\"Retrieve from Schema Service<br/>StrategySchemaService.get()\"]\n    \n    CONSTRUCT[\"new ClientStrategy(params)\"]\n    \n    STORE[\"Store in memoize cache\"]\n    \n    RETURN[\"Return instance\"]\n    \n    CALL --> MEMO_CHECK\n    MEMO_CHECK -->|\"Exists\"| CACHE_HIT\n    MEMO_CHECK -->|\"Missing\"| CACHE_MISS\n    \n    CACHE_MISS --> SCHEMA\n    SCHEMA --> INJECT\n    INJECT --> CONSTRUCT\n    CONSTRUCT --> STORE\n    STORE --> RETURN\n    \n    CACHE_HIT --> RETURN\n```\n\n**Sources**: [src/lib/services/connection/StrategyConnectionService.ts:120-151]()\n\n### Dependency Injection Pattern\n\nAll clients receive dependencies via constructor parameters. Example from ClientStrategy:\n\n```typescript\nnew ClientStrategy({\n  symbol: string,\n  interval: SignalInterval,\n  execution: TExecutionContextService,    // Scoped: symbol, when, backtest\n  method: TMethodContextService,          // Scoped: strategyName, exchangeName, frameName\n  logger: ILogger,                        // Global: LoggerService\n  partial: IPartial,                      // Memoized: PartialConnectionService\n  exchange: IExchange,                    // Memoized: ExchangeConnectionService\n  risk: IRisk,                            // Memoized: RiskConnectionService or NOOP_RISK\n  riskName: RiskName,\n  strategyName: StrategyName,\n  getSignal: Function,                    // From StrategySchemaService\n  callbacks: IStrategyCallbacks           // From StrategySchemaService\n})\n```\n\nThis pattern ensures:\n- Clients are decoupled from service locator\n- Dependencies are explicit and type-safe\n- Easy to mock for testing\n\n**Sources**: [src/interfaces/Strategy.interface.ts:76-94](), [src/lib/services/connection/StrategyConnectionService.ts:130-149]()\n\n### Initialization: waitForInit()\n\nClients that require crash recovery implement `waitForInit()` method:\n\n| Client | Persistence Adapter | Recovery Action |\n|--------|---------------------|-----------------|\n| ClientStrategy | PersistSignalAdapter, PersistScheduleAdapter | Restore pending/scheduled signals |\n| ClientRisk | PersistRiskAdapter | Restore active position tracking |\n| ClientPartial | PersistPartialAdapter | Restore profit/loss milestone state |\n\nIn live mode, ConnectionServices call `await strategy.waitForInit()` before first operation. In backtest mode, `waitForInit()` returns immediately (no persistence).\n\n**Sources**: [src/client/ClientStrategy.ts:491-552]()\n\n### Cache Management\n\nConnectionServices provide `clear()` method to invalidate memoization cache:\n\n```typescript\n// Clear specific instance\nawait strategyConnectionService.clear({ \n  symbol: \"BTCUSDT\", \n  strategyName: \"my-strategy\" \n});\n\n// Clear all instances\nawait strategyConnectionService.clear();\n```\n\nThis is useful for:\n- Releasing resources after execution completes\n- Resetting state between test runs\n- Force-reloading strategy after schema changes\n\n**Sources**: [src/lib/services/connection/StrategyConnectionService.ts:292-305]()\n\n### Risk Composition\n\nStrategyConnectionService implements special logic for risk composition. If `IStrategySchema` defines both `riskName` and `riskList`, they are merged:\n\n```typescript\nconst GET_RISK_FN = (dto, self) => {\n  if (!dto.riskName && !dto.riskList?.length) {\n    return NOOP_RISK;\n  }\n  if (dto.riskName && dto.riskList?.length) {\n    return new MergeRisk([\n      self.riskConnectionService.getRisk(dto.riskName),\n      ...dto.riskList.map(name => self.riskConnectionService.getRisk(name))\n    ]);\n  }\n  // ... single risk cases\n};\n```\n\n`MergeRisk` class combines multiple risk profiles by executing all validations sequentially.\n\n**Sources**: [src/lib/services/connection/StrategyConnectionService.ts:33-67]()\n\n---\n\n## Summary Table\n\n| Client | Interface | File Path | Primary Methods | Memoization Key |\n|--------|-----------|-----------|-----------------|-----------------|\n| ClientStrategy | `IStrategy` | [src/client/ClientStrategy.ts:1-1000]() | `tick()`, `backtest()`, `getPendingSignal()`, `stop()` | `${symbol}:${strategyName}` |\n| ClientExchange | `IExchange` | [src/client/ClientExchange.ts:1-300]() | `getCandles()`, `getNextCandles()`, `getAveragePrice()`, `formatPrice()`, `formatQuantity()` | `${exchangeName}` |\n| ClientFrame | `IFrame` | [src/client/ClientFrame.ts:1-200]() | `getTimeframe()` | `${frameName}` |\n| ClientRisk | `IRisk` | [src/client/ClientRisk.ts:1-300]() | `checkSignal()`, `addSignal()`, `removeSignal()` | `${riskName}` |\n| ClientPartial | `IPartial` | [src/client/ClientPartial.ts:1-300]() | `profit()`, `loss()`, `clear()` | `${symbol}` |\n| ClientOptimizer | `IOptimizer` | [src/client/ClientOptimizer.ts:1-500]() | `run()`, `dump()` | `${optimizerName}` |\n\n**Sources**: [types.d.ts:1-4000](), [src/lib/services/connection/StrategyConnectionService.ts:1-309]()"
                    },
                    {
                        "page_plan": {
                            "id": "4",
                            "title": "Strategy System"
                        },
                        "content": "# Strategy System\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [src/client/ClientStrategy.ts](src/client/ClientStrategy.ts)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [src/interfaces/Heatmap.interface.ts](src/interfaces/Heatmap.interface.ts)\n- [src/interfaces/Strategy.interface.ts](src/interfaces/Strategy.interface.ts)\n- [src/lib/services/connection/StrategyConnectionService.ts](src/lib/services/connection/StrategyConnectionService.ts)\n- [test/e2e/defend.test.mjs](test/e2e/defend.test.mjs)\n- [test/e2e/risk.test.mjs](test/e2e/risk.test.mjs)\n- [test/index.mjs](test/index.mjs)\n- [test/mock/getMockCandles.mjs](test/mock/getMockCandles.mjs)\n- [test/spec/heat.test.mjs](test/spec/heat.test.mjs)\n- [test/spec/list.test.mjs](test/spec/list.test.mjs)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThe Strategy System is the core mechanism for defining, registering, and executing trading strategies in the backtest-kit framework. This system handles signal generation, lifecycle management, risk validation, and execution across both backtest and live trading modes.\n\nThis page covers strategy schema definition, signal types, execution flow, and integration with risk management. For details on specific execution modes, see Backtest Mode ([#5.1](#5.1)), Live Trading Mode ([#5.2](#5.2)), and Walker Mode ([#5.3](#5.3)). For risk validation rules, see Risk Management ([#4.3](#4.3)). For position sizing calculations, see Position Sizing ([#4.4](#4.4)).\n\n---\n\n## Core Architecture\n\n### Strategy System Component Hierarchy\n\n```mermaid\ngraph TB\n    subgraph \"Public API\"\n        ADD_STRATEGY[\"addStrategy(IStrategySchema)\"]\n        LIST_STRATEGIES[\"listStrategies()\"]\n    end\n    \n    subgraph \"Schema Registry\"\n        STRATEGY_SCHEMA[\"StrategySchemaService\"]\n        STRATEGY_VALIDATION[\"StrategyValidationService\"]\n        STORAGE[\"Map<StrategyName, IStrategySchema>\"]\n    end\n    \n    subgraph \"Connection Layer\"\n        STRATEGY_CONNECTION[\"StrategyConnectionService\"]\n        MEMOIZE[\"memoize(symbol:strategyName)\"]\n    end\n    \n    subgraph \"Client Implementation\"\n        CLIENT_STRATEGY[\"ClientStrategy\"]\n        PENDING_SIGNAL[\"_pendingSignal: ISignalRow | null\"]\n        SCHEDULED_SIGNAL[\"_scheduledSignal: IScheduledSignalRow | null\"]\n        LAST_TIMESTAMP[\"_lastSignalTimestamp: number | null\"]\n        IS_STOPPED[\"_isStopped: boolean\"]\n    end\n    \n    subgraph \"Signal Lifecycle\"\n        TICK[\"tick(): IStrategyTickResult\"]\n        BACKTEST[\"backtest(): IStrategyBacktestResult\"]\n        GET_SIGNAL_FN[\"GET_SIGNAL_FN()\"]\n        VALIDATE_SIGNAL[\"VALIDATE_SIGNAL_FN()\"]\n    end\n    \n    subgraph \"Risk Integration\"\n        RISK_CHECK[\"IRisk.checkSignal()\"]\n        RISK_ADD[\"IRisk.addSignal()\"]\n        RISK_REMOVE[\"IRisk.removeSignal()\"]\n        MERGE_RISK[\"MergeRisk\"]\n    end\n    \n    subgraph \"Persistence\"\n        PERSIST_SIGNAL[\"PersistSignalAdapter\"]\n        PERSIST_SCHEDULE[\"PersistScheduleAdapter\"]\n        WAIT_INIT[\"waitForInit()\"]\n    end\n    \n    subgraph \"Event System\"\n        SIGNAL_EMITTER[\"signalEmitter\"]\n        SIGNAL_BACKTEST[\"signalBacktestEmitter\"]\n        SIGNAL_LIVE[\"signalLiveEmitter\"]\n        CALLBACKS[\"IStrategyCallbacks\"]\n    end\n    \n    ADD_STRATEGY --> STRATEGY_VALIDATION\n    STRATEGY_VALIDATION --> STRATEGY_SCHEMA\n    STRATEGY_SCHEMA --> STORAGE\n    \n    STRATEGY_CONNECTION --> MEMOIZE\n    MEMOIZE --> CLIENT_STRATEGY\n    \n    CLIENT_STRATEGY --> PENDING_SIGNAL\n    CLIENT_STRATEGY --> SCHEDULED_SIGNAL\n    CLIENT_STRATEGY --> LAST_TIMESTAMP\n    CLIENT_STRATEGY --> IS_STOPPED\n    \n    CLIENT_STRATEGY --> TICK\n    CLIENT_STRATEGY --> BACKTEST\n    TICK --> GET_SIGNAL_FN\n    BACKTEST --> GET_SIGNAL_FN\n    GET_SIGNAL_FN --> VALIDATE_SIGNAL\n    \n    GET_SIGNAL_FN --> RISK_CHECK\n    CLIENT_STRATEGY --> RISK_ADD\n    CLIENT_STRATEGY --> RISK_REMOVE\n    RISK_CHECK --> MERGE_RISK\n    \n    CLIENT_STRATEGY --> WAIT_INIT\n    WAIT_INIT --> PERSIST_SIGNAL\n    WAIT_INIT --> PERSIST_SCHEDULE\n    \n    CLIENT_STRATEGY --> CALLBACKS\n    STRATEGY_CONNECTION --> SIGNAL_EMITTER\n    STRATEGY_CONNECTION --> SIGNAL_BACKTEST\n    STRATEGY_CONNECTION --> SIGNAL_LIVE\n```\n\n**Sources**: [src/client/ClientStrategy.ts:1-1158](), [src/lib/services/connection/StrategyConnectionService.ts:1-309](), [src/interfaces/Strategy.interface.ts:1-394]()\n\n---\n\n## Strategy Schema and Registration\n\n### IStrategySchema Interface\n\nStrategies are registered via `addStrategy()` with an `IStrategySchema` object. The schema defines signal generation logic, throttling interval, lifecycle callbacks, and risk management configuration.\n\n| Property | Type | Required | Description |\n|----------|------|----------|-------------|\n| `strategyName` | `StrategyName` | ✓ | Unique identifier for strategy registration |\n| `interval` | `SignalInterval` | ✓ | Minimum time between `getSignal()` calls |\n| `getSignal` | `function` | ✓ | Signal generation callback function |\n| `note` | `string` | ✗ | Optional developer documentation |\n| `callbacks` | `Partial<IStrategyCallbacks>` | ✗ | Lifecycle event hooks |\n| `riskName` | `RiskName` | ✗ | Single risk profile identifier |\n| `riskList` | `RiskName[]` | ✗ | Multiple risk profiles (combined) |\n\n**Sources**: [src/interfaces/Strategy.interface.ts:128-151](), [types.d.ts:936-955]()\n\n### Signal Generation Intervals\n\nThe `interval` property enforces throttling to prevent excessive `getSignal()` calls:\n\n| Interval | Minutes | Use Case |\n|----------|---------|----------|\n| `\"1m\"` | 1 | High-frequency scalping |\n| `\"3m\"` | 3 | Short-term momentum |\n| `\"5m\"` | 5 | Standard intraday |\n| `\"15m\"` | 15 | Medium-term swing |\n| `\"30m\"` | 30 | Position trading |\n| `\"1h\"` | 60 | Long-term strategies |\n\nThrottling is enforced by `_lastSignalTimestamp` tracking in ClientStrategy. If less than the interval has elapsed since the last call, `getSignal()` is skipped.\n\n**Sources**: [src/interfaces/Strategy.interface.ts:8-18](), [src/client/ClientStrategy.ts:34-41](), [src/client/ClientStrategy.ts:340-352]()\n\n### Registration Example\n\n```typescript\naddStrategy({\n  strategyName: \"momentum-scalper\",\n  interval: \"5m\",\n  riskName: \"conservative\",\n  note: \"5-minute momentum strategy with 2% risk per trade\",\n  getSignal: async (symbol: string, when: Date) => {\n    // Signal generation logic\n    if (shouldEnter) {\n      return {\n        position: \"long\",\n        priceTakeProfit: 43500,\n        priceStopLoss: 41500,\n        minuteEstimatedTime: 120,\n        note: \"Momentum breakout\"\n      };\n    }\n    return null; // No signal\n  },\n  callbacks: {\n    onOpen: (symbol, data, currentPrice, backtest) => {\n      console.log(`Signal opened: ${data.id}`);\n    },\n    onClose: (symbol, data, priceClose, backtest) => {\n      console.log(`Signal closed: ${data.id}`);\n    }\n  }\n});\n```\n\n**Sources**: [src/function/add.ts:1-200](), [README.md:106-138]()\n\n---\n\n## Signal Types and State Machine\n\n### Signal Type Hierarchy\n\n```mermaid\ngraph TB\n    subgraph \"User-Provided DTO\"\n        DTO[\"ISignalDto\"]\n        DTO_ID[\"id?: string\"]\n        DTO_POSITION[\"position: long | short\"]\n        DTO_OPEN[\"priceOpen?: number\"]\n        DTO_TP[\"priceTakeProfit: number\"]\n        DTO_SL[\"priceStopLoss: number\"]\n        DTO_TIME[\"minuteEstimatedTime: number\"]\n        DTO_NOTE[\"note?: string\"]\n        \n        DTO --> DTO_ID\n        DTO --> DTO_POSITION\n        DTO --> DTO_OPEN\n        DTO --> DTO_TP\n        DTO --> DTO_SL\n        DTO --> DTO_TIME\n        DTO --> DTO_NOTE\n    end\n    \n    subgraph \"System-Augmented Row\"\n        ROW[\"ISignalRow\"]\n        ROW_ID[\"id: string (UUID v4)\"]\n        ROW_OPEN[\"priceOpen: number (required)\"]\n        ROW_EXCHANGE[\"exchangeName: ExchangeName\"]\n        ROW_STRATEGY[\"strategyName: StrategyName\"]\n        ROW_SYMBOL[\"symbol: string\"]\n        ROW_SCHEDULED[\"scheduledAt: number (ms)\"]\n        ROW_PENDING[\"pendingAt: number (ms)\"]\n        ROW_FLAG[\"_isScheduled: boolean\"]\n        \n        ROW --> ROW_ID\n        ROW --> ROW_OPEN\n        ROW --> ROW_EXCHANGE\n        ROW --> ROW_STRATEGY\n        ROW --> ROW_SYMBOL\n        ROW --> ROW_SCHEDULED\n        ROW --> ROW_PENDING\n        ROW --> ROW_FLAG\n    end\n    \n    subgraph \"Scheduled Variant\"\n        SCHEDULED[\"IScheduledSignalRow\"]\n        SCHEDULED_EXTENDS[\"extends ISignalRow\"]\n        SCHEDULED_OPEN[\"priceOpen: number (entry price)\"]\n        SCHEDULED_FLAG[\"_isScheduled: true\"]\n        \n        SCHEDULED --> SCHEDULED_EXTENDS\n        SCHEDULED --> SCHEDULED_OPEN\n        SCHEDULED --> SCHEDULED_FLAG\n    end\n    \n    DTO -.->|\"validated + augmented\"| ROW\n    ROW -.->|\"if priceOpen specified\"| SCHEDULED\n```\n\n**Sources**: [src/interfaces/Strategy.interface.ts:20-73](), [types.d.ts:856-906]()\n\n### Signal State Machine\n\n```mermaid\nstateDiagram-v2\n    [*] --> Idle: No active signal\n    \n    Idle --> Scheduled: getSignal() returns<br/>signal with priceOpen\n    Idle --> Opened: getSignal() returns<br/>signal without priceOpen\n    \n    Scheduled --> Active: Price reaches priceOpen<br/>(activation)\n    Scheduled --> Cancelled: Timeout (CC_SCHEDULE_AWAIT_MINUTES)<br/>or SL hit before activation\n    Scheduled --> Scheduled: Monitoring (active state)\n    \n    Opened --> Active: Signal persisted<br/>and risk checked\n    \n    Active --> Closed_TP: Price >= priceTakeProfit (long)<br/>Price <= priceTakeProfit (short)\n    Active --> Closed_SL: Price <= priceStopLoss (long)<br/>Price >= priceStopLoss (short)\n    Active --> Closed_Time: minuteEstimatedTime expired\n    Active --> Active: Monitoring (idle state)\n    \n    Closed_TP --> Idle: PnL calculated\n    Closed_SL --> Idle: PnL calculated\n    Closed_Time --> Idle: PnL calculated\n    Cancelled --> Idle: No position opened\n```\n\n**Key Transitions**:\n\n1. **Idle → Scheduled**: `priceOpen` specified in `ISignalDto`\n2. **Idle → Opened**: `priceOpen` omitted (uses current VWAP)\n3. **Scheduled → Active**: Price crosses `priceOpen` (long: price ≤ priceOpen, short: price ≥ priceOpen)\n4. **Scheduled → Cancelled**: Timeout or SL hit before activation\n5. **Opened → Active**: Signal validated and persisted\n6. **Active → Closed**: TP/SL/Time condition met\n\n**Sources**: [src/client/ClientStrategy.ts:554-608](), [src/client/ClientStrategy.ts:610-644](), [src/client/ClientStrategy.ts:848-931]()\n\n### Timestamp Semantics\n\n| Field | Meaning | Set When |\n|-------|---------|----------|\n| `scheduledAt` | Signal creation time | `getSignal()` returns non-null |\n| `pendingAt` | Position entry time | Scheduled: activation time<br/>Immediate: same as `scheduledAt` |\n\nFor scheduled signals, `pendingAt` is initially set to `scheduledAt` but updated to the activation timestamp when price reaches `priceOpen`.\n\n**Sources**: [src/interfaces/Strategy.interface.ts:54-57](), [src/client/ClientStrategy.ts:734-738]()\n\n---\n\n## Strategy Execution Flow\n\n### Execution Methods\n\nClientStrategy provides two execution methods:\n\n| Method | Mode | Returns | Use Case |\n|--------|------|---------|----------|\n| `tick()` | Live/Backtest | `IStrategyTickResult` | Single tick with VWAP monitoring |\n| `backtest()` | Backtest only | `IStrategyBacktestResult` | Fast candle-by-candle processing |\n\n**Sources**: [src/interfaces/Strategy.interface.ts:318-388](), [src/client/ClientStrategy.ts:932-1069]()\n\n### tick() Execution Flow\n\n```mermaid\ngraph TB\n    START[\"tick(symbol, strategyName)\"]\n    CHECK_SCHEDULED{\"Has<br/>scheduledSignal?\"}\n    CHECK_PENDING{\"Has<br/>pendingSignal?\"}\n    CHECK_INTERVAL{\"Interval<br/>elapsed?\"}\n    GET_SIGNAL[\"Call getSignal()\"]\n    RISK_CHECK{\"Risk<br/>check<br/>passes?\"}\n    CREATE_SIGNAL[\"Create ISignalRow\"]\n    PERSIST_SIGNAL[\"Persist to disk\"]\n    MONITOR_TP{\"TP/SL/Time<br/>condition<br/>met?\"}\n    CLOSE_SIGNAL[\"Close signal<br/>Calculate PnL\"]\n    RETURN_IDLE[\"Return idle\"]\n    RETURN_SCHEDULED[\"Return scheduled\"]\n    RETURN_OPENED[\"Return opened\"]\n    RETURN_ACTIVE[\"Return active\"]\n    RETURN_CLOSED[\"Return closed\"]\n    \n    START --> CHECK_SCHEDULED\n    CHECK_SCHEDULED -->|Yes| MONITOR_SCHEDULED[\"Monitor activation<br/>Check timeout<br/>Check SL\"]\n    MONITOR_SCHEDULED --> CHECK_ACTIVATION{\"Price<br/>reached<br/>priceOpen?\"}\n    CHECK_ACTIVATION -->|Yes| ACTIVATE[\"Activate signal<br/>Update pendingAt\"]\n    CHECK_ACTIVATION -->|No| CHECK_TIMEOUT{\"Timeout<br/>or SL<br/>hit?\"}\n    CHECK_TIMEOUT -->|Yes| CANCEL[\"Cancel scheduled\"]\n    CHECK_TIMEOUT -->|No| RETURN_SCHEDULED\n    CANCEL --> RETURN_IDLE\n    ACTIVATE --> RETURN_OPENED\n    \n    CHECK_SCHEDULED -->|No| CHECK_PENDING\n    CHECK_PENDING -->|Yes| MONITOR_TP\n    MONITOR_TP -->|Yes| CLOSE_SIGNAL\n    MONITOR_TP -->|No| RETURN_ACTIVE\n    CLOSE_SIGNAL --> RETURN_CLOSED\n    \n    CHECK_PENDING -->|No| CHECK_INTERVAL\n    CHECK_INTERVAL -->|Yes| GET_SIGNAL\n    CHECK_INTERVAL -->|No| RETURN_IDLE\n    GET_SIGNAL --> RISK_CHECK\n    RISK_CHECK -->|No| RETURN_IDLE\n    RISK_CHECK -->|Yes| CREATE_SIGNAL\n    CREATE_SIGNAL --> PERSIST_SIGNAL\n    PERSIST_SIGNAL --> RETURN_OPENED\n```\n\n**Key Steps**:\n\n1. **Scheduled Signal Monitoring**: Check for activation, timeout, or cancellation\n2. **Pending Signal Monitoring**: Check TP/SL/Time conditions\n3. **Idle State**: Check interval throttling, call `getSignal()`, validate risk\n4. **Signal Creation**: Generate UUID, augment with context, persist to disk\n5. **Result Emission**: Emit to `signalEmitter`, `signalBacktestEmitter`, or `signalLiveEmitter`\n\n**Sources**: [src/client/ClientStrategy.ts:932-1019](), [src/lib/services/connection/StrategyConnectionService.ts:207-228]()\n\n### backtest() Fast Processing\n\nThe `backtest()` method optimizes historical simulation by skipping to signal close timestamps:\n\n```mermaid\ngraph TB\n    START[\"backtest(candles[])\"]\n    CALL_TICK[\"Call tick()\"]\n    CHECK_RESULT{\"Result<br/>action?\"}\n    OPENED[\"opened\"]\n    SCHEDULED[\"scheduled\"]\n    \n    START --> CALL_TICK\n    CALL_TICK --> CHECK_RESULT\n    CHECK_RESULT -->|idle| RETURN_IDLE[\"Return idle<br/>(no signal)\"]\n    CHECK_RESULT -->|opened| OPENED\n    CHECK_RESULT -->|scheduled| SCHEDULED\n    \n    OPENED --> FAST_LOOP[\"Fast candle loop\"]\n    SCHEDULED --> MONITOR_ACTIVATION[\"Monitor activation\"]\n    MONITOR_ACTIVATION --> CHECK_ACTIVATED{\"Activated<br/>or cancelled?\"}\n    CHECK_ACTIVATED -->|Cancelled| RETURN_CANCELLED[\"Return cancelled\"]\n    CHECK_ACTIVATED -->|Activated| FAST_LOOP\n    \n    FAST_LOOP --> ITERATE[\"For each candle:\"]\n    ITERATE --> GET_AVG[\"Calculate VWAP<br/>(high+low+close)/3\"]\n    GET_AVG --> CHECK_TP_SL{\"TP/SL<br/>hit?\"}\n    CHECK_TP_SL -->|Yes| CLOSE[\"Close signal<br/>Calculate PnL\"]\n    CHECK_TP_SL -->|No| CHECK_TIME{\"Time<br/>expired?\"}\n    CHECK_TIME -->|Yes| CLOSE\n    CHECK_TIME -->|No| ITERATE\n    CLOSE --> RETURN_CLOSED[\"Return closed\"]\n```\n\n**Optimization**: Skip directly to `closeTimestamp` instead of processing every intermediate timeframe.\n\n**Sources**: [src/client/ClientStrategy.ts:1021-1158]()\n\n---\n\n## Risk Management Integration\n\n### Risk Profile Assignment\n\nStrategies integrate risk management through two properties:\n\n| Property | Type | Behavior |\n|----------|------|----------|\n| `riskName` | `RiskName` | Single risk profile |\n| `riskList` | `RiskName[]` | Multiple risk profiles (combined) |\n\n**Combination Logic** (from `GET_RISK_FN`):\n\n```mermaid\ngraph TB\n    START{\"Check<br/>riskName &<br/>riskList\"}\n    NO_RISK[\"NOOP_RISK<br/>(always allows)\"]\n    SINGLE[\"Single IRisk<br/>from riskName\"]\n    LIST[\"MergeRisk<br/>(riskList)\"]\n    COMBINED[\"MergeRisk<br/>([riskName, ...riskList])\"]\n    \n    START -->|\"Neither\"| NO_RISK\n    START -->|\"Only riskName\"| SINGLE\n    START -->|\"Only riskList\"| LIST\n    START -->|\"Both\"| COMBINED\n```\n\n**Sources**: [src/lib/services/connection/StrategyConnectionService.ts:27-67](), [src/classes/Risk.ts:1-100]()\n\n### Risk Check Flow\n\n```mermaid\nsequenceDiagram\n    participant CS as ClientStrategy\n    participant GS as GET_SIGNAL_FN\n    participant RC as IRisk.checkSignal\n    participant V as Validations[]\n    participant CB as Callbacks\n    \n    CS->>GS: Call getSignal()\n    GS->>CS: Return ISignalDto\n    CS->>RC: checkSignal(IRiskCheckArgs)\n    \n    loop For each validation\n        RC->>V: validate(payload)\n        alt Validation throws\n            V-->>RC: Error\n            RC->>CB: onRejected()\n            RC-->>CS: false\n        else Validation passes\n            V-->>RC: void\n        end\n    end\n    \n    RC->>CB: onAllowed()\n    RC-->>CS: true\n    CS->>CS: Create ISignalRow\n```\n\n**IRiskCheckArgs Payload**:\n\n```typescript\n{\n  symbol: string,\n  pendingSignal: ISignalDto,\n  strategyName: StrategyName,\n  exchangeName: ExchangeName,\n  currentPrice: number,\n  timestamp: number\n}\n```\n\n**Sources**: [src/interfaces/Risk.interface.ts:547-564](), [src/client/ClientStrategy.ts:375-387](), [test/e2e/risk.test.mjs:1-700]()\n\n---\n\n## Signal Validation Rules\n\n### Built-in Validation (VALIDATE_SIGNAL_FN)\n\nClientStrategy enforces comprehensive validation before signal creation:\n\n| Category | Rule | Long | Short |\n|----------|------|------|-------|\n| **Price Logic** | TP direction | TP > priceOpen | TP < priceOpen |\n| | SL direction | SL < priceOpen | SL > priceOpen |\n| **Distance Checks** | Min TP distance | `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT` | Same |\n| | Min SL distance | `CC_MIN_STOPLOSS_DISTANCE_PERCENT` | Same |\n| | Max SL distance | `CC_MAX_STOPLOSS_DISTANCE_PERCENT` | Same |\n| **Time Limits** | Max lifetime | `CC_MAX_SIGNAL_LIFETIME_MINUTES` | Same |\n| **Immediate Close Prevention** | SL not hit | currentPrice > SL | currentPrice < SL |\n| | TP not hit | currentPrice < TP | currentPrice > TP |\n\n**Sources**: [src/client/ClientStrategy.ts:45-330](), [types.d.ts:5-115]()\n\n### Global Configuration Parameters\n\n| Parameter | Default | Purpose |\n|-----------|---------|---------|\n| `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT` | 0.5% | Ensure TP covers fees + slippage |\n| `CC_MIN_STOPLOSS_DISTANCE_PERCENT` | 0.5% | Prevent instant stop-out on volatility |\n| `CC_MAX_STOPLOSS_DISTANCE_PERCENT` | 20% | Limit catastrophic losses |\n| `CC_MAX_SIGNAL_LIFETIME_MINUTES` | 1440 (1 day) | Prevent eternal signals blocking risk limits |\n| `CC_PERCENT_SLIPPAGE` | 0.1% | Slippage per transaction |\n| `CC_PERCENT_FEE` | 0.1% | Fee per transaction |\n\n**Economic Viability Check**:\n\n```\nMinimum TP Distance = (slippage × 2) + (fees × 2) + buffer\n                    = (0.1% × 2) + (0.1% × 2) + 0.1%\n                    = 0.5%\n```\n\n**Sources**: [types.d.ts:5-115](), [src/lib/services/validation/ConfigValidationService.ts:1-100]()\n\n### Validation Error Examples\n\n```typescript\n// ❌ TP too close (covers fees + slippage)\n{\n  position: \"long\",\n  priceOpen: 42000,\n  priceTakeProfit: 42100,  // Only 0.24% - fails\n  priceStopLoss: 41000,\n  minuteEstimatedTime: 60\n}\n\n// ❌ SL in wrong direction\n{\n  position: \"long\",\n  priceOpen: 42000,\n  priceTakeProfit: 43000,\n  priceStopLoss: 43500,  // SL > priceOpen for long - fails\n  minuteEstimatedTime: 60\n}\n\n// ❌ Immediate close (already hit TP)\n{\n  position: \"long\",\n  priceOpen: 42000,\n  priceTakeProfit: 41500,  // currentPrice=42000 already > TP - fails\n  priceStopLoss: 41000,\n  minuteEstimatedTime: 60\n}\n```\n\n**Sources**: [src/client/ClientStrategy.ts:111-291](), [test/e2e/defend.test.mjs:1-800]()\n\n---\n\n## Lifecycle Callbacks and Events\n\n### IStrategyCallbacks Interface\n\nStrategies can register lifecycle hooks via the `callbacks` property:\n\n| Callback | Trigger | Parameters |\n|----------|---------|------------|\n| `onTick` | Every tick (all results) | `(symbol, result, backtest)` |\n| `onIdle` | No active signal | `(symbol, currentPrice, backtest)` |\n| `onSchedule` | Scheduled signal created | `(symbol, data, currentPrice, backtest)` |\n| `onOpen` | Signal activated/opened | `(symbol, data, currentPrice, backtest)` |\n| `onActive` | Signal being monitored | `(symbol, data, currentPrice, backtest)` |\n| `onClose` | Signal closed (TP/SL/Time) | `(symbol, data, priceClose, backtest)` |\n| `onCancel` | Scheduled signal cancelled | `(symbol, data, currentPrice, backtest)` |\n| `onPartialProfit` | Profit milestone reached | `(symbol, data, currentPrice, revenuePercent, backtest)` |\n| `onPartialLoss` | Loss milestone reached | `(symbol, data, currentPrice, lossPercent, backtest)` |\n| `onWrite` | Signal persisted (testing) | `(symbol, data, backtest)` |\n\n**Sources**: [src/interfaces/Strategy.interface.ts:96-126](), [types.d.ts:910-931]()\n\n### Event Emission Flow\n\n```mermaid\ngraph TB\n    subgraph \"ClientStrategy Callbacks\"\n        CB_SCHEDULE[\"callbacks.onSchedule\"]\n        CB_OPEN[\"callbacks.onOpen\"]\n        CB_ACTIVE[\"callbacks.onActive\"]\n        CB_CLOSE[\"callbacks.onClose\"]\n        CB_TICK[\"callbacks.onTick\"]\n    end\n    \n    subgraph \"StrategyConnectionService\"\n        SCS_TICK[\"tick() / backtest()\"]\n        EMIT_LOGIC{\"backtest<br/>mode?\"}\n    end\n    \n    subgraph \"Global Emitters\"\n        SIGNAL_ALL[\"signalEmitter\"]\n        SIGNAL_BT[\"signalBacktestEmitter\"]\n        SIGNAL_LV[\"signalLiveEmitter\"]\n    end\n    \n    subgraph \"Public Listeners\"\n        LISTEN_ALL[\"listenSignal()\"]\n        LISTEN_BT[\"listenSignalBacktest()\"]\n        LISTEN_LV[\"listenSignalLive()\"]\n    end\n    \n    CB_SCHEDULE -.->|\"User code\"| CB_TICK\n    CB_OPEN -.->|\"User code\"| CB_TICK\n    CB_ACTIVE -.->|\"User code\"| CB_TICK\n    CB_CLOSE -.->|\"User code\"| CB_TICK\n    \n    CB_TICK --> SCS_TICK\n    SCS_TICK --> EMIT_LOGIC\n    EMIT_LOGIC -->|\"true\"| SIGNAL_BT\n    EMIT_LOGIC -->|\"false\"| SIGNAL_LV\n    EMIT_LOGIC --> SIGNAL_ALL\n    \n    SIGNAL_ALL --> LISTEN_ALL\n    SIGNAL_BT --> LISTEN_BT\n    SIGNAL_LV --> LISTEN_LV\n```\n\n**Sources**: [src/lib/services/connection/StrategyConnectionService.ts:217-227](), [src/config/emitters.ts:1-133]()\n\n### Callback Usage Example\n\n```typescript\naddStrategy({\n  strategyName: \"monitored-strategy\",\n  interval: \"5m\",\n  getSignal: async (symbol, when) => {\n    // Signal generation logic\n    return signal;\n  },\n  callbacks: {\n    onOpen: (symbol, data, currentPrice, backtest) => {\n      console.log(`[${backtest ? 'BT' : 'LIVE'}] Signal opened: ${data.id}`);\n      console.log(`  Position: ${data.position}`);\n      console.log(`  Entry: ${data.priceOpen}`);\n      console.log(`  TP: ${data.priceTakeProfit}, SL: ${data.priceStopLoss}`);\n    },\n    \n    onActive: (symbol, data, currentPrice, backtest) => {\n      console.log(`[${backtest ? 'BT' : 'LIVE'}] Monitoring: ${data.id}`);\n      console.log(`  Current: ${currentPrice}`);\n    },\n    \n    onPartialProfit: (symbol, data, currentPrice, revenuePercent, backtest) => {\n      console.log(`[${backtest ? 'BT' : 'LIVE'}] Profit milestone: ${revenuePercent.toFixed(1)}%`);\n    },\n    \n    onClose: (symbol, data, priceClose, backtest) => {\n      console.log(`[${backtest ? 'BT' : 'LIVE'}] Signal closed: ${data.id}`);\n      console.log(`  Close price: ${priceClose}`);\n    }\n  }\n});\n```\n\n**Sources**: [README.md:106-138](), [test/spec/callbacks.test.mjs:1-500]()\n\n---\n\n## Implementation Details\n\n### StrategyConnectionService\n\nThe connection layer routes strategy operations to memoized `ClientStrategy` instances:\n\n```mermaid\ngraph TB\n    subgraph \"StrategyConnectionService\"\n        GET_STRATEGY[\"getStrategy(symbol, strategyName)\"]\n        MEMOIZE_KEY[\"Key: symbol:strategyName\"]\n        CACHE[\"Map<string, ClientStrategy>\"]\n    end\n    \n    subgraph \"ClientStrategy Instance\"\n        CONSTRUCTOR[\"new ClientStrategy(IStrategyParams)\"]\n        WAIT_INIT[\"waitForInit()\"]\n        TICK_METHOD[\"tick()\"]\n        BACKTEST_METHOD[\"backtest()\"]\n        STOP_METHOD[\"stop()\"]\n    end\n    \n    subgraph \"Dependencies\"\n        SCHEMA[\"StrategySchemaService.get()\"]\n        EXCHANGE[\"ExchangeConnectionService\"]\n        RISK[\"RiskConnectionService\"]\n        PARTIAL[\"PartialConnectionService\"]\n        EXECUTION[\"ExecutionContextService\"]\n        METHOD[\"MethodContextService\"]\n    end\n    \n    GET_STRATEGY --> MEMOIZE_KEY\n    MEMOIZE_KEY --> CACHE\n    CACHE -.->|\"Cache miss\"| CONSTRUCTOR\n    CACHE -.->|\"Cache hit\"| TICK_METHOD\n    \n    CONSTRUCTOR --> SCHEMA\n    CONSTRUCTOR --> EXCHANGE\n    CONSTRUCTOR --> RISK\n    CONSTRUCTOR --> PARTIAL\n    CONSTRUCTOR --> EXECUTION\n    CONSTRUCTOR --> METHOD\n    \n    CONSTRUCTOR --> WAIT_INIT\n    WAIT_INIT --> TICK_METHOD\n    WAIT_INIT --> BACKTEST_METHOD\n```\n\n**Memoization Key**: `${symbol}:${strategyName}` (e.g., `\"BTCUSDT:momentum-scalper\"`)\n\n**Cache Clearing**: Use `clear()` method to force re-initialization or release resources.\n\n**Sources**: [src/lib/services/connection/StrategyConnectionService.ts:89-306]()\n\n### ClientStrategy Internal State\n\n| Field | Type | Purpose |\n|-------|------|---------|\n| `_pendingSignal` | `ISignalRow \\| null` | Currently active position (monitoring TP/SL) |\n| `_scheduledSignal` | `IScheduledSignalRow \\| null` | Scheduled signal awaiting activation |\n| `_lastSignalTimestamp` | `number \\| null` | Last `getSignal()` call time (for throttling) |\n| `_isStopped` | `boolean` | Stop flag (prevents new signals) |\n\n**State Transitions**:\n\n1. **Idle**: Both `_pendingSignal` and `_scheduledSignal` are `null`\n2. **Scheduled**: `_scheduledSignal` is set, `_pendingSignal` is `null`\n3. **Active**: `_pendingSignal` is set, `_scheduledSignal` is `null`\n\n**Sources**: [src/client/ClientStrategy.ts:1-50]()\n\n### Persistence and Recovery\n\nClientStrategy integrates with `PersistSignalAdapter` and `PersistScheduleAdapter` for crash-safe state recovery:\n\n```mermaid\nsequenceDiagram\n    participant LV as Live.run()\n    participant CS as ClientStrategy\n    participant PSA as PersistSignalAdapter\n    participant PSch as PersistScheduleAdapter\n    \n    LV->>CS: waitForInit()\n    CS->>PSA: readSignalData(symbol, strategyName)\n    PSA-->>CS: ISignalRow | null\n    alt Pending signal exists\n        CS->>CS: _pendingSignal = restored\n        CS->>CS: callbacks.onActive()\n    end\n    \n    CS->>PSch: readScheduleData(symbol, strategyName)\n    PSch-->>CS: IScheduledSignalRow | null\n    alt Scheduled signal exists\n        CS->>CS: _scheduledSignal = restored\n        CS->>CS: callbacks.onSchedule()\n    end\n    \n    Note over CS: Ready for tick()\n```\n\n**File Paths**:\n- Pending: `./dump/signal_${symbol}_${strategyName}.json`\n- Scheduled: `./dump/schedule_${symbol}_${strategyName}.json`\n\n**Atomic Writes**: Uses `singleshot()` pattern to prevent write race conditions.\n\n**Sources**: [src/client/ClientStrategy.ts:491-552](), [src/classes/Persist.ts:1-500]()\n\n---\n\n## Summary\n\nThe Strategy System provides a complete framework for defining, validating, executing, and monitoring trading strategies:\n\n1. **Registration**: `addStrategy()` with `IStrategySchema` defines signal generation logic\n2. **Throttling**: `SignalInterval` prevents excessive `getSignal()` calls\n3. **Validation**: Comprehensive checks for TP/SL logic, distances, and economic viability\n4. **Risk Integration**: `riskName`/`riskList` combine risk profiles via `MergeRisk`\n5. **Lifecycle**: State machine (idle → scheduled → active → closed) with callbacks\n6. **Execution**: `tick()` for live monitoring, `backtest()` for fast historical simulation\n7. **Persistence**: Crash-safe state recovery via `PersistSignalAdapter` and `PersistScheduleAdapter`\n8. **Events**: Global emitters (`signalEmitter`, `signalBacktestEmitter`, `signalLiveEmitter`) for monitoring\n\nFor execution mode details, see Backtest Mode ([#5.1](#5.1)), Live Trading Mode ([#5.2](#5.2)), and Walker Mode ([#5.3](#5.3)).\n\n**Sources**: [src/client/ClientStrategy.ts:1-1158](), [src/lib/services/connection/StrategyConnectionService.ts:1-309](), [src/interfaces/Strategy.interface.ts:1-394]()"
                    },
                    {
                        "page_plan": {
                            "id": "4.1",
                            "title": "Defining Strategies"
                        },
                        "content": "# Defining Strategies\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [docs/classes/StrategyConnectionService.md](docs/classes/StrategyConnectionService.md)\n- [docs/index.md](docs/index.md)\n- [docs/interfaces/IStrategy.md](docs/interfaces/IStrategy.md)\n- [docs/interfaces/IStrategySchema.md](docs/interfaces/IStrategySchema.md)\n- [docs/types/IStrategyBacktestResult.md](docs/types/IStrategyBacktestResult.md)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/add.ts](src/function/add.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/function/list.ts](src/function/list.ts)\n- [src/index.ts](src/index.ts)\n- [src/lib/core/provide.ts](src/lib/core/provide.ts)\n- [src/lib/core/types.ts](src/lib/core/types.ts)\n- [src/lib/index.ts](src/lib/index.ts)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\nThis page documents how to define and register trading strategies in the framework. It covers the `IStrategySchema` structure, the `addStrategy()` registration function, the `getSignal` callback for signal generation, interval-based throttling, and lifecycle callbacks for strategy events.\n\nFor information about how strategies are executed internally, see [Strategy Execution Flow](#4.2). For risk management integration, see [Risk Management](#4.3). For position sizing integration, see [Position Sizing](#4.4).\n\n---\n\n## Strategy Schema Structure\n\nStrategies are defined using the `IStrategySchema` interface, which specifies all configuration and behavior for a trading strategy. The schema is registered via `addStrategy()` and validated by `StrategyValidationService` before being stored in `StrategySchemaService`.\n\n```mermaid\ngraph TB\n    subgraph IStrategySchema[\"IStrategySchema Structure\"]\n        STRATEGY_NAME[\"strategyName: StrategyName<br/>(string - unique identifier)\"]\n        NOTE[\"note?: string<br/>(optional documentation)\"]\n        INTERVAL[\"interval: SignalInterval<br/>('1m' | '3m' | '5m' | '15m' | '30m' | '1h')\"]\n        GET_SIGNAL[\"getSignal: (symbol, when) => Promise<ISignalDto | null><br/>(signal generation function)\"]\n        CALLBACKS[\"callbacks?: Partial<IStrategyCallbacks><br/>(lifecycle event hooks)\"]\n        RISK_NAME[\"riskName?: RiskName<br/>(single risk profile)\"]\n        RISK_LIST[\"riskList?: RiskName[]<br/>(multiple risk profiles)\"]\n    end\n    \n    subgraph ISignalDto[\"ISignalDto - Return Value of getSignal\"]\n        ID[\"id?: string<br/>(auto-generated if omitted)\"]\n        POSITION[\"position: 'long' | 'short'<br/>(trade direction)\"]\n        NOTE_SIGNAL[\"note?: string<br/>(human-readable reason)\"]\n        PRICE_OPEN[\"priceOpen?: number<br/>(scheduled entry price)\"]\n        PRICE_TP[\"priceTakeProfit: number<br/>(profit target)\"]\n        PRICE_SL[\"priceStopLoss: number<br/>(loss limit)\"]\n        MINUTE_EST[\"minuteEstimatedTime: number<br/>(expected duration)\"]\n    end\n    \n    subgraph IStrategyCallbacks[\"IStrategyCallbacks - Event Hooks\"]\n        ON_TICK[\"onTick(symbol, result, backtest)\"]\n        ON_OPEN[\"onOpen(symbol, data, currentPrice, backtest)\"]\n        ON_ACTIVE[\"onActive(symbol, data, currentPrice, backtest)\"]\n        ON_IDLE[\"onIdle(symbol, currentPrice, backtest)\"]\n        ON_CLOSE[\"onClose(symbol, data, priceClose, backtest)\"]\n        ON_SCHEDULE[\"onSchedule(symbol, data, currentPrice, backtest)\"]\n        ON_CANCEL[\"onCancel(symbol, data, currentPrice, backtest)\"]\n        ON_WRITE[\"onWrite(symbol, data, backtest)\"]\n        ON_PARTIAL_PROFIT[\"onPartialProfit(symbol, data, currentPrice, revenuePercent, backtest)\"]\n        ON_PARTIAL_LOSS[\"onPartialLoss(symbol, data, currentPrice, lossPercent, backtest)\"]\n    end\n    \n    GET_SIGNAL --> ISignalDto\n    CALLBACKS --> IStrategyCallbacks\n```\n\n**Sources:** [types.d.ts:936-955](), [types.d.ts:855-873](), [types.d.ts:909-931]()\n\n---\n\n## Strategy Registration Flow\n\nStrategies are registered using the `addStrategy()` function, which validates the schema and stores it in the dependency injection container. The registration process ensures that strategy names are unique and all required fields are present.\n\n```mermaid\ngraph TB\n    USER[\"User Code:<br/>addStrategy(schema)\"]\n    ADD_FN[\"add.addStrategy<br/>[src/function/add.ts:52-64]\"]\n    LOG[\"LoggerService.info<br/>'add.addStrategy'\"]\n    VAL_SERVICE[\"StrategyValidationService<br/>.addStrategy()\"]\n    VAL_CHECKS[\"Validation Checks:<br/>- Unique strategyName<br/>- Valid interval<br/>- getSignal is function<br/>- Callbacks structure\"]\n    SCHEMA_SERVICE[\"StrategySchemaService<br/>.register()\"]\n    STORAGE[\"Stored in _registrations Map<br/>Key: strategyName<br/>Value: IStrategySchema\"]\n    \n    USER --> ADD_FN\n    ADD_FN --> LOG\n    ADD_FN --> VAL_SERVICE\n    VAL_SERVICE --> VAL_CHECKS\n    VAL_CHECKS -->|Valid| SCHEMA_SERVICE\n    VAL_CHECKS -->|Invalid| ERROR[\"Throw Error\"]\n    SCHEMA_SERVICE --> STORAGE\n```\n\n**Sources:** [src/function/add.ts:52-64](), [src/lib/services/validation/StrategyValidationService.ts](), [src/lib/services/schema/StrategySchemaService.ts]()\n\n### Registration Example\n\n```typescript\nimport { addStrategy } from \"backtest-kit\";\n\naddStrategy({\n  strategyName: \"momentum-breakout\",\n  note: \"Enters on momentum breakout with volume confirmation\",\n  interval: \"5m\",\n  getSignal: async (symbol: string, when: Date) => {\n    // Signal generation logic\n    const shouldEnter = await checkBreakoutConditions(symbol, when);\n    \n    if (!shouldEnter) {\n      return null; // No signal\n    }\n    \n    return {\n      position: \"long\",\n      priceOpen: 50000, // Optional - creates scheduled signal\n      priceTakeProfit: 52000,\n      priceStopLoss: 48500,\n      minuteEstimatedTime: 120,\n      note: \"Volume breakout confirmed\",\n    };\n  },\n  riskName: \"conservative\", // Optional risk profile\n  callbacks: {\n    onOpen: (symbol, signal, currentPrice, backtest) => {\n      console.log(`Signal opened: ${signal.id}`);\n    },\n    onClose: (symbol, signal, priceClose, backtest) => {\n      console.log(`Signal closed at ${priceClose}`);\n    },\n  },\n});\n```\n\n**Sources:** [src/function/add.ts:18-64](), [types.d.ts:936-955]()\n\n---\n\n## Signal Generation Callback\n\nThe `getSignal` callback is the core of strategy logic. It is called by `ClientStrategy.tick()` when the interval throttling allows, and must return either a signal DTO or `null` if no signal should be generated.\n\n### getSignal Function Signature\n\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| `symbol` | `string` | Trading pair symbol (e.g., \"BTCUSDT\") |\n| `when` | `Date` | Current timestamp for signal generation |\n| **Returns** | `Promise<ISignalDto \\| null>` | Signal DTO if conditions met, `null` otherwise |\n\n```mermaid\ngraph TB\n    TICK[\"ClientStrategy.tick()\"]\n    CHECK_INTERVAL[\"Check interval throttle<br/>(lastSignalTime + interval)\"]\n    SKIP[\"Skip getSignal call<br/>Return idle or active result\"]\n    CALL_GET_SIGNAL[\"Call getSignal(symbol, when)\"]\n    RETURNS_NULL[\"Returns null\"]\n    RETURNS_DTO[\"Returns ISignalDto\"]\n    IDLE[\"Continue monitoring<br/>existing signal or idle\"]\n    VALIDATE[\"Validate ISignalDto:<br/>- TP/SL distances<br/>- Price logic<br/>- Time values\"]\n    CHECK_RISK[\"Risk check via<br/>ClientRisk.checkSignal()\"]\n    REJECTED[\"Signal rejected<br/>Emit riskSubject\"]\n    CREATE_SIGNAL[\"Create ISignalRow<br/>(add id, metadata)\"]\n    SCHEDULE_OR_OPEN[\"priceOpen present?\"]\n    SCHEDULED[\"Scheduled Signal:<br/>onSchedule callback<br/>Wait for price activation\"]\n    OPENED[\"Immediate Signal:<br/>onOpen callback<br/>Start TP/SL monitoring\"]\n    \n    TICK --> CHECK_INTERVAL\n    CHECK_INTERVAL -->|Too soon| SKIP\n    CHECK_INTERVAL -->|Allowed| CALL_GET_SIGNAL\n    CALL_GET_SIGNAL --> RETURNS_NULL\n    CALL_GET_SIGNAL --> RETURNS_DTO\n    RETURNS_NULL --> IDLE\n    RETURNS_DTO --> VALIDATE\n    VALIDATE -->|Invalid| ERROR[\"Throw Error\"]\n    VALIDATE -->|Valid| CHECK_RISK\n    CHECK_RISK -->|Rejected| REJECTED\n    CHECK_RISK -->|Allowed| CREATE_SIGNAL\n    CREATE_SIGNAL --> SCHEDULE_OR_OPEN\n    SCHEDULE_OR_OPEN -->|Yes| SCHEDULED\n    SCHEDULE_OR_OPEN -->|No| OPENED\n```\n\n**Sources:** [src/lib/client/ClientStrategy.ts](), [types.d.ts:948]()\n\n### Signal Validation Rules\n\nWhen `getSignal` returns a signal DTO, the framework validates:\n\n| Rule | Description | Configuration |\n|------|-------------|---------------|\n| **TP Distance** | `priceTakeProfit` must be > `priceOpen` for long, < `priceOpen` for short | `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT` |\n| **SL Distance** | `priceStopLoss` must be < `priceOpen` for long, > `priceOpen` for short | `CC_MIN_STOPLOSS_DISTANCE_PERCENT`, `CC_MAX_STOPLOSS_DISTANCE_PERCENT` |\n| **Economic Viability** | TP distance must cover slippage + fees + minimum profit | Calculated by `ConfigValidationService` |\n| **Time Constraints** | `minuteEstimatedTime` must be > 0 and < `CC_MAX_SIGNAL_LIFETIME_MINUTES` | Default: 1440 minutes (1 day) |\n\n**Sources:** [types.d.ts:5-115](), [src/lib/services/validation/ConfigValidationService.ts]()\n\n---\n\n## Interval Throttling\n\nThe `interval` property controls the minimum time between `getSignal` invocations. This prevents signal spam and reduces computational overhead during strategy execution.\n\n### SignalInterval Type\n\n```typescript\ntype SignalInterval = \"1m\" | \"3m\" | \"5m\" | \"15m\" | \"30m\" | \"1h\";\n```\n\n```mermaid\ngraph LR\n    subgraph \"Throttling Mechanism\"\n        T0[\"Time T0:<br/>getSignal() called<br/>lastSignalTime = T0\"]\n        T1[\"Time T0 + 30s:<br/>Interval not elapsed<br/>getSignal() SKIPPED\"]\n        T2[\"Time T0 + 4m:<br/>Interval not elapsed<br/>getSignal() SKIPPED\"]\n        T3[\"Time T0 + 5m:<br/>Interval elapsed<br/>getSignal() CALLED<br/>lastSignalTime = T0 + 5m\"]\n    end\n    \n    T0 --> T1\n    T1 --> T2\n    T2 --> T3\n```\n\n**Interval Behavior:**\n- `ClientStrategy` tracks `_lastSignalTime` for each symbol\n- On each tick, checks if `(currentTime - _lastSignalTime) >= interval`\n- If throttled, skips `getSignal` and returns current signal state (idle/active/closed)\n- If allowed, calls `getSignal` and updates `_lastSignalTime`\n\n**Sources:** [types.d.ts:853](), [src/lib/client/ClientStrategy.ts]()\n\n### Choosing an Interval\n\n| Interval | Use Case | Tick Frequency (Live Mode) |\n|----------|----------|---------------------------|\n| `\"1m\"` | High-frequency strategies, scalping | Every 61 seconds |\n| `\"5m\"` | Medium-frequency, momentum strategies | Every 61 seconds (checks every 5 minutes) |\n| `\"15m\"` | Swing trading, trend following | Every 61 seconds (checks every 15 minutes) |\n| `\"1h\"` | Position trading, low-frequency | Every 61 seconds (checks every hour) |\n\n**Note:** Live mode ticks occur every `TICK_TTL` (61 seconds) regardless of interval. The interval only controls how often `getSignal` is invoked during those ticks.\n\n**Sources:** [src/lib/services/logic/private/LiveLogicPrivateService.ts]()\n\n---\n\n## Lifecycle Callbacks\n\nThe `callbacks` property provides event hooks for monitoring strategy execution. All callbacks are optional and receive consistent parameters.\n\n### Available Callbacks\n\n```mermaid\ngraph TB\n    subgraph \"Lifecycle States\"\n        IDLE[\"idle state\"]\n        SCHEDULED[\"scheduled state\"]\n        OPENED[\"opened state\"]\n        ACTIVE[\"active state\"]\n        CLOSED[\"closed state\"]\n        CANCELLED[\"cancelled state\"]\n    end\n    \n    subgraph \"Callback Invocations\"\n        ON_TICK[\"onTick<br/>(every tick)\"]\n        ON_IDLE[\"onIdle<br/>(no signal)\"]\n        ON_SCHEDULE[\"onSchedule<br/>(signal scheduled)\"]\n        ON_OPEN[\"onOpen<br/>(signal opened)\"]\n        ON_ACTIVE[\"onActive<br/>(signal monitoring)\"]\n        ON_PARTIAL_PROFIT[\"onPartialProfit<br/>(profit milestone)\"]\n        ON_PARTIAL_LOSS[\"onPartialLoss<br/>(loss milestone)\"]\n        ON_CLOSE[\"onClose<br/>(signal completed)\"]\n        ON_CANCEL[\"onCancel<br/>(scheduled cancelled)\"]\n        ON_WRITE[\"onWrite<br/>(state persisted)\"]\n    end\n    \n    IDLE --> ON_TICK\n    IDLE --> ON_IDLE\n    SCHEDULED --> ON_TICK\n    SCHEDULED --> ON_SCHEDULE\n    SCHEDULED --> ON_ACTIVE\n    SCHEDULED --> ON_CANCEL\n    OPENED --> ON_TICK\n    OPENED --> ON_OPEN\n    OPENED --> ON_ACTIVE\n    ACTIVE --> ON_TICK\n    ACTIVE --> ON_ACTIVE\n    ACTIVE --> ON_PARTIAL_PROFIT\n    ACTIVE --> ON_PARTIAL_LOSS\n    ACTIVE --> ON_CLOSE\n    CLOSED --> ON_CLOSE\n    CANCELLED --> ON_CANCEL\n```\n\n**Sources:** [types.d.ts:909-931]()\n\n### Callback Parameters\n\n| Callback | Parameters | When Called |\n|----------|-----------|-------------|\n| `onTick` | `(symbol, result, backtest)` | Every tick, with full tick result |\n| `onOpen` | `(symbol, data, currentPrice, backtest)` | Signal opened at `currentPrice` |\n| `onActive` | `(symbol, data, currentPrice, backtest)` | Signal being monitored (each tick) |\n| `onIdle` | `(symbol, currentPrice, backtest)` | No active signal exists |\n| `onClose` | `(symbol, data, priceClose, backtest)` | Signal closed at `priceClose` |\n| `onSchedule` | `(symbol, data, currentPrice, backtest)` | Scheduled signal created |\n| `onCancel` | `(symbol, data, currentPrice, backtest)` | Scheduled signal cancelled |\n| `onWrite` | `(symbol, data, backtest)` | State persisted to disk (live mode) |\n| `onPartialProfit` | `(symbol, data, currentPrice, revenuePercent, backtest)` | Profit milestone reached (10%, 20%, etc.) |\n| `onPartialLoss` | `(symbol, data, currentPrice, lossPercent, backtest)` | Loss milestone reached (-10%, -20%, etc.) |\n\n**Common Parameters:**\n- `symbol`: Trading pair (e.g., \"BTCUSDT\")\n- `data`: `ISignalRow` with signal details (id, prices, timestamps)\n- `currentPrice`: Current VWAP price from `ClientExchange.getAveragePrice()`\n- `backtest`: `true` for backtest mode, `false` for live mode\n\n**Sources:** [types.d.ts:909-931](), [src/lib/client/ClientStrategy.ts]()\n\n### Callback Example\n\n```typescript\naddStrategy({\n  strategyName: \"monitored-strategy\",\n  interval: \"5m\",\n  getSignal: async (symbol, when) => {\n    // ... signal logic\n  },\n  callbacks: {\n    onTick: (symbol, result, backtest) => {\n      console.log(`[TICK] ${symbol} action=${result.action}`);\n    },\n    \n    onOpen: (symbol, signal, currentPrice, backtest) => {\n      console.log(`[OPEN] ${symbol} signal=${signal.id} price=${currentPrice}`);\n      // Log to external monitoring system\n      logToMonitoring(\"signal_opened\", { symbol, signalId: signal.id, currentPrice });\n    },\n    \n    onActive: (symbol, signal, currentPrice, backtest) => {\n      // Monitor signal progress\n      const pnl = calculatePnL(signal, currentPrice);\n      if (Math.abs(pnl) > 5) {\n        console.log(`[ACTIVE] ${symbol} signal=${signal.id} pnl=${pnl}%`);\n      }\n    },\n    \n    onClose: (symbol, signal, priceClose, backtest) => {\n      const duration = (Date.now() - signal.pendingAt) / 60000;\n      console.log(`[CLOSE] ${symbol} signal=${signal.id} price=${priceClose} duration=${duration}m`);\n      // Update external tracking\n      logToMonitoring(\"signal_closed\", { symbol, signalId: signal.id, priceClose, duration });\n    },\n    \n    onPartialProfit: (symbol, signal, currentPrice, revenuePercent, backtest) => {\n      console.log(`[PROFIT] ${symbol} signal=${signal.id} revenue=${revenuePercent}%`);\n      // Adjust external trailing stops or alerts\n    },\n    \n    onPartialLoss: (symbol, signal, currentPrice, lossPercent, backtest) => {\n      console.log(`[LOSS] ${symbol} signal=${signal.id} loss=${lossPercent}%`);\n      // Send alert if loss exceeds threshold\n      if (Math.abs(lossPercent) > 15) {\n        sendAlert(`High loss detected: ${symbol} at ${lossPercent}%`);\n      }\n    },\n  },\n});\n```\n\n**Sources:** [types.d.ts:909-931]()\n\n---\n\n## Risk Integration\n\nStrategies can integrate with the risk management system by specifying `riskName` or `riskList` in the schema. This enables portfolio-level validation before signals are opened.\n\n### Single Risk Profile\n\n```typescript\naddStrategy({\n  strategyName: \"conservative-trend\",\n  interval: \"15m\",\n  riskName: \"conservative\", // Single risk profile\n  getSignal: async (symbol, when) => {\n    // ... signal logic\n  },\n});\n```\n\n### Multiple Risk Profiles\n\n```typescript\naddStrategy({\n  strategyName: \"multi-check-strategy\",\n  interval: \"5m\",\n  riskList: [\"max-positions\", \"drawdown-limit\", \"correlation-check\"], // Multiple risk profiles\n  getSignal: async (symbol, when) => {\n    // ... signal logic\n  },\n});\n```\n\n**Risk Check Flow:**\n1. `getSignal` returns `ISignalDto`\n2. `ClientStrategy` validates signal structure\n3. If `riskName` or `riskList` present, calls `ClientRisk.checkSignal()`\n4. `ClientRisk` runs all validations from specified risk profiles\n5. If any validation throws, signal is rejected and `riskSubject` emits event\n6. If all validations pass, signal proceeds to opened/scheduled state\n\n**Sources:** [types.d.ts:952-954](), [src/lib/client/ClientStrategy.ts](), [src/lib/client/ClientRisk.ts]()\n\n---\n\n## Signal Types: Immediate vs Scheduled\n\nSignals can be either **immediate** (open at current price) or **scheduled** (wait for price to reach `priceOpen`). This is determined by the presence of the `priceOpen` field in `ISignalDto`.\n\n```mermaid\ngraph TB\n    GET_SIGNAL[\"getSignal returns ISignalDto\"]\n    CHECK_PRICE_OPEN{\"priceOpen<br/>present?\"}\n    IMMEDIATE[\"Immediate Signal:<br/>- Opens at current VWAP<br/>- onOpen callback invoked<br/>- Starts TP/SL monitoring<br/>- State: opened → active\"]\n    SCHEDULED[\"Scheduled Signal:<br/>- Waits for price activation<br/>- onSchedule callback invoked<br/>- Monitors for priceOpen touch<br/>- State: scheduled\"]\n    ACTIVATE[\"Price touches priceOpen:<br/>- Converts to immediate signal<br/>- onOpen callback invoked<br/>- Starts TP/SL monitoring<br/>- State: opened → active\"]\n    CANCEL[\"Timeout or invalidation:<br/>- onCancel callback invoked<br/>- State: cancelled<br/>- No position opened\"]\n    \n    GET_SIGNAL --> CHECK_PRICE_OPEN\n    CHECK_PRICE_OPEN -->|No| IMMEDIATE\n    CHECK_PRICE_OPEN -->|Yes| SCHEDULED\n    SCHEDULED --> ACTIVATE\n    SCHEDULED --> CANCEL\n```\n\n**Sources:** [types.d.ts:855-873](), [src/lib/client/ClientStrategy.ts]()\n\n### Immediate Signal Example\n\n```typescript\ngetSignal: async (symbol, when) => {\n  return {\n    position: \"long\",\n    // priceOpen omitted - opens immediately at current price\n    priceTakeProfit: 52000,\n    priceStopLoss: 48000,\n    minuteEstimatedTime: 120,\n  };\n}\n```\n\n### Scheduled Signal Example\n\n```typescript\ngetSignal: async (symbol, when) => {\n  return {\n    position: \"long\",\n    priceOpen: 50500, // Wait for price to reach 50500\n    priceTakeProfit: 52000,\n    priceStopLoss: 48000,\n    minuteEstimatedTime: 120,\n    note: \"Wait for breakout confirmation at 50500\",\n  };\n}\n```\n\n**Scheduled Signal Behavior:**\n- Signal created in `scheduled` state with `_isScheduled = true`\n- `ClientStrategy.backtest()` monitors each candle for price touching `priceOpen`\n- If long: activation when `candle.low <= priceOpen`\n- If short: activation when `candle.high >= priceOpen`\n- On activation: converts to opened signal, calls `onOpen`, begins TP/SL monitoring\n- If not activated within `CC_SCHEDULE_AWAIT_MINUTES`, calls `onCancel` and removes signal\n\n**Sources:** [types.d.ts:10](), [src/lib/client/ClientStrategy.ts]()\n\n---\n\n## Complete Strategy Definition Example\n\n```typescript\nimport { addStrategy, getCandles, getAveragePrice } from \"backtest-kit\";\n\naddStrategy({\n  // Basic identification\n  strategyName: \"rsi-momentum\",\n  note: \"Enters on RSI oversold with volume confirmation\",\n  \n  // Throttling configuration\n  interval: \"5m\", // Check for signals every 5 minutes\n  \n  // Signal generation logic\n  getSignal: async (symbol: string, when: Date) => {\n    // Fetch historical data\n    const candles = await getCandles(symbol, \"15m\", 50);\n    const currentPrice = await getAveragePrice(symbol);\n    \n    // Calculate indicators\n    const rsi = calculateRSI(candles, 14);\n    const volume = candles[candles.length - 1].volume;\n    const avgVolume = candles.slice(-20).reduce((sum, c) => sum + c.volume, 0) / 20;\n    \n    // Entry conditions\n    const isOversold = rsi < 30;\n    const isVolumeConfirmed = volume > avgVolume * 1.5;\n    \n    if (!isOversold || !isVolumeConfirmed) {\n      return null; // No signal\n    }\n    \n    // Calculate targets\n    const atr = calculateATR(candles, 14);\n    const stopDistance = atr * 2;\n    const profitDistance = atr * 3;\n    \n    return {\n      position: \"long\",\n      // Immediate entry (no priceOpen)\n      priceTakeProfit: currentPrice + profitDistance,\n      priceStopLoss: currentPrice - stopDistance,\n      minuteEstimatedTime: 240, // 4 hours\n      note: `RSI=${rsi.toFixed(2)} Volume=${(volume/avgVolume).toFixed(2)}x`,\n    };\n  },\n  \n  // Risk management integration\n  riskName: \"conservative\",\n  \n  // Lifecycle event monitoring\n  callbacks: {\n    onOpen: (symbol, signal, currentPrice, backtest) => {\n      console.log(`[OPEN] ${symbol} @ ${currentPrice}`);\n      console.log(`  TP: ${signal.priceTakeProfit} (+${((signal.priceTakeProfit/currentPrice - 1) * 100).toFixed(2)}%)`);\n      console.log(`  SL: ${signal.priceStopLoss} (${((signal.priceStopLoss/currentPrice - 1) * 100).toFixed(2)}%)`);\n      \n      if (!backtest) {\n        // Log to external monitoring in live mode\n        logToDatabase({ event: \"signal_opened\", symbol, signal, currentPrice });\n      }\n    },\n    \n    onActive: (symbol, signal, currentPrice, backtest) => {\n      // Monitor progress (called every tick)\n      const pnl = ((currentPrice / signal.priceOpen) - 1) * 100;\n      if (Math.abs(pnl) > 3) {\n        console.log(`[ACTIVE] ${symbol} PNL: ${pnl.toFixed(2)}%`);\n      }\n    },\n    \n    onClose: (symbol, signal, priceClose, backtest) => {\n      const pnl = ((priceClose / signal.priceOpen) - 1) * 100;\n      const duration = (Date.now() - signal.pendingAt) / 60000;\n      \n      console.log(`[CLOSE] ${symbol} @ ${priceClose}`);\n      console.log(`  PNL: ${pnl.toFixed(2)}%`);\n      console.log(`  Duration: ${duration.toFixed(0)} minutes`);\n      \n      if (!backtest) {\n        // Update external tracking\n        logToDatabase({ event: \"signal_closed\", symbol, signal, priceClose, pnl, duration });\n      }\n    },\n    \n    onPartialProfit: (symbol, signal, currentPrice, revenuePercent, backtest) => {\n      console.log(`[PROFIT] ${symbol} reached ${revenuePercent}% profit`);\n      // Could adjust trailing stops or send alerts\n    },\n    \n    onPartialLoss: (symbol, signal, currentPrice, lossPercent, backtest) => {\n      console.log(`[LOSS] ${symbol} reached ${lossPercent}% loss`);\n      if (Math.abs(lossPercent) > 15 && !backtest) {\n        sendAlert(`High loss: ${symbol} at ${lossPercent}%`);\n      }\n    },\n  },\n});\n```\n\n**Sources:** [src/function/add.ts:18-64](), [types.d.ts:936-955](), [types.d.ts:909-931]()"
                    },
                    {
                        "page_plan": {
                            "id": "4.2",
                            "title": "Strategy Execution Flow"
                        },
                        "content": "# Strategy Execution Flow\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [assets/uml.svg](assets/uml.svg)\n- [docs/classes/StrategyConnectionService.md](docs/classes/StrategyConnectionService.md)\n- [docs/classes/WalkerCommandService.md](docs/classes/WalkerCommandService.md)\n- [docs/index.md](docs/index.md)\n- [docs/interfaces/BacktestStatistics.md](docs/interfaces/BacktestStatistics.md)\n- [docs/interfaces/IStrategy.md](docs/interfaces/IStrategy.md)\n- [docs/interfaces/IStrategyCallbacks.md](docs/interfaces/IStrategyCallbacks.md)\n- [docs/interfaces/IStrategySchema.md](docs/interfaces/IStrategySchema.md)\n- [docs/interfaces/LiveStatistics.md](docs/interfaces/LiveStatistics.md)\n- [docs/internals.md](docs/internals.md)\n- [docs/types/IStrategyBacktestResult.md](docs/types/IStrategyBacktestResult.md)\n- [docs/types/IStrategyTickResult.md](docs/types/IStrategyTickResult.md)\n- [docs/uml.puml](docs/uml.puml)\n- [scripts/uml.mjs](scripts/uml.mjs)\n- [src/client/ClientStrategy.ts](src/client/ClientStrategy.ts)\n- [src/interfaces/Strategy.interface.ts](src/interfaces/Strategy.interface.ts)\n- [src/lib/services/connection/StrategyConnectionService.ts](src/lib/services/connection/StrategyConnectionService.ts)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis page documents how trading strategies execute within the backtest-kit framework, focusing on the runtime behavior of the `ClientStrategy` class. It covers signal generation throttling, the `tick()` method for live execution, the `backtest()` method for historical simulation, VWAP-based monitoring, TP/SL condition checking, and scheduled signal activation.\n\nFor information about defining strategy schemas and registration, see [Defining Strategies](#4.1). For risk validation that occurs during execution, see [Risk Management](#4.3). For detailed execution mode orchestration, see [Backtest Mode](#5.1) and [Live Trading Mode](#5.2).\n\n---\n\n## ClientStrategy Architecture\n\nThe `ClientStrategy` class implements the `IStrategy` interface and serves as the core execution engine for trading strategies. It maintains internal state, handles signal lifecycle transitions, and integrates with exchange, risk, and persistence services.\n\n**Key Responsibilities:**\n- Signal generation with configurable interval throttling\n- State management for pending and scheduled signals\n- VWAP-based price monitoring for TP/SL conditions\n- Lifecycle callbacks (onOpen, onClose, onTick, etc.)\n- Crash-safe persistence via `PersistSignalAdapter`\n- Scheduled signal price activation logic\n\n**Diagram: ClientStrategy Class Structure**\n\n```mermaid\ngraph TB\n    IStrategy[\"IStrategy Interface<br/>(Strategy.interface.ts:318-388)\"]\n    ClientStrategy[\"ClientStrategy<br/>(ClientStrategy.ts:1285-1564)\"]\n    \n    subgraph \"Public Methods\"\n        tick[\"tick()<br/>Line 1333\"]\n        backtest[\"backtest()<br/>Line 1523\"]\n        getPending[\"getPendingSignal()<br/>Line 1462\"]\n        stop[\"stop()<br/>Line 1480\"]\n        waitForInit[\"waitForInit()<br/>Line 1299\"]\n    end\n    \n    subgraph \"Internal State\"\n        _pending[\"_pendingSignal: ISignalRow | null\"]\n        _scheduled[\"_scheduledSignal: IScheduledSignalRow | null\"]\n        _lastSignalTimestamp[\"_lastSignalTimestamp: number | null\"]\n        _isStopped[\"_isStopped: boolean\"]\n    end\n    \n    subgraph \"Helper Functions\"\n        GET_SIGNAL[\"GET_SIGNAL_FN<br/>Line 332-476<br/>Signal generation + throttling\"]\n        VALIDATE[\"VALIDATE_SIGNAL_FN<br/>Line 45-330<br/>Comprehensive validation\"]\n        CHECK_TIMEOUT[\"CHECK_SCHEDULED_SIGNAL_TIMEOUT_FN<br/>Line 554-608\"]\n        CHECK_ACTIVATION[\"CHECK_SCHEDULED_SIGNAL_PRICE_ACTIVATION_FN<br/>Line 610-644\"]\n        ACTIVATE[\"ACTIVATE_SCHEDULED_SIGNAL_FN<br/>Line 681-774\"]\n        CHECK_COMPLETE[\"CHECK_PENDING_SIGNAL_COMPLETION_FN<br/>Line 901-960\"]\n        CLOSE[\"CLOSE_PENDING_SIGNAL_FN<br/>Line 962-1023\"]\n    end\n    \n    subgraph \"Dependencies (IStrategyParams)\"\n        exchange[\"exchange: IExchange<br/>VWAP calculation\"]\n        risk[\"risk: IRisk<br/>Signal validation\"]\n        partial[\"partial: IPartial<br/>Milestone tracking\"]\n        persistence[\"PersistSignalAdapter<br/>Crash-safe storage\"]\n        logger[\"logger: ILogger\"]\n    end\n    \n    IStrategy --> ClientStrategy\n    ClientStrategy --> tick\n    ClientStrategy --> backtest\n    ClientStrategy --> getPending\n    ClientStrategy --> stop\n    ClientStrategy --> waitForInit\n    \n    ClientStrategy --> _pending\n    ClientStrategy --> _scheduled\n    ClientStrategy --> _lastSignalTimestamp\n    ClientStrategy --> _isStopped\n    \n    tick --> GET_SIGNAL\n    tick --> CHECK_TIMEOUT\n    tick --> CHECK_ACTIVATION\n    tick --> CHECK_COMPLETE\n    \n    GET_SIGNAL --> VALIDATE\n    ACTIVATE --> VALIDATE\n    CHECK_COMPLETE --> CLOSE\n    \n    ClientStrategy --> exchange\n    ClientStrategy --> risk\n    ClientStrategy --> partial\n    ClientStrategy --> persistence\n    ClientStrategy --> logger\n```\n\n**Sources:** [src/client/ClientStrategy.ts:1-1564](), [src/interfaces/Strategy.interface.ts:318-388]()\n\n---\n\n## The tick() Method: Live Execution\n\nThe `tick()` method implements a single iteration of strategy execution. It is called repeatedly in live mode (every 61 seconds) and once per timeframe in backtest mode. The method implements a state machine that handles idle, scheduled, opened, active, and closed states.\n\n**Diagram: tick() Execution Flow and State Transitions**\n\n```mermaid\nstateDiagram-v2\n    [*] --> CheckStopped\n    \n    CheckStopped --> ReturnIdle: _isStopped = true\n    CheckStopped --> CheckScheduled: _isStopped = false\n    \n    CheckScheduled --> CheckTimeout: _scheduledSignal exists\n    CheckScheduled --> CheckPending: _scheduledSignal = null\n    \n    CheckTimeout --> ReturnCancelled: Timeout exceeded<br/>(CC_SCHEDULE_AWAIT_MINUTES)\n    CheckTimeout --> CheckPriceActivation: Within timeout\n    \n    CheckPriceActivation --> CancelByStopLoss: Price beyond SL\n    CheckPriceActivation --> ActivateSignal: Price reached priceOpen\n    CheckPriceActivation --> ReturnActive: Waiting for activation\n    \n    CancelByStopLoss --> ReturnIdle\n    ActivateSignal --> RiskCheck\n    \n    RiskCheck --> ReturnIdle: Risk rejected\n    RiskCheck --> SetPendingSignal: Risk approved\n    \n    SetPendingSignal --> ReturnOpened\n    \n    CheckPending --> MonitorPosition: _pendingSignal exists\n    CheckPending --> GenerateSignal: _pendingSignal = null\n    \n    MonitorPosition --> CheckTPSL: VWAP from last 5 candles\n    \n    CheckTPSL --> ReturnClosed: TP/SL/Time hit\n    CheckTPSL --> ReturnActive: Still active\n    \n    GenerateSignal --> CheckThrottle: GET_SIGNAL_FN\n    \n    CheckThrottle --> ReturnIdle: Interval not elapsed\n    CheckThrottle --> InvokeGetSignal: Interval elapsed\n    \n    InvokeGetSignal --> ReturnIdle: No signal returned\n    InvokeGetSignal --> ValidateSignal: Signal returned\n    \n    ValidateSignal --> RiskCheck2: Valid signal\n    ValidateSignal --> ReturnIdle: Invalid signal\n    \n    RiskCheck2 --> ReturnIdle: Risk rejected\n    RiskCheck2 --> DetermineType: Risk approved\n    \n    DetermineType --> ReturnScheduled: priceOpen not reached\n    DetermineType --> ReturnOpened: Immediate activation\n    \n    ReturnIdle --> [*]\n    ReturnScheduled --> [*]\n    ReturnOpened --> [*]\n    ReturnActive --> [*]\n    ReturnClosed --> [*]\n    ReturnCancelled --> [*]\n```\n\n**Key Implementation Details:**\n\n1. **Stop Check** ([ClientStrategy.ts:1336-1344]()): Returns idle if `_isStopped` flag is set, allowing graceful shutdown without force-closing positions.\n\n2. **Scheduled Signal Handling** ([ClientStrategy.ts:1345-1374]()): \n   - Timeout check: `CC_SCHEDULE_AWAIT_MINUTES` (default 4320 minutes = 3 days)\n   - Price activation: Long activates when `currentPrice <= priceOpen`, Short when `currentPrice >= priceOpen`\n   - Stop loss cancellation: Prevents activation if price already beyond SL\n\n3. **Pending Signal Monitoring** ([ClientStrategy.ts:1379-1412]()): \n   - VWAP calculation from last 5 1-minute candles via `exchange.getAveragePrice()`\n   - TP check: Long closes when `averagePrice >= priceTakeProfit`\n   - SL check: Long closes when `averagePrice <= priceStopLoss`\n   - Time check: Closes when `elapsedTime >= minuteEstimatedTime * 60 * 1000`\n\n4. **Signal Generation** ([ClientStrategy.ts:1413-1433]()): \n   - Calls `GET_SIGNAL_FN` which implements throttling and validation\n   - Returns null if strategy stopped during generation\n   - Immediate activation if `priceOpen` already reached\n   - Scheduled signal creation if waiting for price\n\n**Sources:** [src/client/ClientStrategy.ts:1333-1460](), [src/interfaces/Strategy.interface.ts:174-307]()\n\n---\n\n## Signal Generation and Interval Throttling\n\nThe `GET_SIGNAL_FN` helper implements signal generation with configurable interval throttling to prevent excessive API calls and strategy spam. It enforces minimum time between `getSignal()` invocations based on the strategy's `interval` setting.\n\n**Diagram: Signal Generation Flow with Throttling**\n\n```mermaid\nsequenceDiagram\n    participant tick as tick()\n    participant GET_SIGNAL as GET_SIGNAL_FN<br/>(Line 332)\n    participant throttle as Interval Throttle<br/>INTERVAL_MINUTES\n    participant getSignal as User getSignal()<br/>IStrategySchema\n    participant risk as Risk Check<br/>IRisk.checkSignal()\n    participant validate as VALIDATE_SIGNAL_FN<br/>(Line 45)\n    \n    tick->>GET_SIGNAL: Request new signal\n    \n    GET_SIGNAL->>GET_SIGNAL: Check _isStopped flag\n    alt Strategy stopped\n        GET_SIGNAL-->>tick: return null\n    end\n    \n    GET_SIGNAL->>throttle: Check _lastSignalTimestamp\n    Note over throttle: intervalMs = INTERVAL_MINUTES[interval] * 60 * 1000\n    Note over throttle: Intervals: 1m, 3m, 5m, 15m, 30m, 1h\n    \n    alt Throttled (time < intervalMs)\n        throttle-->>GET_SIGNAL: Too soon\n        GET_SIGNAL-->>tick: return null\n    end\n    \n    throttle->>GET_SIGNAL: Interval elapsed\n    GET_SIGNAL->>GET_SIGNAL: Update _lastSignalTimestamp\n    \n    GET_SIGNAL->>getSignal: Invoke user callback<br/>getSignal(symbol, when)\n    Note over getSignal: Timeout: CC_MAX_SIGNAL_GENERATION_SECONDS\n    \n    alt Timeout exceeded\n        getSignal-->>GET_SIGNAL: TIMEOUT_SYMBOL\n        GET_SIGNAL->>GET_SIGNAL: throw Error\n    end\n    \n    alt No signal\n        getSignal-->>GET_SIGNAL: return null\n        GET_SIGNAL-->>tick: return null\n    end\n    \n    getSignal-->>GET_SIGNAL: ISignalDto\n    \n    GET_SIGNAL->>GET_SIGNAL: Check _isStopped again\n    alt Strategy stopped\n        GET_SIGNAL-->>tick: return null\n    end\n    \n    GET_SIGNAL->>risk: checkSignal({pendingSignal, symbol, ...})\n    \n    alt Risk rejected\n        risk-->>GET_SIGNAL: return false\n        GET_SIGNAL-->>tick: return null\n    end\n    \n    risk-->>GET_SIGNAL: return true\n    \n    GET_SIGNAL->>GET_SIGNAL: Determine signal type\n    \n    alt priceOpen specified\n        GET_SIGNAL->>GET_SIGNAL: Check shouldActivateImmediately\n        Note over GET_SIGNAL: Long: currentPrice <= priceOpen<br/>Short: currentPrice >= priceOpen\n        \n        alt Immediate activation\n            GET_SIGNAL->>validate: VALIDATE_SIGNAL_FN(signal, currentPrice, false)\n            validate-->>GET_SIGNAL: Valid ISignalRow\n            GET_SIGNAL-->>tick: return ISignalRow (_isScheduled: false)\n        else Scheduled activation\n            GET_SIGNAL->>validate: VALIDATE_SIGNAL_FN(signal, currentPrice, true)\n            validate-->>GET_SIGNAL: Valid IScheduledSignalRow\n            GET_SIGNAL-->>tick: return IScheduledSignalRow (_isScheduled: true)\n        end\n    else priceOpen omitted\n        GET_SIGNAL->>GET_SIGNAL: priceOpen = currentPrice\n        GET_SIGNAL->>validate: VALIDATE_SIGNAL_FN(signal, currentPrice, false)\n        validate-->>GET_SIGNAL: Valid ISignalRow\n        GET_SIGNAL-->>tick: return ISignalRow (_isScheduled: false)\n    end\n```\n\n**Throttling Configuration:**\n\n| Interval | Minutes | Use Case |\n|----------|---------|----------|\n| `\"1m\"` | 1 | High-frequency scalping strategies |\n| `\"3m\"` | 3 | Short-term momentum strategies |\n| `\"5m\"` | 5 | Standard intraday strategies |\n| `\"15m\"` | 15 | Swing trading strategies |\n| `\"30m\"` | 30 | Position trading strategies |\n| `\"1h\"` | 60 | Long-term strategies |\n\n**Key Implementation Details:**\n\n1. **Timestamp Tracking** ([ClientStrategy.ts:340-353]()): \n   - `_lastSignalTimestamp` stores last successful generation time\n   - Current time compared against `_lastSignalTimestamp + intervalMs`\n   - Early return null if throttled\n\n2. **Timeout Protection** ([ClientStrategy.ts:357-367]()): \n   - Uses `Promise.race()` to enforce `CC_MAX_SIGNAL_GENERATION_SECONDS`\n   - Prevents hanging user callbacks from blocking execution\n   - Throws error with strategy name and symbol for debugging\n\n3. **Immediate vs Scheduled** ([ClientStrategy.ts:388-443]()): \n   - If `priceOpen` provided and already reached → immediate `ISignalRow`\n   - If `priceOpen` provided and not reached → `IScheduledSignalRow` with `_isScheduled: true`\n   - If `priceOpen` omitted → immediate `ISignalRow` with `priceOpen = currentPrice`\n\n**Sources:** [src/client/ClientStrategy.ts:332-476](), [src/interfaces/Strategy.interface.ts:8-39]()\n\n---\n\n## Signal Validation\n\nThe `VALIDATE_SIGNAL_FN` helper performs comprehensive validation of signal fields and price relationships to prevent impossible trades, instant closures, and unprofitable configurations. It enforces constraints from `GLOBAL_CONFIG` parameters.\n\n**Validation Categories:**\n\n| Category | Checks | Config Parameters |\n|----------|--------|-------------------|\n| **Required Fields** | id, exchangeName, strategyName, symbol, position, _isScheduled | N/A |\n| **Price Validity** | Finite numbers, positive values, NaN/Infinity protection | N/A |\n| **Long Position Logic** | `priceTakeProfit > priceOpen > priceStopLoss` | N/A |\n| **Short Position Logic** | `priceStopLoss > priceOpen > priceTakeProfit` | N/A |\n| **Instant Closure Prevention** | Current price between SL and TP for immediate signals | N/A |\n| **Scheduled Validity** | priceOpen between SL and TP for scheduled signals | N/A |\n| **Minimum TP Distance** | Sufficient distance to cover fees and slippage | `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT` |\n| **Minimum SL Distance** | Buffer to avoid instant stop-out on volatility | `CC_MIN_STOPLOSS_DISTANCE_PERCENT` |\n| **Maximum SL Distance** | Capital protection from extreme losses | `CC_MAX_STOPLOSS_DISTANCE_PERCENT` |\n| **Time Validity** | Positive integer minutes, max lifetime limit | `CC_MAX_SIGNAL_LIFETIME_MINUTES` |\n\n**Diagram: Signal Validation Decision Tree**\n\n```mermaid\ngraph TB\n    Start[\"VALIDATE_SIGNAL_FN<br/>(Line 45)\"]\n    \n    Start --> RequiredFields[\"Check Required Fields<br/>id, exchangeName, strategyName,<br/>symbol, position, _isScheduled\"]\n    \n    RequiredFields --> |Missing| Error1[\"Throw Error:<br/>Required field missing\"]\n    RequiredFields --> |Valid| PriceFinite[\"Check Price Validity<br/>isFinite() for all prices<br/>currentPrice > 0\"]\n    \n    PriceFinite --> |NaN/Infinity| Error2[\"Throw Error:<br/>Price must be finite number\"]\n    PriceFinite --> |Valid| PositionType{\"position type?\"}\n    \n    PositionType --> |\"long\"| LongLogic[\"Long Position Validation\"]\n    PositionType --> |\"short\"| ShortLogic[\"Short Position Validation\"]\n    \n    LongLogic --> LongRelation[\"Check: priceTakeProfit > priceOpen > priceStopLoss\"]\n    LongRelation --> |Invalid| Error3[\"Throw Error:<br/>Invalid price relationship\"]\n    LongRelation --> |Valid| LongImmediate{\"isScheduled?\"}\n    \n    LongImmediate --> |false| CheckLongCurrent[\"Check: priceStopLoss < currentPrice < priceTakeProfit\"]\n    CheckLongCurrent --> |Outside range| Error4[\"Throw Error:<br/>Position would close immediately\"]\n    CheckLongCurrent --> |Inside range| LongScheduledCheck\n    \n    LongImmediate --> |true| LongScheduledCheck[\"Check: priceStopLoss < priceOpen < priceTakeProfit\"]\n    LongScheduledCheck --> |Outside range| Error5[\"Throw Error:<br/>Scheduled signal invalid\"]\n    LongScheduledCheck --> |Inside range| TPDistance\n    \n    ShortLogic --> ShortRelation[\"Check: priceStopLoss > priceOpen > priceTakeProfit\"]\n    ShortRelation --> |Invalid| Error6[\"Throw Error:<br/>Invalid price relationship\"]\n    ShortRelation --> |Valid| ShortImmediate{\"isScheduled?\"}\n    \n    ShortImmediate --> |false| CheckShortCurrent[\"Check: priceTakeProfit < currentPrice < priceStopLoss\"]\n    CheckShortCurrent --> |Outside range| Error7[\"Throw Error:<br/>Position would close immediately\"]\n    CheckShortCurrent --> |Inside range| ShortScheduledCheck\n    \n    ShortImmediate --> |true| ShortScheduledCheck[\"Check: priceTakeProfit < priceOpen < priceStopLoss\"]\n    ShortScheduledCheck --> |Outside range| Error8[\"Throw Error:<br/>Scheduled signal invalid\"]\n    ShortScheduledCheck --> |Inside range| TPDistance\n    \n    TPDistance[\"Check TP Distance<br/>CC_MIN_TAKEPROFIT_DISTANCE_PERCENT\"]\n    TPDistance --> |Too close| Error9[\"Throw Error:<br/>TakeProfit too close,<br/>cannot cover fees\"]\n    TPDistance --> |Sufficient| SLMinDistance\n    \n    SLMinDistance[\"Check Min SL Distance<br/>CC_MIN_STOPLOSS_DISTANCE_PERCENT\"]\n    SLMinDistance --> |Too close| Error10[\"Throw Error:<br/>StopLoss too close,<br/>instant stop-out risk\"]\n    SLMinDistance --> |Sufficient| SLMaxDistance\n    \n    SLMaxDistance[\"Check Max SL Distance<br/>CC_MAX_STOPLOSS_DISTANCE_PERCENT\"]\n    SLMaxDistance --> |Too far| Error11[\"Throw Error:<br/>StopLoss too far,<br/>capital protection\"]\n    SLMaxDistance --> |Within limit| TimeValid\n    \n    TimeValid[\"Check Time Parameters<br/>minuteEstimatedTime > 0,<br/>integer, < CC_MAX_SIGNAL_LIFETIME_MINUTES\"]\n    TimeValid --> |Invalid| Error12[\"Throw Error:<br/>Invalid time parameters\"]\n    TimeValid --> |Valid| Success[\"Validation Passed\"]\n```\n\n**Key Validation Logic:**\n\n1. **Instant Closure Prevention** ([ClientStrategy.ts:124-160]()): \n   - Long immediate: Rejects if `currentPrice <= priceStopLoss` or `currentPrice >= priceTakeProfit`\n   - Short immediate: Rejects if `currentPrice >= priceStopLoss` or `currentPrice <= priceTakeProfit`\n   - Prevents opening positions that are already stopped out or already profitable\n\n2. **Economic Viability** ([ClientStrategy.ts:163-199]()): \n   - TP distance must exceed `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT` to cover fees (default 0.2%)\n   - SL distance must exceed `CC_MIN_STOPLOSS_DISTANCE_PERCENT` to avoid instant stop-out (default 0.1%)\n   - SL distance must not exceed `CC_MAX_STOPLOSS_DISTANCE_PERCENT` for capital protection (default 10%)\n\n3. **Lifetime Limits** ([ClientStrategy.ts:306-316]()): \n   - `CC_MAX_SIGNAL_LIFETIME_MINUTES` prevents eternal signals that block risk limits\n   - Default 43200 minutes (30 days)\n   - Ensures portfolio turnover and risk slot availability\n\n**Sources:** [src/client/ClientStrategy.ts:45-330](), [src/config/params.ts]()\n\n---\n\n## Scheduled Signal Activation\n\nScheduled signals implement delayed entry at specific price levels. The framework monitors price movement and activates signals when the target `priceOpen` is reached, or cancels them if stop loss is hit first or timeout expires.\n\n**Diagram: Scheduled Signal State Machine**\n\n```mermaid\nstateDiagram-v2\n    [*] --> Scheduled: getSignal returns<br/>IScheduledSignalRow\n    \n    Scheduled --> TimeoutCheck: Every tick\n    \n    TimeoutCheck --> Cancelled: elapsed > CC_SCHEDULE_AWAIT_MINUTES\n    TimeoutCheck --> PriceCheck: Within timeout\n    \n    PriceCheck --> CheckStopLoss: Every tick\n    \n    CheckStopLoss --> Cancelled: Long: price <= SL<br/>Short: price >= SL\n    CheckStopLoss --> CheckActivation: SL not hit\n    \n    CheckActivation --> RiskValidation: Long: price <= priceOpen<br/>Short: price >= priceOpen\n    CheckActivation --> Active: Waiting for price\n    \n    RiskValidation --> Cancelled: Risk rejected\n    RiskValidation --> Opened: Risk approved\n    \n    Opened --> Pending: Convert to ISignalRow<br/>Update pendingAt\n    \n    Active --> TimeoutCheck: Continue monitoring\n    Cancelled --> [*]\n    Pending --> [*]: Monitor as pending signal\n```\n\n**Implementation Functions:**\n\n1. **Timeout Check** ([ClientStrategy.ts:554-608]()): \n   ```typescript\n   // CHECK_SCHEDULED_SIGNAL_TIMEOUT_FN\n   const maxTimeToWait = GLOBAL_CONFIG.CC_SCHEDULE_AWAIT_MINUTES * 60 * 1000;\n   const elapsedTime = currentTime - scheduled.scheduledAt;\n   if (elapsedTime >= maxTimeToWait) {\n     // Cancel signal and return IStrategyTickResultCancelled\n   }\n   ```\n\n2. **Price Activation Check** ([ClientStrategy.ts:610-644]()): \n   ```typescript\n   // CHECK_SCHEDULED_SIGNAL_PRICE_ACTIVATION_FN\n   if (scheduled.position === \"long\") {\n     if (currentPrice <= scheduled.priceStopLoss) {\n       shouldCancel = true; // Stop loss hit before activation\n     } else if (currentPrice <= scheduled.priceOpen) {\n       shouldActivate = true; // Entry price reached\n     }\n   }\n   // Similar logic for short positions\n   ```\n\n3. **Activation** ([ClientStrategy.ts:681-774]()): \n   ```typescript\n   // ACTIVATE_SCHEDULED_SIGNAL_FN\n   // 1. Check _isStopped flag\n   // 2. Risk validation with IRisk.checkSignal()\n   // 3. Convert IScheduledSignalRow to ISignalRow\n   // 4. Update pendingAt to activation timestamp\n   // 5. Persist via setPendingSignal()\n   // 6. Add to risk tracking\n   // 7. Trigger onOpen callback\n   // 8. Return IStrategyTickResultOpened\n   ```\n\n**Critical Timestamp Handling:**\n\n- `scheduledAt`: Set when signal first created, never changes\n- `pendingAt`: Initially equals `scheduledAt`, updated to activation timestamp when activated\n- Duration calculations for pending signals use `pendingAt`, not `scheduledAt`\n\n**Sources:** [src/client/ClientStrategy.ts:554-801]()\n\n---\n\n## Position Monitoring and Closure\n\nOnce a signal transitions to the pending state (either immediately or after scheduled activation), `ClientStrategy` monitors VWAP price against TP/SL/time conditions on every tick.\n\n**Diagram: Position Monitoring Flow**\n\n```mermaid\nsequenceDiagram\n    participant tick as tick()\n    participant exchange as IExchange.getAveragePrice()\n    participant vwap as VWAP Calculation<br/>Last 5 1m candles\n    participant check as CHECK_PENDING_SIGNAL_COMPLETION_FN<br/>(Line 901)\n    participant close as CLOSE_PENDING_SIGNAL_FN<br/>(Line 962)\n    participant partial as IPartial.profit/loss()\n    participant risk as IRisk.removeSignal()\n    \n    tick->>exchange: getAveragePrice(symbol)\n    exchange->>vwap: Fetch last 5 candles<br/>CC_AVG_PRICE_CANDLES_COUNT\n    vwap-->>exchange: Calculate VWAP\n    exchange-->>tick: averagePrice\n    \n    tick->>check: Check closure conditions<br/>(_pendingSignal, averagePrice)\n    \n    check->>check: Calculate elapsedTime<br/>currentTime - signal.pendingAt\n    \n    alt Time Expired\n        check->>check: elapsedTime >= minuteEstimatedTime * 60 * 1000\n        check->>close: CLOSE_PENDING_SIGNAL_FN<br/>(signal, averagePrice, \"time_expired\")\n    else Long TP Hit\n        check->>check: position = \"long\" && averagePrice >= priceTakeProfit\n        check->>close: CLOSE_PENDING_SIGNAL_FN<br/>(signal, priceTakeProfit, \"take_profit\")\n    else Short TP Hit\n        check->>check: position = \"short\" && averagePrice <= priceTakeProfit\n        check->>close: CLOSE_PENDING_SIGNAL_FN<br/>(signal, priceTakeProfit, \"take_profit\")\n    else Long SL Hit\n        check->>check: position = \"long\" && averagePrice <= priceStopLoss\n        check->>close: CLOSE_PENDING_SIGNAL_FN<br/>(signal, priceStopLoss, \"stop_loss\")\n    else Short SL Hit\n        check->>check: position = \"short\" && averagePrice >= priceStopLoss\n        check->>close: CLOSE_PENDING_SIGNAL_FN<br/>(signal, priceStopLoss, \"stop_loss\")\n    else Still Active\n        check->>check: Calculate percentTp/percentSl\n        check->>partial: Call profit() or loss() based on direction\n        check-->>tick: return IStrategyTickResultActive<br/>{action: \"active\", percentTp, percentSl}\n    end\n    \n    close->>close: Calculate PNL<br/>toProfitLossDto(signal, currentPrice)\n    close->>close: Trigger onClose callback\n    close->>partial: Clear partial tracking<br/>partial.clear(symbol, signal, price)\n    close->>risk: Remove from risk tracking<br/>removeSignal(symbol, {strategyName, riskName})\n    close->>close: Clear _pendingSignal state<br/>setPendingSignal(null)\n    close->>close: Trigger onTick callback\n    close-->>check: IStrategyTickResultClosed\n    check-->>tick: IStrategyTickResultClosed\n```\n\n**Closure Conditions:**\n\n| Close Reason | Long Condition | Short Condition | Price Used |\n|--------------|---------------|-----------------|------------|\n| `\"take_profit\"` | `averagePrice >= priceTakeProfit` | `averagePrice <= priceTakeProfit` | `priceTakeProfit` (exact TP price) |\n| `\"stop_loss\"` | `averagePrice <= priceStopLoss` | `averagePrice >= priceStopLoss` | `priceStopLoss` (exact SL price) |\n| `\"time_expired\"` | `elapsedTime >= minuteEstimatedTime * 60 * 1000` | Same | `averagePrice` (current market price) |\n\n**Partial Profit/Loss Tracking:**\n\nFor active signals, the framework calculates progress towards TP or SL as percentages:\n\n- **Long Position Moving Up**: `percentTp = ((currentPrice - priceOpen) / (priceTakeProfit - priceOpen)) * 100`\n- **Long Position Moving Down**: `percentSl = ((priceOpen - currentPrice) / (priceOpen - priceStopLoss)) * 100`\n- **Short Position Moving Down**: `percentTp = ((priceOpen - currentPrice) / (priceOpen - priceTakeProfit)) * 100`\n- **Short Position Moving Up**: `percentSl = ((currentPrice - priceOpen) / (priceStopLoss - priceOpen)) * 100`\n\nThese percentages trigger milestone events (10%, 20%, 30%, etc.) via `IPartial.profit()` and `IPartial.loss()` for tracking and callbacks.\n\n**Sources:** [src/client/ClientStrategy.ts:901-1129](), [src/helpers/toProfitLossDto.ts]()\n\n---\n\n## The backtest() Method: Fast Historical Simulation\n\nThe `backtest()` method provides optimized historical simulation by processing candle data directly rather than iterating individual ticks. It's called when `tick()` returns an \"opened\" signal during backtest mode.\n\n**Diagram: backtest() Execution Flow**\n\n```mermaid\ngraph TB\n    Start[\"backtest()<br/>(Line 1523)\"]\n    \n    Start --> CheckScheduled{\"_scheduledSignal<br/>exists?\"}\n    \n    CheckScheduled --> |Yes| ScheduledLoop[\"Iterate candles<br/>for activation/cancellation\"]\n    CheckScheduled --> |No| SetPending[\"_pendingSignal<br/>already set<br/>(immediate signal)\"]\n    \n    ScheduledLoop --> ScheduledCandle[\"For each candle\"]\n    \n    ScheduledCandle --> ScheduledVWAP[\"Calculate VWAP<br/>GET_AVG_PRICE_FN\"]\n    ScheduledVWAP --> CheckScheduledTimeout[\"Check timeout<br/>candle.timestamp - scheduledAt\"]\n    \n    CheckScheduledTimeout --> |Timeout| ReturnCancelled[\"Return IStrategyTickResultCancelled<br/>closeTimestamp = candle.timestamp\"]\n    CheckScheduledTimeout --> |Within time| CheckScheduledPrice[\"CHECK_SCHEDULED_SIGNAL_PRICE_ACTIVATION_FN\"]\n    \n    CheckScheduledPrice --> |shouldCancel| ReturnCancelled\n    CheckScheduledPrice --> |shouldActivate| ActivateScheduled[\"ACTIVATE_SCHEDULED_SIGNAL_FN<br/>pendingAt = candle.timestamp + 60000\"]\n    CheckScheduledPrice --> |waiting| ScheduledCandle\n    \n    ActivateScheduled --> SetPending\n    SetPending --> PendingLoop[\"Iterate candles<br/>for TP/SL/Time\"]\n    \n    PendingLoop --> PendingCandle[\"For each candle\"]\n    \n    PendingCandle --> PendingVWAP[\"Calculate VWAP<br/>GET_AVG_PRICE_FN\"]\n    PendingVWAP --> CheckTime[\"Check time expiration<br/>candle.timestamp - pendingAt\"]\n    \n    CheckTime --> |Expired| CloseTime[\"CLOSE_PENDING_SIGNAL_FN<br/>closeReason: 'time_expired'\"]\n    CheckTime --> |Active| CheckTP[\"Check Take Profit\"]\n    \n    CheckTP --> |Hit| CloseTP[\"CLOSE_PENDING_SIGNAL_FN<br/>closeReason: 'take_profit'<br/>price = priceTakeProfit\"]\n    CheckTP --> |Not hit| CheckSL[\"Check Stop Loss\"]\n    \n    CheckSL --> |Hit| CloseSL[\"CLOSE_PENDING_SIGNAL_FN<br/>closeReason: 'stop_loss'<br/>price = priceStopLoss\"]\n    CheckSL --> |Not hit| UpdatePartial[\"Update partial tracking<br/>Call onActive callback\"]\n    \n    UpdatePartial --> PendingCandle\n    \n    CloseTime --> ReturnClosed\n    CloseTP --> ReturnClosed\n    CloseSL --> ReturnClosed\n    \n    ReturnClosed[\"Return IStrategyTickResultClosed\"]\n    ReturnCancelled --> End[\"End\"]\n    ReturnClosed --> End\n```\n\n**Key Optimizations:**\n\n1. **Direct Candle Processing**: No individual tick() calls, processes candles in batch\n2. **VWAP per Candle**: Calculates volume-weighted average for each candle using `GET_AVG_PRICE_FN`\n3. **Immediate Closure Detection**: Exits loop as soon as TP/SL/time condition met\n4. **Activation Timestamp**: For scheduled signals, sets `pendingAt = candle.timestamp + 60000` (next candle)\n\n**Critical Timestamp Handling in Backtest:**\n\n```typescript\n// For scheduled signal activation in backtest\nconst activationTime = candle.timestamp + 60_000; // Next candle start\nactivatedSignal.pendingAt = activationTime;\n\n// For closure\nresult.closeTimestamp = candle.timestamp; // Current candle timestamp\n```\n\nThis ensures that duration calculations accurately reflect candle boundaries rather than arbitrary intermediate times.\n\n**VWAP Calculation** ([ClientStrategy.ts:478-489]()):\n\n```typescript\nconst GET_AVG_PRICE_FN = (candles: ICandleData[]): number => {\n  const sumPriceVolume = candles.reduce((acc, c) => {\n    const typicalPrice = (c.high + c.low + c.close) / 3;\n    return acc + typicalPrice * c.volume;\n  }, 0);\n  \n  const totalVolume = candles.reduce((acc, c) => acc + c.volume, 0);\n  \n  return totalVolume === 0\n    ? candles.reduce((acc, c) => acc + c.close, 0) / candles.length\n    : sumPriceVolume / totalVolume;\n};\n```\n\n**Sources:** [src/client/ClientStrategy.ts:1523-1564](), [src/client/ClientStrategy.ts:478-489]()\n\n---\n\n## State Persistence and Recovery\n\n`ClientStrategy` implements crash-safe state persistence for live trading mode. Pending and scheduled signals are atomically written to disk after each state change, enabling recovery after process crashes.\n\n**Persistence Points:**\n\n1. **setPendingSignal()** ([ClientStrategy.ts:1304-1318]()): \n   - Writes via `PersistSignalAdapter.writeSignalData()`\n   - Atomic write ensures consistency\n   - Triggers `onWrite` callback for testing\n\n2. **setScheduledSignal()** ([ClientStrategy.ts:1320-1330]()): \n   - Writes via `PersistScheduleAdapter.writeScheduleData()`\n   - Separate storage from pending signals\n   - Enables concurrent scheduled and pending signals\n\n3. **waitForInit()** ([ClientStrategy.ts:491-552]()): \n   - Called before first tick in live mode\n   - Reads both pending and scheduled signal state\n   - Triggers `onActive` and `onSchedule` callbacks for restored signals\n   - Only runs in non-backtest mode (`backtest = false`)\n\n**Recovery Guarantees:**\n\n- **Pending signals**: Restored with exact price levels and timestamps\n- **Scheduled signals**: Restored and continue monitoring for activation\n- **No double-execution**: State cleared before persistence prevents duplication\n- **Risk state**: Risk tracking re-initialized via callbacks, not persisted\n\n**Sources:** [src/client/ClientStrategy.ts:491-552](), [src/client/ClientStrategy.ts:1304-1330](), [src/classes/Persist.ts]()\n\n---\n\n## Integration with Service Layer\n\n`ClientStrategy` is instantiated and managed by `StrategyConnectionService`, which implements memoization and routing. The service layer provides dependency injection and context management.\n\n**Diagram: Service Layer Integration**\n\n```mermaid\ngraph TB\n    Public[\"Public API<br/>Backtest.run()<br/>Live.run()\"]\n    \n    Command[\"Command Services<br/>BacktestCommandService<br/>LiveCommandService\"]\n    \n    LogicPub[\"Logic Public Services<br/>BacktestLogicPublicService<br/>LiveLogicPublicService\"]\n    \n    LogicPriv[\"Logic Private Services<br/>BacktestLogicPrivateService<br/>LiveLogicPrivateService\"]\n    \n    Core[\"StrategyCoreService<br/>(core/StrategyCoreService.ts)\"]\n    \n    Connection[\"StrategyConnectionService<br/>(connection/StrategyConnectionService.ts)\"]\n    \n    Client[\"ClientStrategy<br/>(client/ClientStrategy.ts)\"]\n    \n    Schema[\"StrategySchemaService<br/>Registry for IStrategySchema\"]\n    \n    Exchange[\"ExchangeConnectionService<br/>IExchange instances\"]\n    \n    Risk[\"RiskConnectionService<br/>IRisk instances\"]\n    \n    Partial[\"PartialConnectionService<br/>IPartial instances\"]\n    \n    Context[\"ExecutionContextService<br/>{symbol, when, backtest}\"]\n    \n    Method[\"MethodContextService<br/>{strategyName, exchangeName, frameName}\"]\n    \n    Public --> Command\n    Command --> LogicPub\n    LogicPub --> LogicPriv\n    LogicPriv --> Core\n    \n    Core --> Connection\n    Connection --> |\"getStrategy(symbol, strategyName)<br/>Memoized by 'symbol:strategyName'\"| Client\n    \n    Connection --> Schema\n    Connection --> Exchange\n    Connection --> Risk\n    Connection --> Partial\n    Connection --> Context\n    Connection --> Method\n    \n    Schema --> |\"get(strategyName)<br/>Returns IStrategySchema\"| Connection\n    Exchange --> |\"Provides IExchange\"| Client\n    Risk --> |\"Provides IRisk\"| Client\n    Partial --> |\"Provides IPartial\"| Client\n    Context --> |\"Provides ExecutionContext\"| Client\n    Method --> |\"Provides MethodContext\"| Client\n    \n    Client --> |\"tick()<br/>backtest()<br/>getPendingSignal()\"| Connection\n```\n\n**StrategyConnectionService Methods** ([src/lib/services/connection/StrategyConnectionService.ts:89-306]()):\n\n| Method | Purpose | Key Implementation |\n|--------|---------|-------------------|\n| `getStrategy()` | Memoized factory for ClientStrategy instances | Cache key: `${symbol}:${strategyName}`, creates new instance on first call |\n| `tick()` | Routes to ClientStrategy.tick(), emits events | Calls `waitForInit()`, emits to `signalEmitter`, `signalLiveEmitter`, `signalBacktestEmitter` |\n| `backtest()` | Routes to ClientStrategy.backtest(), emits events | Calls `waitForInit()`, emits to `signalEmitter`, `signalBacktestEmitter` |\n| `getPendingSignal()` | Routes to ClientStrategy.getPendingSignal() | Direct delegation, no side effects |\n| `stop()` | Routes to ClientStrategy.stop() | Sets `_isStopped` flag |\n| `clear()` | Clears memoization cache | Optional context parameter for selective clearing |\n\n**Context Services:**\n\n- **ExecutionContextService** ([src/lib/services/context/ExecutionContextService.ts]()): Provides `{symbol, when, backtest}` for current execution\n- **MethodContextService** ([src/lib/services/context/MethodContextService.ts]()): Provides `{strategyName, exchangeName, frameName}` for routing\n\nThese contexts are injected via dependency injection and accessed throughout ClientStrategy via `this.params.execution.context` and `this.params.method.context`.\n\n**Sources:** [src/lib/services/connection/StrategyConnectionService.ts:89-306](), [src/lib/services/core/StrategyCoreService.ts](), [src/lib/services/context/ExecutionContextService.ts](), [src/lib/services/context/MethodContextService.ts]()\n\n---\n\n## Summary\n\nThe strategy execution flow in backtest-kit is implemented by `ClientStrategy`, which provides two primary execution modes:\n\n1. **tick() mode**: Real-time or timeframe-by-timeframe execution with state persistence, scheduled signal activation, and VWAP monitoring\n2. **backtest() mode**: Fast historical simulation with direct candle processing and optimized closure detection\n\nKey design patterns:\n- **State Machine**: Clear transitions between idle/scheduled/opened/active/closed/cancelled states\n- **Throttling**: Configurable interval-based signal generation to prevent spam\n- **Validation**: Comprehensive pre-execution checks ensuring economic viability and logical consistency\n- **Persistence**: Crash-safe atomic writes for live trading recovery\n- **Memoization**: Service-layer caching for performance optimization\n- **Context Injection**: Dependency injection for testability and modularity\n\nThe execution flow integrates with risk management, position sizing, partial tracking, and exchange services through well-defined interfaces, enabling modular composition and extensibility.\n\n**Sources:** [src/client/ClientStrategy.ts:1-1564](), [src/interfaces/Strategy.interface.ts:1-394](), [src/lib/services/connection/StrategyConnectionService.ts:1-309]()"
                    },
                    {
                        "page_plan": {
                            "id": "4.3",
                            "title": "Risk Management"
                        },
                        "content": "# Risk Management\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [src/client/ClientStrategy.ts](src/client/ClientStrategy.ts)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [src/interfaces/Heatmap.interface.ts](src/interfaces/Heatmap.interface.ts)\n- [src/interfaces/Strategy.interface.ts](src/interfaces/Strategy.interface.ts)\n- [src/lib/services/connection/StrategyConnectionService.ts](src/lib/services/connection/StrategyConnectionService.ts)\n- [test/e2e/defend.test.mjs](test/e2e/defend.test.mjs)\n- [test/e2e/risk.test.mjs](test/e2e/risk.test.mjs)\n- [test/index.mjs](test/index.mjs)\n- [test/mock/getMockCandles.mjs](test/mock/getMockCandles.mjs)\n- [test/spec/heat.test.mjs](test/spec/heat.test.mjs)\n- [test/spec/list.test.mjs](test/spec/list.test.mjs)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\nThis document describes the risk management system that validates trading signals before execution. Risk profiles define portfolio-level controls such as position limits, time windows, and custom validation logic. For strategy-level signal validation (TP/SL distances, price checks), see [Strategy Execution Flow](#4.2). For position sizing calculations, see [Position Sizing](#4.4).\n\n---\n\n## Overview\n\nThe risk management system enforces portfolio-level constraints on signal creation through custom validation functions. Risk profiles are registered via `addRisk()` and referenced by strategies through `riskName` or `riskList` fields. Risk checks execute **before** signals are created or activated, preventing invalid positions from entering the portfolio.\n\n**Key Features:**\n- Custom validation functions with access to portfolio state\n- Position tracking across multiple strategies\n- Multi-risk composition via `MergeRisk`\n- Event emission for rejected signals\n- Strategy-level or portfolio-level scoping\n\n**Sources:** [types.d.ts:546-691](), [src/interfaces/Risk.interface.ts](), [README.md:76-95]()\n\n---\n\n## Risk Schema Registration\n\nRisk profiles are registered using `addRisk()` and stored in `RiskSchemaService`. Each profile contains a unique identifier, optional callbacks, and an array of validation functions.\n\n### IRiskSchema Structure\n\n```typescript\ninterface IRiskSchema {\n  riskName: RiskName;                                  // Unique identifier\n  note?: string;                                       // Documentation\n  callbacks?: Partial<IRiskCallbacks>;                 // Event hooks\n  validations: (IRiskValidation | IRiskValidationFn)[]; // Validation array\n}\n\ninterface IRiskValidation {\n  validate: IRiskValidationFn;  // Validation function\n  note?: string;                 // Description for rejection message\n}\n```\n\n### Registration Example\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `riskName` | `string` | Yes | Unique risk profile identifier |\n| `note` | `string` | No | Developer documentation |\n| `validations` | `Array` | Yes | Array of validation functions or validation objects |\n| `callbacks` | `Object` | No | `onRejected`, `onAllowed` event hooks |\n\n**Sources:** [types.d.ts:606-634](), [src/function/add.ts](), [test/e2e/risk.test.mjs:35-56]()\n\n---\n\n## Validation Function Interface\n\nValidation functions receive `IRiskValidationPayload` containing signal details, portfolio state, and active positions. Functions should throw an error to reject the signal, or return `void`/`Promise<void>` to allow it.\n\n### IRiskValidationPayload Structure\n\n```typescript\ninterface IRiskValidationPayload {\n  symbol: string;                     // Trading pair (e.g., \"BTCUSDT\")\n  pendingSignal: ISignalDto;          // Signal to validate\n  strategyName: StrategyName;         // Strategy requesting position\n  exchangeName: ExchangeName;         // Exchange name\n  currentPrice: number;               // Current VWAP price\n  timestamp: number;                  // Request timestamp (ms)\n  activePositionCount: number;        // Total active positions\n  activePositions: IRiskActivePosition[]; // List of active positions\n}\n\ninterface IRiskActivePosition {\n  signal: ISignalRow;       // Active signal details\n  strategyName: string;     // Owning strategy\n  exchangeName: string;     // Exchange name\n  openTimestamp: number;    // Position open time (ms)\n}\n```\n\n### Common Validation Patterns\n\n**Maximum Position Limit:**\n```typescript\n({ activePositionCount }) => {\n  if (activePositionCount >= 3) {\n    throw new Error(\"Maximum 3 concurrent positions\");\n  }\n}\n```\n\n**Symbol Filter:**\n```typescript\n({ symbol }) => {\n  if (symbol === \"BTCUSDT\") {\n    throw new Error(\"BTC trading not allowed\");\n  }\n}\n```\n\n**Time Window:**\n```typescript\n({ timestamp }) => {\n  const hour = new Date(timestamp).getHours();\n  if (hour < 9 || hour > 16) {\n    throw new Error(\"Trading only allowed 9am-4pm\");\n  }\n}\n```\n\n**Risk/Reward Ratio:**\n```typescript\n({ pendingSignal, currentPrice }) => {\n  const { priceOpen = currentPrice, priceTakeProfit, priceStopLoss, position } = pendingSignal;\n  const reward = position === \"long\" ? priceTakeProfit - priceOpen : priceOpen - priceTakeProfit;\n  const risk = position === \"long\" ? priceOpen - priceStopLoss : priceStopLoss - priceOpen;\n  if (reward / risk < 2) {\n    throw new Error(\"R/R ratio must be >= 2:1\");\n  }\n}\n```\n\n**Sources:** [types.d.ts:588-620](), [test/e2e/risk.test.mjs:146-160](), [test/e2e/risk.test.mjs:229-234]()\n\n---\n\n## Risk Check Lifecycle\n\nRisk validation occurs at two points in the signal lifecycle: (1) when `getSignal()` returns a new signal, and (2) when a scheduled signal activates at `priceOpen`. The validation process is identical in both cases.\n\n### Risk Validation Flow\n\n```mermaid\ngraph TB\n    Start[\"ClientStrategy.tick() or<br/>scheduled signal activation\"]\n    GetSignal[\"getSignal() returns<br/>ISignalDto or null\"]\n    CheckNull{\"Signal<br/>null?\"}\n    RiskCheck[\"ClientRisk.checkSignal()<br/>IRiskCheckArgs\"]\n    LoadState[\"Load active positions<br/>from PersistRiskAdapter\"]\n    BuildPayload[\"Build IRiskValidationPayload<br/>with activePositionCount\"]\n    IterateValidations[\"Iterate validations array\"]\n    RunValidation[\"Execute validation(payload)\"]\n    ValidationThrows{\"Throws<br/>error?\"}\n    EmitRejection[\"Emit riskSubject event<br/>Call callbacks.onRejected\"]\n    ReturnFalse[\"Return false\"]\n    NextValidation[\"Next validation\"]\n    AllPassed{\"All<br/>passed?\"}\n    EmitAllowed[\"Call callbacks.onAllowed\"]\n    ReturnTrue[\"Return true\"]\n    CheckResult{\"checkSignal<br/>= true?\"}\n    CreateSignal[\"Create ISignalRow<br/>Set scheduledAt, pendingAt\"]\n    ValidateSignal[\"VALIDATE_SIGNAL_FN()<br/>Price/TP/SL checks\"]\n    AddPosition[\"risk.addSignal()<br/>Track in PersistRiskAdapter\"]\n    PersistSignal[\"Persist to PersistSignalAdapter\"]\n    EmitOpened[\"Emit signalEmitter<br/>action: opened\"]\n    Discard[\"Discard signal<br/>Return null\"]\n    End[\"Continue monitoring\"]\n\n    Start --> GetSignal\n    GetSignal --> CheckNull\n    CheckNull -->|\"Yes\"| End\n    CheckNull -->|\"No\"| RiskCheck\n    \n    RiskCheck --> LoadState\n    LoadState --> BuildPayload\n    BuildPayload --> IterateValidations\n    IterateValidations --> RunValidation\n    RunValidation --> ValidationThrows\n    ValidationThrows -->|\"Yes\"| EmitRejection\n    EmitRejection --> ReturnFalse\n    ReturnFalse --> CheckResult\n    ValidationThrows -->|\"No\"| NextValidation\n    NextValidation --> AllPassed\n    AllPassed -->|\"No\"| RunValidation\n    AllPassed -->|\"Yes\"| EmitAllowed\n    EmitAllowed --> ReturnTrue\n    ReturnTrue --> CheckResult\n    \n    CheckResult -->|\"false\"| Discard\n    Discard --> End\n    CheckResult -->|\"true\"| CreateSignal\n    CreateSignal --> ValidateSignal\n    ValidateSignal --> AddPosition\n    AddPosition --> PersistSignal\n    PersistSignal --> EmitOpened\n    EmitOpened --> End\n    \n    style RiskCheck fill:#fff4e1,stroke:#333,stroke-width:2px\n    style EmitRejection fill:#ffcccc,stroke:#333,stroke-width:2px\n    style AddPosition fill:#e8f5e9,stroke:#333,stroke-width:2px\n```\n\n**Sources:** [src/client/ClientStrategy.ts:375-387](), [src/client/ClientRisk.ts](), [src/client/ClientStrategy.ts:712-729]()\n\n---\n\n## Risk Check Arguments\n\nThe `IRiskCheckArgs` interface defines the parameters passed from `ClientStrategy` to `ClientRisk.checkSignal()`. These are **passthrough arguments** from the strategy context, without portfolio state.\n\n### IRiskCheckArgs vs IRiskValidationPayload\n\n```mermaid\ngraph LR\n    subgraph \"ClientStrategy Context\"\n        StrategyArgs[\"symbol: string<br/>pendingSignal: ISignalDto<br/>strategyName: StrategyName<br/>exchangeName: ExchangeName<br/>currentPrice: number<br/>timestamp: number\"]\n    end\n    \n    subgraph \"IRiskCheckArgs\"\n        CheckArgs[\"symbol<br/>pendingSignal<br/>strategyName<br/>exchangeName<br/>currentPrice<br/>timestamp\"]\n    end\n    \n    subgraph \"ClientRisk.checkSignal()\"\n        LoadActivePos[\"Load active positions<br/>from PersistRiskAdapter\"]\n        CountPos[\"Count activePositionCount\"]\n    end\n    \n    subgraph \"IRiskValidationPayload\"\n        Payload[\"symbol<br/>pendingSignal<br/>strategyName<br/>exchangeName<br/>currentPrice<br/>timestamp<br/>activePositionCount<br/>activePositions[]\"]\n    end\n    \n    subgraph \"Validation Functions\"\n        Validate[\"validate(payload)<br/>Throw or return void\"]\n    end\n    \n    StrategyArgs --> CheckArgs\n    CheckArgs --> LoadActivePos\n    LoadActivePos --> CountPos\n    CountPos --> Payload\n    Payload --> Validate\n    \n    style CheckArgs fill:#e1f5ff,stroke:#333,stroke-width:2px\n    style Payload fill:#fff4e1,stroke:#333,stroke-width:2px\n    style Validate fill:#e8f5e9,stroke:#333,stroke-width:2px\n```\n\n**Key Distinction:**\n- `IRiskCheckArgs` - Input to `checkSignal()` from strategy\n- `IRiskValidationPayload` - Extended payload passed to validation functions, includes `activePositionCount` and `activePositions[]`\n\n**Sources:** [types.d.ts:546-564](), [types.d.ts:588-605](), [src/client/ClientRisk.ts]()\n\n---\n\n## Position Tracking\n\nThe risk system maintains a registry of active positions to enable cross-strategy validation. Positions are tracked in `PersistRiskAdapter` (crash-safe JSON storage) and loaded on demand during risk checks.\n\n### Position Lifecycle\n\n```mermaid\ngraph TB\n    SignalOpened[\"Signal opened<br/>action: opened\"]\n    AddSignal[\"risk.addSignal(symbol, context)<br/>context: strategyName, riskName\"]\n    LoadData[\"PersistRiskAdapter.readRiskData(symbol, riskName)<br/>Returns RiskData | null\"]\n    CreateEntry[\"Create IRiskActivePosition<br/>signal, strategyName, exchangeName, openTimestamp\"]\n    AppendArray[\"Append to positions array\"]\n    Persist[\"PersistRiskAdapter.writeRiskData(symbol, riskName, data)<br/>Atomic JSON write\"]\n    \n    SignalClosed[\"Signal closed<br/>action: closed\"]\n    RemoveSignal[\"risk.removeSignal(symbol, context)\"]\n    LoadData2[\"PersistRiskAdapter.readRiskData(symbol, riskName)\"]\n    FilterArray[\"Filter out position<br/>by signal.id\"]\n    Persist2[\"PersistRiskAdapter.writeRiskData(symbol, riskName, data)<br/>Updated positions array\"]\n    \n    RiskCheck[\"During risk check\"]\n    LoadAllRisks[\"Load all risk data<br/>for symbol\"]\n    FlattenPositions[\"Flatten positions arrays<br/>from all risk profiles\"]\n    CountPositions[\"activePositionCount = positions.length\"]\n    PassToValidation[\"Pass to validation functions\"]\n    \n    SignalOpened --> AddSignal\n    AddSignal --> LoadData\n    LoadData --> CreateEntry\n    CreateEntry --> AppendArray\n    AppendArray --> Persist\n    \n    SignalClosed --> RemoveSignal\n    RemoveSignal --> LoadData2\n    LoadData2 --> FilterArray\n    FilterArray --> Persist2\n    \n    RiskCheck --> LoadAllRisks\n    LoadAllRisks --> FlattenPositions\n    FlattenPositions --> CountPositions\n    CountPositions --> PassToValidation\n    \n    style Persist fill:#e8f5e9,stroke:#333,stroke-width:2px\n    style Persist2 fill:#e8f5e9,stroke:#333,stroke-width:2px\n    style CountPositions fill:#fff4e1,stroke:#333,stroke-width:2px\n```\n\n### RiskData Structure\n\n```typescript\ninterface RiskData {\n  positions: IRiskActivePosition[];  // Array of active positions\n}\n\ninterface IRiskActivePosition {\n  signal: ISignalRow;      // Full signal details\n  strategyName: string;    // Owning strategy\n  exchangeName: string;    // Exchange name\n  openTimestamp: number;   // When position opened (ms)\n}\n```\n\n**Persistence Details:**\n- Storage: `./dump/{symbol}_{riskName}_risk.json`\n- Format: `{ positions: IRiskActivePosition[] }`\n- Atomic writes via `singleshot` pattern\n- Loaded during `checkSignal()` to populate `activePositions`\n\n**Sources:** [src/client/ClientRisk.ts](), [src/classes/Persist.ts](), [types.d.ts:566-577]()\n\n---\n\n## Component Architecture\n\nThe risk system uses dependency injection to route risk checks through memoized `ClientRisk` instances. Strategies reference risk profiles by `riskName`, and `RiskConnectionService` ensures singleton instances per risk profile.\n\n```mermaid\ngraph TB\n    subgraph \"Public API\"\n        AddRisk[\"addRisk(IRiskSchema)<br/>Register risk profile\"]\n    end\n    \n    subgraph \"Schema Registry\"\n        RiskSchemaService[\"RiskSchemaService<br/>Store IRiskSchema by riskName\"]\n    end\n    \n    subgraph \"Validation Service\"\n        RiskValidationService[\"RiskValidationService<br/>Validate schema structure<br/>Memoized checks\"]\n    end\n    \n    subgraph \"Connection Service\"\n        RiskConnectionService[\"RiskConnectionService<br/>Memoized ClientRisk instances<br/>Key: riskName\"]\n    end\n    \n    subgraph \"Client Implementation\"\n        ClientRisk[\"ClientRisk<br/>checkSignal(IRiskCheckArgs)<br/>addSignal(symbol, context)<br/>removeSignal(symbol, context)\"]\n    end\n    \n    subgraph \"Persistence Layer\"\n        PersistRiskAdapter[\"PersistRiskAdapter<br/>readRiskData(symbol, riskName)<br/>writeRiskData(symbol, riskName, data)<br/>File: ./dump/{symbol}_{riskName}_risk.json\"]\n    end\n    \n    subgraph \"Event System\"\n        RiskSubject[\"riskSubject<br/>Emit rejection events<br/>RiskContract payload\"]\n    end\n    \n    subgraph \"Strategy Integration\"\n        StrategySchema[\"IStrategySchema<br/>riskName?: RiskName<br/>riskList?: RiskName[]\"]\n        StrategyConnection[\"StrategyConnectionService<br/>GET_RISK_FN()<br/>MergeRisk for riskList\"]\n        ClientStrategy[\"ClientStrategy<br/>Calls risk.checkSignal()<br/>before signal creation\"]\n    end\n    \n    AddRisk --> RiskValidationService\n    RiskValidationService --> RiskSchemaService\n    \n    StrategySchema --> StrategyConnection\n    StrategyConnection --> RiskConnectionService\n    RiskConnectionService --> ClientRisk\n    \n    ClientRisk --> PersistRiskAdapter\n    ClientRisk --> RiskSubject\n    \n    ClientStrategy --> ClientRisk\n    \n    RiskSchemaService -.->|\"Read schema\"| RiskConnectionService\n    \n    style RiskConnectionService fill:#fff4e1,stroke:#333,stroke-width:3px\n    style ClientRisk fill:#e1f5ff,stroke:#333,stroke-width:2px\n    style PersistRiskAdapter fill:#e8f5e9,stroke:#333,stroke-width:2px\n```\n\n**Key Components:**\n\n| Component | File Path | Purpose |\n|-----------|-----------|---------|\n| `addRisk()` | [src/function/add.ts]() | Public registration API |\n| `RiskSchemaService` | [src/lib/services/schema/RiskSchemaService.ts]() | Schema storage and retrieval |\n| `RiskValidationService` | [src/lib/services/validation/RiskValidationService.ts]() | Schema validation |\n| `RiskConnectionService` | [src/lib/services/connection/RiskConnectionService.ts]() | Memoized ClientRisk factory |\n| `ClientRisk` | [src/client/ClientRisk.ts]() | Risk checking implementation |\n| `PersistRiskAdapter` | [src/classes/Persist.ts]() | Position persistence (JSON) |\n| `riskSubject` | [src/config/emitters.ts:131]() | Rejection event emitter |\n| `MergeRisk` | [src/classes/Risk.ts]() | Multi-risk composition |\n\n**Sources:** [src/lib/services/connection/RiskConnectionService.ts](), [src/client/ClientRisk.ts](), [src/classes/Persist.ts](), [src/lib/services/connection/StrategyConnectionService.ts:27-67]()\n\n---\n\n## Multi-Risk Composition\n\nStrategies can reference multiple risk profiles using `riskList` (array) or combine `riskName` with `riskList`. The `MergeRisk` class executes validations sequentially across all profiles.\n\n### Risk Resolution Logic\n\n```typescript\n// From StrategyConnectionService.ts\nconst GET_RISK_FN = (dto, self) => {\n  const hasRiskName = !!dto.riskName;\n  const hasRiskList = !!(dto.riskList?.length);\n  \n  // No risk management\n  if (!hasRiskName && !hasRiskList) {\n    return NOOP_RISK;\n  }\n  \n  // Single risk profile\n  if (hasRiskName && !hasRiskList) {\n    return self.riskConnectionService.getRisk(dto.riskName);\n  }\n  \n  // Multiple risk profiles (riskList only)\n  if (!hasRiskName && hasRiskList) {\n    return new MergeRisk(\n      dto.riskList.map((riskName) => self.riskConnectionService.getRisk(riskName))\n    );\n  }\n  \n  // Combined (riskName + riskList)\n  return new MergeRisk([\n    self.riskConnectionService.getRisk(dto.riskName),\n    ...dto.riskList.map((riskName) => self.riskConnectionService.getRisk(riskName))\n  ]);\n};\n```\n\n### MergeRisk Behavior\n\n```mermaid\ngraph TB\n    CheckSignal[\"MergeRisk.checkSignal(args)\"]\n    IterateRisks[\"Iterate risks array\"]\n    CallRisk[\"await risks[i].checkSignal(args)\"]\n    CheckResult{\"Result<br/>false?\"}\n    ReturnFalse[\"Return false<br/>Signal rejected\"]\n    NextRisk[\"Next risk profile\"]\n    AllPassed{\"All<br/>passed?\"}\n    ReturnTrue[\"Return true<br/>Signal allowed\"]\n    \n    AddSignal[\"MergeRisk.addSignal(symbol, context)\"]\n    CallAdd[\"await risks[i].addSignal(symbol, context)\"]\n    NextAdd[\"Next risk profile\"]\n    AllAdded{\"All<br/>added?\"}\n    Done[\"Done\"]\n    \n    RemoveSignal[\"MergeRisk.removeSignal(symbol, context)\"]\n    CallRemove[\"await risks[i].removeSignal(symbol, context)\"]\n    NextRemove[\"Next risk profile\"]\n    AllRemoved{\"All<br/>removed?\"}\n    Done2[\"Done\"]\n    \n    CheckSignal --> IterateRisks\n    IterateRisks --> CallRisk\n    CallRisk --> CheckResult\n    CheckResult -->|\"Yes\"| ReturnFalse\n    CheckResult -->|\"No\"| NextRisk\n    NextRisk --> AllPassed\n    AllPassed -->|\"No\"| CallRisk\n    AllPassed -->|\"Yes\"| ReturnTrue\n    \n    AddSignal --> CallAdd\n    CallAdd --> NextAdd\n    NextAdd --> AllAdded\n    AllAdded -->|\"No\"| CallAdd\n    AllAdded -->|\"Yes\"| Done\n    \n    RemoveSignal --> CallRemove\n    CallRemove --> NextRemove\n    NextRemove --> AllRemoved\n    AllRemoved -->|\"No\"| CallRemove\n    AllRemoved -->|\"Yes\"| Done2\n    \n    style ReturnFalse fill:#ffcccc,stroke:#333,stroke-width:2px\n    style ReturnTrue fill:#e8f5e9,stroke:#333,stroke-width:2px\n```\n\n**Usage Example:**\n```typescript\naddStrategy({\n  strategyName: \"multi-risk-strategy\",\n  interval: \"1m\",\n  riskName: \"max-3-positions\",     // Primary risk profile\n  riskList: [\"symbol-filter\", \"time-window\"], // Additional profiles\n  getSignal: async () => { /* ... */ }\n});\n```\n\n**Validation Order:**\n1. `max-3-positions` validations (from `riskName`)\n2. `symbol-filter` validations (from `riskList[0]`)\n3. `time-window` validations (from `riskList[1]`)\n\n**Short-Circuit:** If any validation fails, remaining profiles are not checked and signal is rejected.\n\n**Sources:** [src/lib/services/connection/StrategyConnectionService.ts:33-67](), [src/classes/Risk.ts](), [types.d.ts:949-955]()\n\n---\n\n## Event System Integration\n\nRisk rejections emit events via `riskSubject` for monitoring and alerting. Subscribers can track rejection frequency, reasons, and portfolio state at rejection time.\n\n### Risk Events\n\n```mermaid\ngraph LR\n    subgraph \"ClientRisk\"\n        Validation[\"Validation throws error\"]\n        EmitRejection[\"params.onRejected(symbol, params,<br/>activePositionCount, comment, timestamp)\"]\n    end\n    \n    subgraph \"Event Emitters\"\n        RiskSubject[\"riskSubject.next(RiskContract)\"]\n    end\n    \n    subgraph \"Public Listeners\"\n        ListenRisk[\"listenRisk((event) => void)<br/>Queued async processing\"]\n        ListenRiskOnce[\"listenRiskOnce(filter, callback)<br/>One-time execution\"]\n    end\n    \n    subgraph \"Markdown Service\"\n        RiskMarkdownService[\"RiskMarkdownService<br/>Accumulate rejection events<br/>MAX_EVENTS unbounded\"]\n        GetReport[\"Risk.getReport(riskName)<br/>Generate markdown table\"]\n    end\n    \n    Validation --> EmitRejection\n    EmitRejection --> RiskSubject\n    RiskSubject --> ListenRisk\n    RiskSubject --> ListenRiskOnce\n    RiskSubject --> RiskMarkdownService\n    RiskMarkdownService --> GetReport\n    \n    style RiskSubject fill:#fff4e1,stroke:#333,stroke-width:2px\n    style RiskMarkdownService fill:#e8f5e9,stroke:#333,stroke-width:2px\n```\n\n### RiskContract Structure\n\n```typescript\ninterface RiskContract {\n  symbol: string;              // Trading pair\n  strategyName: string;        // Strategy that was rejected\n  exchangeName: string;        // Exchange name\n  activePositionCount: number; // Portfolio state at rejection\n  comment: string;             // Rejection reason (from validation note or \"N/A\")\n  timestamp: number;           // Event timestamp (ms)\n}\n```\n\n### Listening for Rejections\n\n```typescript\nimport { listenRisk, listenRiskOnce } from \"backtest-kit\";\n\n// Subscribe to all rejections\nconst unsubscribe = listenRisk((event) => {\n  console.log(`Signal rejected: ${event.comment}`);\n  console.log(`Active positions: ${event.activePositionCount}`);\n  console.log(`Strategy: ${event.strategyName}`);\n  // Send alert to monitoring service\n});\n\n// Wait for first rejection on BTCUSDT\nlistenRiskOnce(\n  (event) => event.symbol === \"BTCUSDT\",\n  (event) => console.log(`BTCUSDT rejection: ${event.comment}`)\n);\n```\n\n**Callback Hooks:**\n- `callbacks.onRejected(symbol, params)` - Called when signal rejected (before event emission)\n- `callbacks.onAllowed(symbol, params)` - Called when signal passes all validations\n\n**Sources:** [src/client/ClientRisk.ts](), [src/config/emitters.ts:127-131](), [src/function/event.ts](), [types.d.ts:580-586]()\n\n---\n\n## Risk Statistics and Reporting\n\nThe `RiskMarkdownService` accumulates rejection events to generate statistics reports. Use `Risk.getData()` to retrieve aggregated metrics or `Risk.dump()` to write markdown files.\n\n### Risk Statistics\n\n```typescript\ninterface RiskStatistics {\n  totalRejections: number;       // Total rejection count\n  rejectionsByReason: Map<string, number>; // Group by comment\n  rejectionsByStrategy: Map<string, number>; // Group by strategyName\n  rejectionsBySymbol: Map<string, number>;   // Group by symbol\n  avgActivePositions: number;    // Average positions at rejection\n}\n```\n\n### Report Generation\n\n```typescript\nimport { Risk, listenRisk } from \"backtest-kit\";\n\n// Collect rejection events\nlistenRisk((event) => {\n  // Events are automatically collected by RiskMarkdownService\n});\n\n// After backtest/live execution\nconst stats = await Risk.getData(\"my-risk-profile\");\nconsole.log(`Total rejections: ${stats.totalRejections}`);\n\n// Generate markdown report\nawait Risk.dump(\"my-risk-profile\");\n// Writes to: ./dump/my-risk-profile_risk.md\n```\n\n**Report Contents:**\n- Rejection count by reason\n- Rejection count by strategy\n- Rejection count by symbol\n- Average active positions at rejection\n- Full rejection event table (timestamp, symbol, strategy, reason, positions)\n\n**Sources:** [src/lib/services/markdown/RiskMarkdownService.ts](), [src/classes/Risk.ts](), [test/spec/risk.test.mjs]()\n\n---\n\n## Configuration Parameters\n\nRisk-related global configuration parameters control validation behavior and timeouts.\n\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT` | `number` | `0.5` | Minimum TP distance from priceOpen (%) |\n| `CC_MIN_STOPLOSS_DISTANCE_PERCENT` | `number` | `0.5` | Minimum SL distance from priceOpen (%) |\n| `CC_MAX_STOPLOSS_DISTANCE_PERCENT` | `number` | `20` | Maximum SL distance from priceOpen (%) |\n| `CC_MAX_SIGNAL_LIFETIME_MINUTES` | `number` | `1440` | Maximum signal lifetime (minutes) |\n| `CC_SCHEDULE_AWAIT_MINUTES` | `number` | `120` | Scheduled signal timeout (minutes) |\n\n**Note:** These parameters are enforced by `VALIDATE_SIGNAL_FN()` in `ClientStrategy`, not by risk validations. They define **strategy-level** constraints. Custom risk validations can enforce additional **portfolio-level** constraints.\n\n**Configuration API:**\n```typescript\nimport { setConfig } from \"backtest-kit\";\n\nsetConfig({\n  CC_MIN_TAKEPROFIT_DISTANCE_PERCENT: 1.0,  // Require 1% min TP\n  CC_MAX_SIGNAL_LIFETIME_MINUTES: 720,      // Max 12 hours per signal\n});\n```\n\n**Sources:** [types.d.ts:5-115](), [src/client/ClientStrategy.ts:45-330](), [src/config/params.ts]()\n\n---\n\n## Common Use Cases\n\n### Portfolio Position Limit\n\n```typescript\naddRisk({\n  riskName: \"max-3-positions\",\n  validations: [\n    ({ activePositionCount }) => {\n      if (activePositionCount >= 3) {\n        throw new Error(\"Maximum 3 concurrent positions\");\n      }\n    }\n  ]\n});\n```\n\n### Per-Symbol Position Limit\n\n```typescript\naddRisk({\n  riskName: \"max-1-per-symbol\",\n  validations: [\n    ({ symbol, activePositions }) => {\n      const symbolPositions = activePositions.filter(p => p.signal.symbol === symbol);\n      if (symbolPositions.length >= 1) {\n        throw new Error(`Maximum 1 position for ${symbol}`);\n      }\n    }\n  ]\n});\n```\n\n### Time-Based Trading Window\n\n```typescript\naddRisk({\n  riskName: \"trading-hours\",\n  validations: [\n    ({ timestamp }) => {\n      const hour = new Date(timestamp).getUTCHours();\n      if (hour < 9 || hour > 16) {\n        throw new Error(\"Trading only allowed 09:00-16:00 UTC\");\n      }\n    }\n  ]\n});\n```\n\n### Minimum Risk/Reward Ratio\n\n```typescript\naddRisk({\n  riskName: \"rr-2to1\",\n  validations: [\n    {\n      validate: ({ pendingSignal, currentPrice }) => {\n        const { priceOpen = currentPrice, priceTakeProfit, priceStopLoss, position } = pendingSignal;\n        const reward = position === \"long\" \n          ? priceTakeProfit - priceOpen \n          : priceOpen - priceTakeProfit;\n        const risk = position === \"long\" \n          ? priceOpen - priceStopLoss \n          : priceStopLoss - priceOpen;\n        if (reward / risk < 2) {\n          throw new Error(\"Risk/Reward ratio must be >= 2:1\");\n        }\n      },\n      note: \"R/R ratio validation\"\n    }\n  ]\n});\n```\n\n### Strategy-Specific Limits\n\n```typescript\naddRisk({\n  riskName: \"strategy-limits\",\n  validations: [\n    ({ strategyName, activePositions }) => {\n      const strategyPositions = activePositions.filter(\n        p => p.strategyName === strategyName\n      );\n      if (strategyPositions.length >= 2) {\n        throw new Error(`Strategy ${strategyName} has max 2 positions`);\n      }\n    }\n  ]\n});\n```\n\n**Sources:** [test/e2e/risk.test.mjs:21-127](), [test/e2e/risk.test.mjs:212-317](), [test/e2e/risk.test.mjs:387-463]()"
                    },
                    {
                        "page_plan": {
                            "id": "4.4",
                            "title": "Position Sizing"
                        },
                        "content": "# Position Sizing\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/add.ts](src/function/add.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/function/list.ts](src/function/list.ts)\n- [src/index.ts](src/index.ts)\n- [src/lib/core/provide.ts](src/lib/core/provide.ts)\n- [src/lib/core/types.ts](src/lib/core/types.ts)\n- [src/lib/index.ts](src/lib/index.ts)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\nPosition sizing determines how much capital to allocate to each trading signal. This page documents the position sizing system, including the three built-in sizing methods (fixed-percentage, Kelly Criterion, ATR-based), schema registration, calculation flow, and service architecture.\n\nFor information about risk management and portfolio-level position limits, see [Risk Management](#4.3). For strategy configuration that uses position sizing, see [Defining Strategies](#4.1).\n\n---\n\n## Purpose and Scope\n\nThe position sizing system calculates the quantity of an asset to trade based on:\n- Account balance\n- Risk tolerance\n- Market volatility (for ATR-based sizing)\n- Historical performance (for Kelly Criterion)\n- Price levels (for fixed-percentage sizing)\n\nPosition sizing is configured via `ISizingSchema` and registered using `addSizing()`. Each sizing configuration defines a calculation method and constraints (min/max position size, max position percentage). The framework provides three built-in methods as a discriminated union based on the `method` field.\n\n**Sources:** [types.d.ts:849-1085]()\n\n---\n\n## Position Sizing Methods\n\nThe framework provides three position sizing methods, each suited for different risk management philosophies:\n\n### Method Comparison\n\n| Method | Description | Formula | Best For |\n|--------|-------------|---------|----------|\n| `fixed-percentage` | Risk fixed % of account per trade | `(Balance × Risk%) / (Entry - StopLoss)` | Conservative, consistent risk |\n| `kelly-criterion` | Optimal sizing based on edge | `Balance × Kelly% × Multiplier` | Statistical edge exploitation |\n| `atr-based` | Volatility-adjusted sizing | `(Balance × Risk%) / (ATR × Multiplier)` | Adapting to market conditions |\n\n### Fixed Percentage Sizing\n\nRisks a fixed percentage of account balance per trade. Position size is calculated based on the distance between entry price and stop loss.\n\n**Formula:**\n```\nPosition Size = (Account Balance × Risk %) / (Entry Price - Stop Loss Price)\n```\n\n**Parameters:**\n- `riskPercentage`: Percentage of account to risk (e.g., `1` = 1%)\n- `maxPositionPercentage`: Optional cap on position size\n- `minPositionSize` / `maxPositionSize`: Optional absolute constraints\n\n**Example:**\n```\nAccount: $10,000\nRisk: 1%\nEntry: $50,000\nStop Loss: $49,000\nPosition Size = ($10,000 × 0.01) / ($50,000 - $49,000) = 0.1 BTC\n```\n\n**Sources:** [types.d.ts:875-897]()\n\n### Kelly Criterion Sizing\n\nCalculates optimal position size based on historical win rate and risk/reward ratio. Uses a multiplier (typically 0.25 for quarter-Kelly) to reduce variance.\n\n**Formula:**\n```\nKelly % = (Win Rate × Win Size - Loss Rate × Loss Size) / Win Size\nPosition Size = Account Balance × Kelly % × Kelly Multiplier\n```\n\n**Parameters:**\n- `kellyMultiplier`: Conservative multiplier (default: `0.25` for quarter-Kelly)\n- `maxPositionPercentage`: Optional cap on position size\n- `minPositionSize` / `maxPositionSize`: Optional absolute constraints\n\n**Calculation requires:**\n- `winRate`: Historical win rate (0.0-1.0)\n- `averageWin`: Average win size multiplier\n- `averageLoss`: Average loss size multiplier\n\n**Example:**\n```\nAccount: $10,000\nWin Rate: 60% (0.6)\nAverage Win: 1.5x\nAverage Loss: 1.0x\nKelly Multiplier: 0.25 (quarter-Kelly)\n\nKelly % = (0.6 × 1.5 - 0.4 × 1.0) / 1.5 = 0.333\nPosition = $10,000 × 0.333 × 0.25 = $833\n```\n\n**Sources:** [types.d.ts:899-922]()\n\n### ATR-Based Sizing\n\nSizes positions based on Average True Range (volatility indicator). Higher volatility results in smaller positions, lower volatility in larger positions.\n\n**Formula:**\n```\nPosition Size = (Account Balance × Risk %) / (ATR × ATR Multiplier)\n```\n\n**Parameters:**\n- `riskPercentage`: Percentage of account to risk per trade\n- `atrMultiplier`: Stop loss distance in ATRs (default: `2`)\n- `maxPositionPercentage`: Optional cap on position size\n- `minPositionSize` / `maxPositionSize`: Optional absolute constraints\n\n**Example:**\n```\nAccount: $10,000\nRisk: 2%\nATR: $500\nATR Multiplier: 2× (stop loss at 2× ATR)\n\nPosition Size = ($10,000 × 0.02) / ($500 × 2) = 0.2 BTC\n```\n\n**Sources:** [types.d.ts:924-949]()\n\n---\n\n## Schema Definition and Registration\n\n### ISizingSchema Discriminated Union\n\nThe sizing schema uses a discriminated union based on the `method` field. TypeScript enforces type safety, ensuring only valid parameters are provided for each method.\n\n```mermaid\ngraph TB\n    subgraph \"ISizingSchema Discriminated Union\"\n        SCHEMA[\"ISizingSchema<br/>(Union Type)\"]\n        FIXED[\"ISizingSchemaFixedPercentage<br/>method: 'fixed-percentage'\"]\n        KELLY[\"ISizingSchemaKelly<br/>method: 'kelly-criterion'\"]\n        ATR[\"ISizingSchemaATR<br/>method: 'atr-based'\"]\n    end\n    \n    subgraph \"Fixed Percentage Fields\"\n        F_NAME[\"sizingName: SizingName\"]\n        F_METHOD[\"method: 'fixed-percentage'\"]\n        F_RISK[\"riskPercentage: number\"]\n        F_MAX[\"maxPositionPercentage?: number\"]\n        F_MIN[\"minPositionSize?: number\"]\n        F_MAX_ABS[\"maxPositionSize?: number\"]\n        F_CB[\"callbacks?: Partial&lt;ISizingCallbacks&gt;\"]\n    end\n    \n    subgraph \"Kelly Criterion Fields\"\n        K_NAME[\"sizingName: SizingName\"]\n        K_METHOD[\"method: 'kelly-criterion'\"]\n        K_MULT[\"kellyMultiplier?: number<br/>default: 0.25\"]\n        K_MAX[\"maxPositionPercentage?: number\"]\n        K_MIN[\"minPositionSize?: number\"]\n        K_MAX_ABS[\"maxPositionSize?: number\"]\n        K_CB[\"callbacks?: Partial&lt;ISizingCallbacks&gt;\"]\n    end\n    \n    subgraph \"ATR-Based Fields\"\n        A_NAME[\"sizingName: SizingName\"]\n        A_METHOD[\"method: 'atr-based'\"]\n        A_RISK[\"riskPercentage: number\"]\n        A_MULT[\"atrMultiplier?: number<br/>default: 2\"]\n        A_MAX[\"maxPositionPercentage?: number\"]\n        A_MIN[\"minPositionSize?: number\"]\n        A_MAX_ABS[\"maxPositionSize?: number\"]\n        A_CB[\"callbacks?: Partial&lt;ISizingCallbacks&gt;\"]\n    end\n    \n    SCHEMA --> FIXED\n    SCHEMA --> KELLY\n    SCHEMA --> ATR\n    \n    FIXED --> F_NAME\n    FIXED --> F_METHOD\n    FIXED --> F_RISK\n    FIXED --> F_MAX\n    FIXED --> F_MIN\n    FIXED --> F_MAX_ABS\n    FIXED --> F_CB\n    \n    KELLY --> K_NAME\n    KELLY --> K_METHOD\n    KELLY --> K_MULT\n    KELLY --> K_MAX\n    KELLY --> K_MIN\n    KELLY --> K_MAX_ABS\n    KELLY --> K_CB\n    \n    ATR --> A_NAME\n    ATR --> A_METHOD\n    ATR --> A_RISK\n    ATR --> A_MULT\n    ATR --> A_MAX\n    ATR --> A_MIN\n    ATR --> A_MAX_ABS\n    ATR --> A_CB\n```\n\n**Sources:** [types.d.ts:849-949]()\n\n### Registration with addSizing()\n\nSizing configurations are registered via `addSizing()`, which validates the schema and stores it in `SizingSchemaService`.\n\n**Function Signature:**\n```typescript\nfunction addSizing(sizingSchema: ISizingSchema): void\n```\n\n**Validation Steps:**\n1. `SizingValidationService.addSizing()` validates schema structure\n2. `SizingSchemaService.register()` stores configuration for retrieval\n\n**Example Registrations:**\n\n```typescript\n// Fixed percentage: Risk 1% per trade\naddSizing({\n  sizingName: \"conservative\",\n  method: \"fixed-percentage\",\n  riskPercentage: 1,\n  maxPositionPercentage: 10,\n  minPositionSize: 0.001,\n  callbacks: {\n    onCalculate: (quantity, params) => {\n      console.log(`Conservative sizing: ${quantity}`);\n    }\n  }\n});\n\n// Kelly Criterion: Quarter-Kelly with 20% max position\naddSizing({\n  sizingName: \"kelly-optimal\",\n  method: \"kelly-criterion\",\n  kellyMultiplier: 0.25,\n  maxPositionPercentage: 20,\n});\n\n// ATR-based: 2% risk with 2× ATR stop\naddSizing({\n  sizingName: \"atr-dynamic\",\n  method: \"atr-based\",\n  riskPercentage: 2,\n  atrMultiplier: 2,\n  maxPositionSize: 1.0,\n});\n```\n\n**Sources:** [src/function/add.ts:256-268](), [types.d.ts:849-949]()\n\n---\n\n## Calculation Parameters\n\n### ISizingCalculateParams\n\nThe `calculate()` method accepts `ISizingCalculateParams`, which contains:\n- `symbol`: Trading pair (e.g., `\"BTCUSDT\"`)\n- `accountBalance`: Current account balance in quote currency\n- `params`: Method-specific parameters (discriminated union)\n\n### Method-Specific Parameters\n\nEach sizing method requires different calculation inputs:\n\n#### Fixed Percentage Parameters\n\n```typescript\ninterface ISizingCalculateParamsFixedPercentage {\n  method: \"fixed-percentage\";\n  entryPrice: number;      // Entry price for position\n  stopLossPrice: number;   // Stop loss price\n}\n```\n\n**Used for:** Risk-per-trade calculation based on price distance\n\n#### Kelly Criterion Parameters\n\n```typescript\ninterface ISizingCalculateParamsKelly {\n  method: \"kelly-criterion\";\n  winRate: number;         // Historical win rate (0.0-1.0)\n  averageWin: number;      // Average win multiplier\n  averageLoss: number;     // Average loss multiplier\n}\n```\n\n**Used for:** Statistical edge-based sizing\n\n#### ATR-Based Parameters\n\n```typescript\ninterface ISizingCalculateParamsATR {\n  method: \"atr-based\";\n  atr: number;             // Current Average True Range\n}\n```\n\n**Used for:** Volatility-adjusted sizing\n\n**Sources:** [types.d.ts:951-1007]()\n\n---\n\n## Service Architecture\n\n### Position Sizing Service Dependencies\n\n```mermaid\ngraph TB\n    subgraph \"Public API\"\n        ADD_SIZING[\"addSizing()<br/>src/function/add.ts\"]\n        POSITION_SIZE[\"PositionSize.calculate()<br/>src/classes/PositionSize.ts\"]\n    end\n    \n    subgraph \"Validation Layer\"\n        SIZING_VAL[\"SizingValidationService<br/>Validates schema structure\"]\n    end\n    \n    subgraph \"Schema Layer\"\n        SIZING_SCHEMA[\"SizingSchemaService<br/>ToolRegistry pattern<br/>Stores ISizingSchema\"]\n    end\n    \n    subgraph \"Connection Layer\"\n        SIZING_CONN[\"SizingConnectionService<br/>Memoized factory<br/>Key: sizingName\"]\n    end\n    \n    subgraph \"Client Layer\"\n        CLIENT_SIZING[\"ClientSizing<br/>Implements ISizing<br/>calculate() logic\"]\n    end\n    \n    subgraph \"Global Layer\"\n        SIZING_GLOBAL[\"SizingGlobalService<br/>Orchestrates calculation<br/>Injects ExecutionContext\"]\n    end\n    \n    subgraph \"Strategy Integration\"\n        STRATEGY[\"ClientStrategy<br/>Uses sizing for signals\"]\n        STRATEGY_SCHEMA[\"IStrategySchema<br/>Optional sizingName field\"]\n    end\n    \n    ADD_SIZING --> SIZING_VAL\n    ADD_SIZING --> SIZING_SCHEMA\n    SIZING_VAL --> SIZING_SCHEMA\n    \n    POSITION_SIZE --> SIZING_GLOBAL\n    SIZING_GLOBAL --> SIZING_CONN\n    SIZING_CONN --> SIZING_SCHEMA\n    SIZING_CONN --> CLIENT_SIZING\n    \n    CLIENT_SIZING -.->|\"reads config\"| SIZING_SCHEMA\n    CLIENT_SIZING -.->|\"calls onCalculate\"| SIZING_SCHEMA\n    \n    STRATEGY --> SIZING_GLOBAL\n    STRATEGY_SCHEMA -.->|\"references\"| SIZING_SCHEMA\n```\n\n**Sources:** [src/lib/index.ts:1-242](), [src/lib/core/types.ts:1-104](), [src/lib/core/provide.ts:1-141]()\n\n### Memoization in SizingConnectionService\n\n`SizingConnectionService` caches `ClientSizing` instances by `sizingName` to avoid redundant instantiation:\n\n**Memoization Key:**\n```\nsizingName (e.g., \"conservative\", \"kelly-optimal\")\n```\n\n**Cache Behavior:**\n- First call creates new `ClientSizing` instance\n- Subsequent calls with same `sizingName` return cached instance\n- Each instance reads configuration from `SizingSchemaService`\n\n**Sources:** [src/lib/core/types.ts:14](), [src/lib/core/provide.ts:68]()\n\n---\n\n## Calculation Flow\n\n### Position Size Calculation Sequence\n\n```mermaid\nsequenceDiagram\n    participant User as User Code\n    participant PS as PositionSize.calculate()\n    participant SG as SizingGlobalService\n    participant SC as SizingConnectionService\n    participant CS as ClientSizing\n    participant SS as SizingSchemaService\n    participant CB as ISizingCallbacks\n    \n    User->>PS: calculate(symbol, sizingName, accountBalance, params)\n    PS->>SG: calculate(symbol, sizingName, accountBalance, params)\n    \n    Note over SG: Wraps in ExecutionContextService\n    \n    SG->>SC: getSizing(sizingName)\n    SC->>SS: get(sizingName)\n    SS-->>SC: ISizingSchema\n    \n    alt \"Cache Hit\"\n        SC-->>SG: Cached ClientSizing\n    else \"Cache Miss\"\n        SC->>CS: new ClientSizing(schema, logger)\n        CS-->>SC: ClientSizing instance\n        SC-->>SG: New ClientSizing (cached)\n    end\n    \n    SG->>CS: calculate(params)\n    \n    alt \"Fixed Percentage\"\n        Note over CS: (Balance × Risk%) / (Entry - StopLoss)\n    else \"Kelly Criterion\"\n        Note over CS: Balance × Kelly% × Multiplier\n    else \"ATR-Based\"\n        Note over CS: (Balance × Risk%) / (ATR × Multiplier)\n    end\n    \n    Note over CS: Apply constraints<br/>(min/max position size,<br/>max position %)\n    \n    CS->>CB: onCalculate(quantity, params)\n    CB-->>CS: void\n    \n    CS-->>SG: calculated quantity\n    SG-->>PS: quantity\n    PS-->>User: quantity\n```\n\n**Sources:** [types.d.ts:1009-1085]()\n\n### Constraint Application\n\nAfter calculating the base position size, `ClientSizing` applies constraints in this order:\n\n1. **Max Position Percentage:**\n   ```typescript\n   if (maxPositionPercentage) {\n     maxAllowed = accountBalance * (maxPositionPercentage / 100);\n     quantity = Math.min(quantity, maxAllowed);\n   }\n   ```\n\n2. **Min Position Size:**\n   ```typescript\n   if (minPositionSize && quantity < minPositionSize) {\n     quantity = minPositionSize;\n   }\n   ```\n\n3. **Max Position Size:**\n   ```typescript\n   if (maxPositionSize && quantity > maxPositionSize) {\n     quantity = maxPositionSize;\n   }\n   ```\n\n**Sources:** [types.d.ts:875-949]()\n\n---\n\n## Integration with Strategy System\n\n### Strategy Schema Configuration\n\nStrategies can optionally reference a sizing configuration:\n\n```typescript\ninterface IStrategySchema {\n  strategyName: StrategyName;\n  interval: SignalInterval;\n  getSignal: (symbol: string, when: Date) => Promise<ISignalDto | null>;\n  \n  // Optional sizing configuration\n  sizingName?: SizingName;\n  \n  // Alternative: multiple sizing configs\n  sizingList?: SizingName[];\n  \n  // Other fields...\n}\n```\n\n**Usage Pattern:**\n- If `sizingName` is specified, strategy uses that sizing config\n- If `sizingList` is specified, strategy can select from multiple configs\n- If neither specified, strategy must calculate position size manually\n\n**Sources:** [types.d.ts:932-955]()\n\n### Position Size Calculation in Strategy\n\nStrategies typically calculate position size during signal generation or validation:\n\n```typescript\n// In getSignal callback\nconst sizing = await PositionSize.calculate(\n  symbol,\n  \"conservative\", // sizingName\n  accountBalance,\n  {\n    method: \"fixed-percentage\",\n    entryPrice: 50000,\n    stopLossPrice: 49000\n  }\n);\n\n// Return signal with calculated quantity\nreturn {\n  position: \"long\",\n  priceOpen: 50000,\n  priceTakeProfit: 51000,\n  priceStopLoss: 49000,\n  minuteEstimatedTime: 60,\n  quantity: sizing  // Use calculated quantity\n};\n```\n\n**Sources:** [types.d.ts:849-1085]()\n\n---\n\n## PositionSize Class API\n\n### Public Methods\n\nThe `PositionSize` class provides a high-level API for position size calculation:\n\n**Method Signature:**\n```typescript\nclass PositionSize {\n  static calculate(\n    symbol: string,\n    sizingName: SizingName,\n    accountBalance: number,\n    params: ISizingCalculateParamsFixedPercentage | \n           ISizingCalculateParamsKelly | \n           ISizingCalculateParamsATR\n  ): Promise<number>\n}\n```\n\n**Parameters:**\n- `symbol`: Trading pair (e.g., `\"BTCUSDT\"`)\n- `sizingName`: Registered sizing configuration name\n- `accountBalance`: Current account balance in quote currency\n- `params`: Method-specific calculation parameters\n\n**Returns:** Calculated position size in base currency units\n\n**Example Usage:**\n\n```typescript\nimport { PositionSize, addSizing } from \"backtest-kit\";\n\n// Register sizing configuration\naddSizing({\n  sizingName: \"my-sizing\",\n  method: \"fixed-percentage\",\n  riskPercentage: 1,\n  maxPositionPercentage: 10\n});\n\n// Calculate position size\nconst quantity = await PositionSize.calculate(\n  \"BTCUSDT\",\n  \"my-sizing\",\n  10000, // $10,000 account\n  {\n    method: \"fixed-percentage\",\n    entryPrice: 50000,\n    stopLossPrice: 49000\n  }\n);\n\nconsole.log(`Position size: ${quantity} BTC`);\n// Position size: 0.1 BTC\n```\n\n**Sources:** [src/index.ts:184](), [types.d.ts:849-1085]()\n\n---\n\n## Complete Example\n\n### Full Position Sizing Configuration\n\n```typescript\nimport { \n  addSizing, \n  addStrategy,\n  PositionSize,\n  ISizingCalculateParams \n} from \"backtest-kit\";\n\n// 1. Register multiple sizing configurations\naddSizing({\n  sizingName: \"conservative\",\n  method: \"fixed-percentage\",\n  riskPercentage: 1,\n  maxPositionPercentage: 5,\n  minPositionSize: 0.001,\n  callbacks: {\n    onCalculate: (quantity, params) => {\n      console.log(`[Conservative] Size: ${quantity} for ${params.symbol}`);\n    }\n  }\n});\n\naddSizing({\n  sizingName: \"aggressive-kelly\",\n  method: \"kelly-criterion\",\n  kellyMultiplier: 0.5, // Half-Kelly (more aggressive than quarter-Kelly)\n  maxPositionPercentage: 25,\n  callbacks: {\n    onCalculate: (quantity, params) => {\n      console.log(`[Kelly] Size: ${quantity}`);\n    }\n  }\n});\n\naddSizing({\n  sizingName: \"volatility-adjusted\",\n  method: \"atr-based\",\n  riskPercentage: 2,\n  atrMultiplier: 1.5,\n  maxPositionSize: 0.5,\n});\n\n// 2. Use in strategy\naddStrategy({\n  strategyName: \"my-strategy\",\n  interval: \"5m\",\n  sizingName: \"conservative\", // Reference sizing config\n  \n  getSignal: async (symbol, when) => {\n    // Fetch data for decision making\n    const candles = await getCandles(symbol, \"1h\", 100);\n    const atr = calculateATR(candles);\n    const entryPrice = candles[candles.length - 1].close;\n    const stopLossPrice = entryPrice - (atr * 2);\n    \n    // Calculate position size\n    const accountBalance = 10000;\n    const quantity = await PositionSize.calculate(\n      symbol,\n      \"conservative\",\n      accountBalance,\n      {\n        method: \"fixed-percentage\",\n        entryPrice,\n        stopLossPrice\n      }\n    );\n    \n    // Generate signal with calculated size\n    if (shouldEnterLong(candles)) {\n      return {\n        position: \"long\",\n        priceOpen: entryPrice,\n        priceTakeProfit: entryPrice + (atr * 3),\n        priceStopLoss: stopLossPrice,\n        minuteEstimatedTime: 60,\n        quantity, // Use calculated quantity\n        note: `ATR: ${atr}, Quantity: ${quantity}`\n      };\n    }\n    \n    return null;\n  }\n});\n\n// 3. Alternative: Calculate at runtime without strategy reference\nasync function calculatePositionForTrade(\n  symbol: string,\n  accountBalance: number,\n  historicalStats: { winRate: number, avgWin: number, avgLoss: number }\n) {\n  // Use Kelly Criterion for sizing\n  const quantity = await PositionSize.calculate(\n    symbol,\n    \"aggressive-kelly\",\n    accountBalance,\n    {\n      method: \"kelly-criterion\",\n      winRate: historicalStats.winRate,\n      averageWin: historicalStats.avgWin,\n      averageLoss: historicalStats.avgLoss\n    }\n  );\n  \n  return quantity;\n}\n```\n\n**Sources:** [src/function/add.ts:256-268](), [types.d.ts:849-1085]()\n\n---\n\n## Summary\n\nThe position sizing system provides three calculation methods through a discriminated union interface:\n\n| Component | Purpose | Key Files |\n|-----------|---------|-----------|\n| `ISizingSchema` | Schema definition (discriminated union) | [types.d.ts:849-949]() |\n| `addSizing()` | Registration function | [src/function/add.ts:256-268]() |\n| `SizingValidationService` | Schema validation | [src/lib/core/types.ts:78]() |\n| `SizingSchemaService` | Configuration storage | [src/lib/core/types.ts:25]() |\n| `SizingConnectionService` | Memoized client factory | [src/lib/core/types.ts:14]() |\n| `ClientSizing` | Calculation implementation | Referenced in architecture |\n| `SizingGlobalService` | Orchestration with context | [src/lib/core/types.ts:37]() |\n| `PositionSize` | Public API class | [src/index.ts:184]() |\n\n**Key Features:**\n- Three sizing methods: fixed-percentage, kelly-criterion, atr-based\n- Discriminated union ensures type-safe parameter passing\n- Constraint application (min/max size, max position %)\n- Memoized client instances by `sizingName`\n- Optional callbacks for calculation events\n- Integration with strategy system via `sizingName` field\n\n**Sources:** [types.d.ts:849-1085](), [src/index.ts:89-101,184](), [src/function/add.ts:256-268]()"
                    },
                    {
                        "page_plan": {
                            "id": "5",
                            "title": "Execution Modes (Detailed)"
                        },
                        "content": "# Execution Modes (Detailed)\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [assets/uml.svg](assets/uml.svg)\n- [docs/classes/WalkerCommandService.md](docs/classes/WalkerCommandService.md)\n- [docs/interfaces/BacktestStatistics.md](docs/interfaces/BacktestStatistics.md)\n- [docs/interfaces/IStrategyCallbacks.md](docs/interfaces/IStrategyCallbacks.md)\n- [docs/interfaces/LiveStatistics.md](docs/interfaces/LiveStatistics.md)\n- [docs/internals.md](docs/internals.md)\n- [docs/types/IStrategyTickResult.md](docs/types/IStrategyTickResult.md)\n- [docs/uml.puml](docs/uml.puml)\n- [scripts/uml.mjs](scripts/uml.mjs)\n- [src/classes/Backtest.ts](src/classes/Backtest.ts)\n- [src/classes/Live.ts](src/classes/Live.ts)\n- [src/classes/Walker.ts](src/classes/Walker.ts)\n- [src/lib/services/logic/private/BacktestLogicPrivateService.ts](src/lib/services/logic/private/BacktestLogicPrivateService.ts)\n- [src/lib/services/logic/private/LiveLogicPrivateService.ts](src/lib/services/logic/private/LiveLogicPrivateService.ts)\n- [src/lib/services/logic/private/WalkerLogicPrivateService.ts](src/lib/services/logic/private/WalkerLogicPrivateService.ts)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis page provides comprehensive documentation of the four execution modes implemented in backtest-kit: **Backtest**, **Live**, **Walker**, and **Optimizer**. Each mode orchestrates trading strategy execution with distinct architectural patterns, data flows, and performance characteristics. This document details the internal implementation of each mode, including the service layer architecture, async generator patterns, and state management.\n\nFor a high-level comparison of when to use each mode, see [Execution Modes Overview](#2.2). For strategy definition and signal lifecycle concepts, see [Signal Lifecycle and State Machine](#2.1).\n\n## Execution Mode Architecture\n\nAll four execution modes follow a consistent architectural pattern with three primary layers:\n\n| Layer | Components | Responsibilities |\n|-------|-----------|------------------|\n| **Public API** | `Backtest`, `Live`, `Walker`, `Optimizer` classes | User-facing singleton instances with validation |\n| **Instance Management** | `BacktestInstance`, `LiveInstance`, `WalkerInstance` | Memoized per-symbol execution contexts |\n| **Command Services** | `BacktestCommandService`, `LiveCommandService`, `WalkerCommandService` | Dependency injection and context propagation |\n| **Logic Services** | `BacktestLogicPublicService/Private`, `LiveLogicPublicService/Private`, `WalkerLogicPublicService/Private` | Core execution logic with async generators |\n| **Core Services** | `StrategyCoreService`, `ExchangeCoreService`, `FrameCoreService` | Domain business logic |\n\n**Sources:** [src/classes/Backtest.ts:1-594](), [src/classes/Live.ts:1-607](), [src/classes/Walker.ts:1-678](), [docs/internals.md:28-39]()\n\n---\n\n## Backtest Mode\n\n### Architecture Overview\n\n```mermaid\ngraph TB\n    subgraph \"Public API Layer\"\n        BT[\"Backtest (singleton)\"]\n        BTI[\"BacktestInstance (memoized)\"]\n    end\n    \n    subgraph \"Service Layer\"\n        CMD[\"BacktestCommandService\"]\n        PUB[\"BacktestLogicPublicService\"]\n        PRIV[\"BacktestLogicPrivateService\"]\n    end\n    \n    subgraph \"Core Services\"\n        STRAT[\"StrategyCoreService\"]\n        EXCH[\"ExchangeCoreService\"]\n        FRAME[\"FrameCoreService\"]\n    end\n    \n    subgraph \"Context Services\"\n        MCTX[\"MethodContextService\"]\n        ECTX[\"ExecutionContextService\"]\n    end\n    \n    BT -->|\"run(symbol, context)\"| BTI\n    BTI -->|\"validate + run()\"| CMD\n    CMD -->|\"context propagation\"| MCTX\n    CMD -->|\"async generator\"| PUB\n    PUB -->|\"async generator\"| PRIV\n    \n    PRIV -->|\"getTimeframe()\"| FRAME\n    PRIV -->|\"tick(symbol, when, true)\"| STRAT\n    PRIV -->|\"backtest(symbol, candles)\"| STRAT\n    PRIV -->|\"getNextCandles()\"| EXCH\n    \n    MCTX -->|\"strategyName, exchangeName, frameName\"| PRIV\n    ECTX -->|\"symbol, when, backtest=true\"| STRAT\n```\n\n**Diagram: Backtest Mode Service Dependencies**\n\n**Sources:** [src/classes/Backtest.ts:335-555](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:1-481]()\n\n### Public API Entry Points\n\nThe `Backtest` singleton provides the primary interface for backtest operations:\n\n```typescript\n// From Backtest.ts\nBacktest.run(symbol: string, context: {\n  strategyName: string,\n  exchangeName: string,\n  frameName: string\n}) -> AsyncGenerator<IStrategyBacktestResult>\n\nBacktest.background(symbol, context) -> CancellationFunction\nBacktest.stop(symbol, strategyName) -> Promise<void>\nBacktest.getData(symbol, strategyName) -> Promise<BacktestStatistics>\n```\n\nEach symbol-strategy pair is managed by a memoized `BacktestInstance` (keyed by `\"${symbol}:${strategyName}\"`), ensuring isolated state and preventing duplicate executions.\n\n**Sources:** [src/classes/Backtest.ts:355-396](), [src/classes/Backtest.ts:360-365]()\n\n### Execution Flow\n\n```mermaid\ngraph TD\n    START[\"Backtest.run()\"]\n    VALIDATE[\"Validate strategy, exchange, frame, risk\"]\n    INSTANCE[\"Get/Create BacktestInstance\"]\n    CLEAR[\"Clear markdown services & strategy state & risk state\"]\n    COMMAND[\"BacktestCommandService.run()\"]\n    \n    FRAME[\"FrameCoreService.getTimeframe()\"]\n    LOOP[\"For each timeframe\"]\n    PROGRESS[\"Emit progressBacktestEmitter\"]\n    \n    TICK[\"StrategyCoreService.tick(when, backtest=true)\"]\n    CHECK_RESULT{\"result.action?\"}\n    \n    IDLE[\"action: idle\"]\n    SCHEDULED[\"action: scheduled\"]\n    OPENED[\"action: opened\"]\n    \n    FETCH_SCHED[\"getNextCandles(CC_SCHEDULE_AWAIT_MINUTES + minuteEstimatedTime + buffer)\"]\n    BACKTEST_SCHED[\"StrategyCoreService.backtest() - handle activation/cancellation\"]\n    \n    FETCH_OPEN[\"getNextCandles(minuteEstimatedTime + buffer)\"]\n    BACKTEST[\"StrategyCoreService.backtest() - TP/SL monitoring\"]\n    \n    SKIP[\"Skip timeframes until closeTimestamp\"]\n    YIELD[\"Yield closed result\"]\n    \n    CHECK_STOP{\"getStopped()?\"}\n    BREAK[\"Break loop\"]\n    NEXT[\"i++\"]\n    \n    DONE[\"Emit doneBacktestSubject\"]\n    END[\"End generator\"]\n    \n    START --> VALIDATE\n    VALIDATE --> INSTANCE\n    INSTANCE --> CLEAR\n    CLEAR --> COMMAND\n    COMMAND --> FRAME\n    FRAME --> LOOP\n    \n    LOOP --> PROGRESS\n    PROGRESS --> CHECK_STOP\n    CHECK_STOP -->|\"Yes & Idle\"| BREAK\n    CHECK_STOP -->|\"No\"| TICK\n    \n    TICK --> CHECK_RESULT\n    CHECK_RESULT -->|\"idle\"| IDLE\n    CHECK_RESULT -->|\"scheduled\"| SCHEDULED\n    CHECK_RESULT -->|\"opened\"| OPENED\n    \n    SCHEDULED --> FETCH_SCHED\n    FETCH_SCHED --> BACKTEST_SCHED\n    BACKTEST_SCHED --> SKIP\n    \n    OPENED --> FETCH_OPEN\n    FETCH_OPEN --> BACKTEST\n    BACKTEST --> SKIP\n    \n    SKIP --> YIELD\n    YIELD --> CHECK_STOP\n    \n    IDLE --> NEXT\n    NEXT --> LOOP\n    \n    BREAK --> DONE\n    DONE --> END\n```\n\n**Diagram: Backtest Execution Flow with Signal Type Handling**\n\n**Sources:** [src/lib/services/logic/private/BacktestLogicPrivateService.ts:62-477]()\n\n### Timeframe Iteration and Skip Optimization\n\nThe backtest mode uses pre-generated timeframes from `FrameCoreService.getTimeframe()`, which returns an array of `Date` objects based on the frame configuration. The main optimization technique is **skip-to-close**:\n\n1. **Initial tick:** Call `StrategyCoreService.tick(when, backtest=true)` at each timeframe\n2. **Signal opened/scheduled:** When a signal opens, fetch all required candles at once:\n   - For scheduled signals: `CC_SCHEDULE_AWAIT_MINUTES + minuteEstimatedTime + buffer` candles\n   - For opened signals: `minuteEstimatedTime + buffer` candles\n   - Buffer = `CC_AVG_PRICE_CANDLES_COUNT - 1` for VWAP calculation\n3. **Fast processing:** Call `backtest(candles)` which processes all candles in memory without individual ticks\n4. **Skip timeframes:** Advance loop counter `i` to skip all timeframes before `closeTimestamp`\n5. **Yield result:** Emit closed signal result immediately\n\nThis pattern eliminates redundant tick calls during active signal monitoring, reducing execution time by orders of magnitude for strategies with long signal lifetimes.\n\n**Sources:** [src/lib/services/logic/private/BacktestLogicPrivateService.ts:154-301](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:304-431]()\n\n### BacktestLogicPrivateService Implementation\n\nThe core logic is implemented as an async generator in `BacktestLogicPrivateService.run()`:\n\n```typescript\n// From BacktestLogicPrivateService.ts:62-477\npublic async *run(symbol: string) {\n  const timeframes = await this.frameCoreService.getTimeframe(symbol, frameName);\n  let i = 0;\n  \n  while (i < timeframes.length) {\n    const when = timeframes[i];\n    \n    // Emit progress event\n    await progressBacktestEmitter.next({...});\n    \n    // Check stop flag before processing\n    if (await this.strategyCoreService.getStopped(symbol, strategyName)) {\n      break;\n    }\n    \n    const result = await this.strategyCoreService.tick(symbol, when, true);\n    \n    // Handle scheduled signals\n    if (result.action === \"scheduled\") {\n      const candles = await this.exchangeCoreService.getNextCandles(...);\n      const backtestResult = await this.strategyCoreService.backtest(symbol, candles, when, true);\n      \n      // Skip to close timestamp\n      while (i < timeframes.length && timeframes[i].getTime() < backtestResult.closeTimestamp) {\n        i++;\n      }\n      \n      yield backtestResult;\n    }\n    \n    // Handle opened signals (similar pattern)\n    if (result.action === \"opened\") { ... }\n    \n    i++;\n  }\n}\n```\n\nKey implementation details:\n\n- **Error handling:** Tick and backtest failures emit to `errorEmitter` and skip the timeframe\n- **Performance tracking:** Emits to `performanceEmitter` for signal and timeframe durations\n- **Stop checks:** Multiple stop points (before tick, after idle, after closed) for graceful shutdown\n- **Progress reporting:** Emits `progressBacktestEmitter` with `processedFrames / totalFrames`\n\n**Sources:** [src/lib/services/logic/private/BacktestLogicPrivateService.ts:62-477](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:114-129]()\n\n### Scheduled Signal Handling\n\nScheduled signals (delayed entry orders) require special handling in backtest mode:\n\n```typescript\n// From BacktestLogicPrivateService.ts:154-301\nif (result.action === \"scheduled\") {\n  const signal = result.signal;\n  \n  // Calculate candles needed:\n  // - Buffer for VWAP (CC_AVG_PRICE_CANDLES_COUNT - 1)\n  // - Await period (CC_SCHEDULE_AWAIT_MINUTES)\n  // - Signal lifetime (minuteEstimatedTime)\n  const bufferMinutes = GLOBAL_CONFIG.CC_AVG_PRICE_CANDLES_COUNT - 1;\n  const bufferStartTime = new Date(when.getTime() - bufferMinutes * 60 * 1000);\n  const candlesNeeded = bufferMinutes + GLOBAL_CONFIG.CC_SCHEDULE_AWAIT_MINUTES + signal.minuteEstimatedTime + 1;\n  \n  const candles = await this.exchangeCoreService.getNextCandles(\n    symbol, \"1m\", candlesNeeded, bufferStartTime, true\n  );\n  \n  // backtest() handles activation/cancellation monitoring internally\n  const backtestResult = await this.strategyCoreService.backtest(symbol, candles, when, true);\n}\n```\n\nThe `backtest()` method internally monitors for:\n1. **Activation conditions:** Price reaches `priceOpen` within `CC_SCHEDULE_AWAIT_MINUTES`\n2. **Cancellation conditions:** Time expires without activation\n3. **Post-activation:** Normal TP/SL/time monitoring if activated\n\n**Sources:** [src/lib/services/logic/private/BacktestLogicPrivateService.ts:154-301](), [docs/internals.md:54-67]()\n\n### State Management and Memory Efficiency\n\nBacktest mode is stateless by design:\n- **No persistence:** Signals are not written to disk\n- **Streaming results:** Async generator yields results without accumulation\n- **Clear on start:** Each `run()` clears previous markdown service data and strategy state\n- **Early termination:** Consumer can `break` from the async generator at any point\n- **Memoized instances:** Each symbol-strategy pair reuses the same `BacktestInstance`\n\nThe clear operations ensure isolation between runs:\n\n```typescript\n// From Backtest.ts:161-174\nbacktest.backtestMarkdownService.clear({ symbol, strategyName });\nbacktest.scheduleMarkdownService.clear({ symbol, strategyName });\nbacktest.strategyCoreService.clear({ symbol, strategyName });\n\nconst { riskName, riskList } = backtest.strategySchemaService.get(strategyName);\nriskName && backtest.riskGlobalService.clear(riskName);\nriskList?.forEach((riskName) => backtest.riskGlobalService.clear(riskName));\n```\n\n**Sources:** [src/classes/Backtest.ts:161-174](), [docs/internals.md:92-103]()\n\n---\n\n## Live Trading Mode\n\n### Architecture Overview\n\n```mermaid\ngraph TB\n    subgraph \"Public API Layer\"\n        LV[\"Live (singleton)\"]\n        LVI[\"LiveInstance (memoized)\"]\n    end\n    \n    subgraph \"Service Layer\"\n        CMD[\"LiveCommandService\"]\n        PUB[\"LiveLogicPublicService\"]\n        PRIV[\"LiveLogicPrivateService\"]\n    end\n    \n    subgraph \"Core Services\"\n        STRAT[\"StrategyCoreService\"]\n    end\n    \n    subgraph \"Persistence Layer\"\n        PSA[\"PersistSignalAdapter\"]\n        JSON[\"JSON files (atomic writes)\"]\n    end\n    \n    subgraph \"Context Services\"\n        MCTX[\"MethodContextService\"]\n        ECTX[\"ExecutionContextService\"]\n    end\n    \n    LV -->|\"run(symbol, context)\"| LVI\n    LVI -->|\"validate + run()\"| CMD\n    CMD -->|\"context propagation\"| MCTX\n    CMD -->|\"async generator\"| PUB\n    PUB -->|\"async generator\"| PRIV\n    \n    PRIV -->|\"while(true)\"| PRIV\n    PRIV -->|\"when = new Date()\"| PRIV\n    PRIV -->|\"tick(symbol, when, false)\"| STRAT\n    PRIV -->|\"sleep(TICK_TTL)\"| PRIV\n    \n    STRAT -->|\"waitForInit()\"| PSA\n    STRAT -->|\"setPendingSignal()\"| PSA\n    PSA -->|\"writeSignalData()\"| JSON\n    PSA -->|\"readSignalData()\"| JSON\n    \n    MCTX -->|\"strategyName, exchangeName\"| PRIV\n    ECTX -->|\"symbol, when, backtest=false\"| STRAT\n```\n\n**Diagram: Live Mode Service Dependencies with Persistence**\n\n**Sources:** [src/classes/Live.ts:1-607](), [src/lib/services/logic/private/LiveLogicPrivateService.ts:1-179]()\n\n### Public API Entry Points\n\nThe `Live` singleton provides crash-safe real-time trading:\n\n```typescript\n// From Live.ts\nLive.run(symbol: string, context: {\n  strategyName: string,\n  exchangeName: string\n}) -> AsyncGenerator<IStrategyTickResultOpened | IStrategyTickResultClosed>\n\nLive.background(symbol, context) -> CancellationFunction\nLive.stop(symbol, strategyName) -> Promise<void>\nLive.getData(symbol, strategyName) -> Promise<LiveStatistics>\n```\n\nKey differences from Backtest:\n- **No frameName:** Live mode uses real-time progression (`new Date()`)\n- **Filtered output:** Generator only yields `opened` and `closed` results (not `idle`/`active`)\n- **Infinite loop:** Generator never completes unless explicitly stopped\n- **Crash recovery:** State restored from disk on restart\n\n**Sources:** [src/classes/Live.ts:372-414](), [src/classes/Live.ts:417-455]()\n\n### Execution Flow\n\n```mermaid\ngraph TD\n    START[\"Live.run()\"]\n    VALIDATE[\"Validate strategy, exchange, risk\"]\n    INSTANCE[\"Get/Create LiveInstance\"]\n    CLEAR[\"Clear markdown services & strategy state & risk state\"]\n    COMMAND[\"LiveCommandService.run()\"]\n    \n    INFINITE[\"while(true) - Infinite Loop\"]\n    WHEN[\"when = new Date()\"]\n    \n    TICK[\"StrategyCoreService.tick(when, backtest=false)\"]\n    WAIT_INIT[\"First tick: waitForInit() - load persisted state\"]\n    CHECK_RESULT{\"result.action?\"}\n    \n    IDLE[\"action: idle\"]\n    ACTIVE[\"action: active\"]\n    SCHEDULED[\"action: scheduled\"]\n    OPENED[\"action: opened\"]\n    CLOSED[\"action: closed\"]\n    \n    CHECK_STOP_IDLE{\"getStopped() && idle?\"}\n    BREAK[\"Break loop\"]\n    \n    PERSIST[\"setPendingSignal() - write to disk\"]\n    YIELD[\"Yield result\"]\n    \n    CHECK_STOP_CLOSED{\"getStopped() && closed?\"}\n    \n    SLEEP[\"sleep(TICK_TTL) - 61 seconds\"]\n    \n    DONE[\"Emit doneLiveSubject\"]\n    END[\"End generator\"]\n    \n    START --> VALIDATE\n    VALIDATE --> INSTANCE\n    INSTANCE --> CLEAR\n    CLEAR --> COMMAND\n    COMMAND --> INFINITE\n    \n    INFINITE --> WHEN\n    WHEN --> TICK\n    TICK --> WAIT_INIT\n    WAIT_INIT --> CHECK_RESULT\n    \n    CHECK_RESULT -->|\"idle\"| IDLE\n    CHECK_RESULT -->|\"active\"| ACTIVE\n    CHECK_RESULT -->|\"scheduled\"| SCHEDULED\n    CHECK_RESULT -->|\"opened\"| OPENED\n    CHECK_RESULT -->|\"closed\"| CLOSED\n    \n    IDLE --> CHECK_STOP_IDLE\n    CHECK_STOP_IDLE -->|\"Yes\"| BREAK\n    CHECK_STOP_IDLE -->|\"No\"| SLEEP\n    \n    ACTIVE --> SLEEP\n    SCHEDULED --> SLEEP\n    \n    OPENED --> PERSIST\n    PERSIST --> YIELD\n    YIELD --> SLEEP\n    \n    CLOSED --> PERSIST\n    PERSIST --> YIELD\n    YIELD --> CHECK_STOP_CLOSED\n    CHECK_STOP_CLOSED -->|\"Yes\"| BREAK\n    CHECK_STOP_CLOSED -->|\"No\"| SLEEP\n    \n    SLEEP --> INFINITE\n    BREAK --> DONE\n    DONE --> END\n```\n\n**Diagram: Live Mode Infinite Loop with Crash-Safe Persistence**\n\n**Sources:** [src/lib/services/logic/private/LiveLogicPrivateService.ts:63-175]()\n\n### Infinite Loop Architecture\n\nThe core difference between live and backtest is the infinite loop structure:\n\n```typescript\n// From LiveLogicPrivateService.ts:63-175\npublic async *run(symbol: string) {\n  let previousEventTimestamp: number | null = null;\n  \n  while (true) {  // Infinite loop\n    const tickStartTime = performance.now();\n    const when = new Date();  // Real-time date\n    \n    const result = await this.strategyCoreService.tick(symbol, when, false);\n    \n    // Track performance\n    await performanceEmitter.next({\n      timestamp: Date.now(),\n      previousTimestamp: previousEventTimestamp,\n      metricType: \"live_tick\",\n      duration: performance.now() - tickStartTime,\n      strategyName, exchangeName, symbol,\n      backtest: false\n    });\n    \n    // Check stop conditions\n    if (result.action === \"idle\") {\n      if (await this.strategyCoreService.getStopped(symbol, strategyName)) {\n        break;  // Exit when idle\n      }\n      await sleep(TICK_TTL);\n      continue;\n    }\n    \n    if (result.action === \"active\" || result.action === \"scheduled\") {\n      await sleep(TICK_TTL);\n      continue;  // Skip yielding, just continue loop\n    }\n    \n    // Yield opened/closed only\n    yield result as IStrategyTickResultOpened | IStrategyTickResultClosed;\n    \n    // Check stop after closed\n    if (result.action === \"closed\") {\n      if (await this.strategyCoreService.getStopped(symbol, strategyName)) {\n        break;\n      }\n    }\n    \n    await sleep(TICK_TTL);  // 61 seconds between ticks\n  }\n}\n```\n\nKey characteristics:\n- **`TICK_TTL = 61000ms`:** Slightly over 1 minute to ensure fresh candle data\n- **Real-time dates:** `new Date()` called each iteration\n- **No frame skipping:** Every tick is processed (no optimization like backtest)\n- **Filtered yield:** Only `opened` and `closed` emitted to consumer\n\n**Sources:** [src/lib/services/logic/private/LiveLogicPrivateService.ts:63-175](), [src/lib/services/logic/private/LiveLogicPrivateService.ts:14]()\n\n### Crash-Safe Persistence\n\nLive mode achieves crash safety through atomic file writes and state recovery:\n\n#### Write Path (Persistence)\n\n```typescript\n// StrategyCoreService calls PersistSignalAdapter\n// From StrategyCoreService (not shown in files, but documented)\nawait this.persistSignalAdapter.writeSignalData(symbol, strategyName, signal);\n```\n\nThe `PersistSignalAdapter` writes JSON atomically:\n1. Serialize signal object to JSON\n2. Write to temporary file\n3. Atomic rename to final path: `./persist/${symbol}_${strategyName}.json`\n\n#### Read Path (Recovery)\n\n```typescript\n// From ClientStrategy (referenced but not in provided files)\nasync waitForInit() {\n  if (this._initialized) return;\n  const persistedSignal = await this.persistSignalAdapter.readSignalData(\n    this.symbol, \n    this.strategyName\n  );\n  if (persistedSignal) {\n    this._pendingSignal = persistedSignal;\n  }\n  this._initialized = true;\n}\n```\n\nThe `waitForInit()` is called on first tick:\n- Loads persisted signal from disk\n- Restores `_pendingSignal` state\n- Continues monitoring from last known position\n- If file doesn't exist, starts fresh\n\n**Sources:** [docs/internals.md:69-82](), [docs/internals.md:46-52]()\n\n### Graceful Shutdown\n\nLive mode implements graceful shutdown to avoid interrupting active positions:\n\n```typescript\n// From Live.ts:221-240\nreturn () => {  // Cancellation function returned by background()\n  // Set stop flag\n  backtest.strategyCoreService.stop({symbol, strategyName}, false);\n  \n  // Wait for position to close\n  backtest.strategyCoreService\n    .getPendingSignal(symbol, strategyName)\n    .then(async (pendingSignal) => {\n      if (pendingSignal) {\n        return;  // Position still open, don't emit done\n      }\n      if (!this._isDone) {\n        await doneLiveSubject.next({\n          exchangeName, strategyName,\n          backtest: false, symbol\n        });\n      }\n      this._isDone = true;\n    });\n  \n  this._isStopped = true;\n};\n```\n\nStop flow:\n1. **User calls** `Live.stop()` or cancellation function\n2. **Stop flag set:** `strategyCoreService.stop(symbol, strategyName, false)` where `false` means \"don't force immediate stop\"\n3. **Loop checks:**\n   - If idle: breaks immediately\n   - If active: continues monitoring until closed\n4. **Position closes:** Loop breaks after `action === \"closed\"` and `getStopped()` returns true\n5. **Done event:** Emits `doneLiveSubject` only when no pending signal\n\nThis prevents orphaned positions by waiting for natural close (TP/SL/time).\n\n**Sources:** [src/classes/Live.ts:221-240](), [src/lib/services/logic/private/LiveLogicPrivateService.ts:155-171]()\n\n### State Management and Persistence Lifecycle\n\n```mermaid\ngraph LR\n    subgraph \"Process Lifecycle\"\n        START[\"Process Start\"]\n        RUN[\"Live.run()\"]\n        INIT[\"waitForInit()\"]\n        LOAD[\"Load from disk\"]\n        TICK[\"tick() loop\"]\n        OPEN[\"Signal opened\"]\n        PERSIST[\"Write to disk\"]\n        MONITOR[\"Monitor active\"]\n        CLOSE[\"Signal closed\"]\n        PERSIST2[\"Write closed to disk\"]\n        CRASH[\"Process Crash\"]\n    end\n    \n    subgraph \"State Recovery\"\n        RESTART[\"Process Restart\"]\n        RUN2[\"Live.run()\"]\n        INIT2[\"waitForInit()\"]\n        LOAD2[\"Restore from disk\"]\n        CONTINUE[\"Continue monitoring\"]\n    end\n    \n    START --> RUN\n    RUN --> INIT\n    INIT --> LOAD\n    LOAD -->|\"No file: null\"| TICK\n    LOAD -->|\"File exists: restore\"| TICK\n    TICK --> OPEN\n    OPEN --> PERSIST\n    PERSIST --> MONITOR\n    MONITOR --> CLOSE\n    CLOSE --> PERSIST2\n    PERSIST2 --> TICK\n    \n    TICK -.->|\"Crash\"| CRASH\n    CRASH -.-> RESTART\n    RESTART --> RUN2\n    RUN2 --> INIT2\n    INIT2 --> LOAD2\n    LOAD2 --> CONTINUE\n    CONTINUE --> MONITOR\n```\n\n**Diagram: Live Mode Crash Recovery Lifecycle**\n\nThe persistence layer ensures:\n- **Atomic writes:** No corrupted state files\n- **Singleshot initialization:** `waitForInit()` called once per instance\n- **Stateless process:** All state in JSON files, not in-memory\n- **Crash recovery:** Process can restart anytime and resume monitoring\n\n**Sources:** [docs/internals.md:46-52](), [docs/internals.md:69-82]()\n\n---\n\n## Walker Mode\n\n### Architecture Overview\n\n```mermaid\ngraph TB\n    subgraph \"Public API Layer\"\n        WK[\"Walker (singleton)\"]\n        WKI[\"WalkerInstance (memoized)\"]\n    end\n    \n    subgraph \"Service Layer\"\n        CMD[\"WalkerCommandService\"]\n        PUB[\"WalkerLogicPublicService\"]\n        PRIV[\"WalkerLogicPrivateService\"]\n    end\n    \n    subgraph \"Backtest Delegation\"\n        BT_PUB[\"BacktestLogicPublicService\"]\n        BT_PRIV[\"BacktestLogicPrivateService\"]\n    end\n    \n    subgraph \"Results Collection\"\n        BT_MD[\"BacktestMarkdownService\"]\n        WK_MD[\"WalkerMarkdownService\"]\n    end\n    \n    subgraph \"Stop Signal System\"\n        STOP_SUB[\"walkerStopSubject\"]\n        STOP_SET[\"Set<StrategyName>\"]\n    end\n    \n    WK -->|\"run(symbol, {walkerName})\"| WKI\n    WKI -->|\"validate all strategies\"| CMD\n    CMD -->|\"async generator\"| PUB\n    PUB -->|\"async generator\"| PRIV\n    \n    PRIV -->|\"for each strategy\"| BT_PUB\n    BT_PUB --> BT_PRIV\n    BT_PRIV -->|\"yields closed signals\"| PRIV\n    \n    PRIV -->|\"getData(symbol, strategyName)\"| BT_MD\n    BT_MD -->|\"statistics\"| PRIV\n    \n    PRIV -->|\"compare metric\"| PRIV\n    PRIV -->|\"track bestStrategy\"| PRIV\n    PRIV -->|\"yield WalkerContract\"| WK_MD\n    \n    STOP_SUB -->|\"filter by symbol+walkerName\"| STOP_SET\n    PRIV -->|\"check stoppedStrategies.has()\"| STOP_SET\n```\n\n**Diagram: Walker Mode Architecture with Sequential Backtest Delegation**\n\n**Sources:** [src/classes/Walker.ts:1-678](), [src/lib/services/logic/private/WalkerLogicPrivateService.ts:1-263]()\n\n### Public API Entry Points\n\nThe `Walker` singleton orchestrates strategy comparison:\n\n```typescript\n// From Walker.ts\nWalker.run(symbol: string, context: {\n  walkerName: string\n}) -> AsyncGenerator<WalkerContract>\n\nWalker.background(symbol, context) -> CancellationFunction\nWalker.stop(symbol, walkerName) -> Promise<void>\nWalker.getData(symbol, walkerName) -> Promise<WalkerData>\n```\n\nConfiguration is pulled from `WalkerSchemaService`:\n\n```typescript\ninterface IWalkerSchema {\n  walkerName: string;\n  strategies: StrategyName[];  // List of strategies to compare\n  exchangeName: string;\n  frameName: string;\n  metric?: WalkerMetric;  // Default: \"sharpeRatio\"\n  callbacks?: {\n    onStrategyStart?: (strategyName, symbol) => void;\n    onStrategyComplete?: (strategyName, symbol, stats, metricValue) => Promise<void>;\n    onStrategyError?: (strategyName, symbol, error) => void;\n    onComplete?: (finalResults) => void;\n  };\n}\n```\n\n**Sources:** [src/classes/Walker.ts:418-459](), [src/lib/services/logic/private/WalkerLogicPrivateService.ts:68-84]()\n\n### Sequential Backtest Execution\n\nWalker mode runs one backtest per strategy sequentially:\n\n```mermaid\ngraph TD\n    START[\"Walker.run()\"]\n    SCHEMA[\"Get WalkerSchema\"]\n    VALIDATE[\"Validate all strategies, exchange, frame\"]\n    CLEAR[\"Clear markdown & strategy state for all\"]\n    \n    INIT[\"strategiesTested = 0\"]\n    INIT2[\"bestMetric = null\"]\n    INIT3[\"bestStrategy = null\"]\n    INIT4[\"stoppedStrategies = Set()\"]\n    \n    SUBSCRIBE[\"Subscribe to walkerStopSubject\"]\n    \n    LOOP[\"for strategy in strategies\"]\n    CHECK_STOP{\"stoppedStrategies.has(strategy)?\"}\n    SKIP[\"Skip & break\"]\n    \n    CALLBACK_START[\"onStrategyStart(strategyName)\"]\n    BACKTEST[\"BacktestLogicPublicService.run()\"]\n    CONSUME[\"await resolveDocuments(iterator)\"]\n    \n    GET_STATS[\"BacktestMarkdownService.getData()\"]\n    EXTRACT[\"Extract metric value\"]\n    \n    COMPARE{\"metricValue > bestMetric?\"}\n    UPDATE[\"Update bestMetric, bestStrategy\"]\n    \n    INCREMENT[\"strategiesTested++\"]\n    \n    CONTRACT[\"Create WalkerContract\"]\n    EMIT_PROGRESS[\"Emit progressWalkerEmitter\"]\n    CALLBACK_COMPLETE[\"onStrategyComplete(stats)\"]\n    EMIT_WALKER[\"Emit walkerEmitter\"]\n    YIELD[\"Yield WalkerContract\"]\n    \n    NEXT[\"Next strategy\"]\n    \n    FINAL[\"Create final results\"]\n    CALLBACK_FINAL[\"onComplete(finalResults)\"]\n    EMIT_COMPLETE[\"Emit walkerCompleteSubject\"]\n    \n    START --> SCHEMA\n    SCHEMA --> VALIDATE\n    VALIDATE --> CLEAR\n    CLEAR --> INIT\n    INIT --> INIT2\n    INIT2 --> INIT3\n    INIT3 --> INIT4\n    INIT4 --> SUBSCRIBE\n    SUBSCRIBE --> LOOP\n    \n    LOOP --> CHECK_STOP\n    CHECK_STOP -->|\"Yes\"| SKIP\n    CHECK_STOP -->|\"No\"| CALLBACK_START\n    \n    CALLBACK_START --> BACKTEST\n    BACKTEST --> CONSUME\n    CONSUME --> GET_STATS\n    GET_STATS --> EXTRACT\n    \n    EXTRACT --> COMPARE\n    COMPARE -->|\"Yes\"| UPDATE\n    COMPARE -->|\"No\"| INCREMENT\n    UPDATE --> INCREMENT\n    \n    INCREMENT --> CONTRACT\n    CONTRACT --> EMIT_PROGRESS\n    EMIT_PROGRESS --> CALLBACK_COMPLETE\n    CALLBACK_COMPLETE --> EMIT_WALKER\n    EMIT_WALKER --> YIELD\n    YIELD --> NEXT\n    \n    NEXT --> LOOP\n    SKIP --> FINAL\n    LOOP -->|\"All done\"| FINAL\n    FINAL --> CALLBACK_FINAL\n    CALLBACK_FINAL --> EMIT_COMPLETE\n```\n\n**Diagram: Walker Sequential Execution Flow**\n\n**Sources:** [src/lib/services/logic/private/WalkerLogicPrivateService.ts:68-259]()\n\n### WalkerLogicPrivateService Implementation\n\nThe core logic runs backtests sequentially and compares results:\n\n```typescript\n// From WalkerLogicPrivateService.ts:68-259\npublic async *run(\n  symbol: string,\n  strategies: StrategyName[],\n  metric: WalkerMetric,\n  context: {\n    exchangeName: string,\n    frameName: string,\n    walkerName: string\n  }\n): AsyncGenerator<WalkerContract> {\n  \n  let strategiesTested = 0;\n  let bestMetric: number | null = null;\n  let bestStrategy: StrategyName | null = null;\n  \n  // Track stopped strategies\n  const stoppedStrategies = new Set<StrategyName>();\n  \n  // Subscribe to stop signals (filtered by symbol AND walkerName)\n  const unsubscribe = walkerStopSubject\n    .filter((data) => data.symbol === symbol && data.walkerName === context.walkerName)\n    .connect((data) => {\n      stoppedStrategies.add(data.strategyName);\n    });\n  \n  try {\n    // Sequential backtest for each strategy\n    for (const strategyName of strategies) {\n      // Check if stopped\n      if (stoppedStrategies.has(strategyName)) {\n        break;\n      }\n      \n      // Run backtest\n      const iterator = this.backtestLogicPublicService.run(symbol, {\n        strategyName, exchangeName, frameName\n      });\n      \n      await resolveDocuments(iterator);  // Consume all results\n      \n      // Get statistics\n      const stats = await this.backtestMarkdownService.getData(symbol, strategyName);\n      \n      // Extract metric value\n      const value = stats[metric];\n      const metricValue = (\n        value !== null && \n        value !== undefined && \n        typeof value === \"number\" &&\n        !isNaN(value) &&\n        isFinite(value)\n      ) ? value : null;\n      \n      // Update best if better\n      if (bestMetric === null || (metricValue !== null && metricValue > bestMetric)) {\n        bestMetric = metricValue;\n        bestStrategy = strategyName;\n      }\n      \n      strategiesTested++;\n      \n      // Create progress contract\n      const walkerContract: WalkerContract = {\n        walkerName, exchangeName, frameName, symbol,\n        strategyName, stats, metricValue, metric,\n        bestMetric, bestStrategy,\n        strategiesTested, totalStrategies: strategies.length\n      };\n      \n      await walkerEmitter.next(walkerContract);\n      yield walkerContract;\n    }\n  } finally {\n    unsubscribe();  // Clean up subscription\n  }\n  \n  // Emit final results\n  await walkerCompleteSubject.next({ bestStrategy, bestMetric, ... });\n}\n```\n\n**Sources:** [src/lib/services/logic/private/WalkerLogicPrivateService.ts:68-259]()\n\n### Metric Evaluation System\n\nWalker supports multiple comparison metrics:\n\n| Metric | Type | Formula | Interpretation |\n|--------|------|---------|----------------|\n| `sharpeRatio` | Risk-adjusted return | `avgPnl / stdDev` | Higher is better - reward per unit risk |\n| `annualizedSharpeRatio` | Annualized risk-adj. | `sharpeRatio × √365` | Higher is better - yearly normalized |\n| `winRate` | Win probability | `winCount / totalSignals × 100` | Higher is better - % winning trades |\n| `avgPnl` | Average return | `sum(pnl) / count` | Higher is better - expected profit per trade |\n| `totalPnl` | Cumulative return | `sum(pnl)` | Higher is better - total profit |\n| `certaintyRatio` | Win/loss ratio | `avgWin / |avgLoss|` | Higher is better - reward/risk asymmetry |\n| `expectedYearlyReturns` | Annualized profit | Based on avg duration | Higher is better - yearly expected gain |\n\nMetric comparison logic:\n\n```typescript\n// From WalkerLogicPrivateService.ts:182-190\nconst isBetter = \n  bestMetric === null ||\n  (metricValue !== null && metricValue > bestMetric);\n\nif (isBetter && metricValue !== null) {\n  bestMetric = metricValue;\n  bestStrategy = strategyName;\n}\n```\n\nAll metrics follow \"higher is better\" convention (including `stdDev` as inverse in Sharpe).\n\n**Sources:** [src/lib/services/logic/private/WalkerLogicPrivateService.ts:172-190](), [docs/interfaces/BacktestStatistics.md:1-110]()\n\n### Stop Signal System and Multiple Walkers\n\nWalker mode supports concurrent walker instances on the same symbol through filtered stop signals:\n\n```typescript\n// From WalkerLogicPrivateService.ts:98-111\nconst unsubscribe = walkerStopSubject\n  .filter((data) => \n    data.symbol === symbol && \n    data.walkerName === context.walkerName  // Filter by walker name\n  )\n  .connect((data) => {\n    stoppedStrategies.add(data.strategyName);\n    this.loggerService.info(\n      \"walkerLogicPrivateService received stop signal for strategy\",\n      { symbol, walkerName, strategyName: data.strategyName }\n    );\n  });\n```\n\nStop flow:\n1. **User calls** `Walker.stop(symbol, walkerName)`\n2. **Iterate strategies:** For each strategy in walker schema\n3. **Emit stop signal:** `walkerStopSubject.next({ symbol, strategyName, walkerName })`\n4. **Set internal flag:** `strategyCoreService.stop({ symbol, strategyName }, true)`\n5. **Filter in loop:** `WalkerLogicPrivateService` checks `stoppedStrategies.has()`\n6. **Break loop:** Current strategy finishes, next is skipped\n\nThe `walkerName` filter enables multiple walker instances on the same symbol without interference.\n\n**Sources:** [src/lib/services/logic/private/WalkerLogicPrivateService.ts:98-111](), [src/classes/Walker.ts:270-282]()\n\n### Lifecycle Callbacks\n\nWalker schema supports callback hooks for progress monitoring:\n\n```typescript\ncallbacks: {\n  // Called before each strategy backtest\n  onStrategyStart(strategyName: string, symbol: string): void\n  \n  // Called after each strategy completes successfully\n  onStrategyComplete(\n    strategyName: string, \n    symbol: string, \n    stats: BacktestStatistics, \n    metricValue: number | null\n  ): Promise<void>\n  \n  // Called if strategy backtest fails\n  onStrategyError(\n    strategyName: string, \n    symbol: string, \n    error: Error\n  ): void\n  \n  // Called once at end with final best results\n  onComplete(finalResults: {\n    walkerName, symbol, exchangeName, frameName,\n    metric, totalStrategies, bestStrategy, bestMetric, bestStats\n  }): void\n}\n```\n\nCallback execution points:\n\n```typescript\n// From WalkerLogicPrivateService.ts:129-160\nif (walkerSchema.callbacks?.onStrategyStart) {\n  walkerSchema.callbacks.onStrategyStart(strategyName, symbol);\n}\n\n// ... run backtest ...\n\nif (walkerSchema.callbacks?.onStrategyComplete) {\n  await walkerSchema.callbacks.onStrategyComplete(\n    strategyName, symbol, stats, metricValue\n  );\n}\n```\n\n**Sources:** [src/lib/services/logic/private/WalkerLogicPrivateService.ts:129-228](), [src/lib/services/logic/private/WalkerLogicPrivateService.ts:254-256]()\n\n---\n\n## Optimizer Mode\n\n### Architecture Overview\n\nOptimizer mode is distinct from the other execution modes - it does not execute strategies but generates them using LLM technology. The architecture is documented in the high-level diagrams but implementation files are not included in the provided sources.\n\n```mermaid\ngraph TB\n    subgraph \"Public API Layer\"\n        OPT[\"Optimizer (singleton)\"]\n    end\n    \n    subgraph \"Service Layer\"\n        OPT_GLOBAL[\"OptimizerGlobalService\"]\n        OPT_CONN[\"OptimizerConnectionService\"]\n        OPT_SCHEMA[\"OptimizerSchemaService\"]\n    end\n    \n    subgraph \"Client Layer\"\n        OPT_CLIENT[\"ClientOptimizer\"]\n    end\n    \n    subgraph \"Template System\"\n        TMPL[\"OptimizerTemplateService\"]\n    end\n    \n    subgraph \"Data Sources\"\n        CCXT_DUMP[\"CCXT_DUMPER_URL\"]\n        EXCH_API[\"Exchange API (getCandles)\"]\n    end\n    \n    subgraph \"LLM Integration\"\n        OLLAMA[\"Ollama API\"]\n        MODEL[\"deepseek-v3.1:671b\"]\n    end\n    \n    subgraph \"Output\"\n        CODE[\".mjs file with strategy\"]\n        DUMP[\"./dump/{optimizerName}_{symbol}.mjs\"]\n    end\n    \n    OPT -->|\"run(symbol, optimizerName)\"| OPT_GLOBAL\n    OPT_GLOBAL --> OPT_CONN\n    OPT_CONN --> OPT_CLIENT\n    OPT_CLIENT -->|\"fetch multi-timeframe data\"| CCXT_DUMP\n    OPT_CLIENT -->|\"fallback\"| EXCH_API\n    \n    OPT_CLIENT -->|\"format data for LLM\"| OPT_CLIENT\n    OPT_CLIENT -->|\"getPrompt() callback\"| OPT_CLIENT\n    OPT_CLIENT -->|\"generate strategy code\"| OLLAMA\n    OLLAMA -->|\"use model\"| MODEL\n    \n    MODEL -->|\"generated code\"| OPT_CLIENT\n    OPT_CLIENT -->|\"merge with template\"| TMPL\n    TMPL --> CODE\n    OPT -->|\"dump()\"| DUMP\n```\n\n**Diagram: Optimizer Mode Architecture (High-Level)**\n\nBased on the provided diagrams, the Optimizer mode follows this pattern:\n1. **Data Source Iteration:** Fetches historical data at multiple timeframes (1h, 30m, 15m, 1m)\n2. **Data Formatting:** Converts candles to markdown tables for LLM consumption\n3. **Prompt Construction:** Calls user-provided `getPrompt()` callback with formatted data\n4. **LLM Generation:** Sends prompt to Ollama API with deepseek model\n5. **Template Merging:** Combines generated strategy logic with framework boilerplate\n6. **Code Export:** Outputs executable `.mjs` file with complete strategy\n\n**Sources:** [docs/internals.md:1-507]() (Diagram 2 section on Optimizer)\n\n### Key Differences from Other Modes\n\n| Aspect | Backtest/Live/Walker | Optimizer |\n|--------|---------------------|-----------|\n| **Purpose** | Execute strategies | Generate strategies |\n| **Output** | Signal results | Source code |\n| **Execution** | Async generator loop | Single-shot code generation |\n| **Data usage** | Real-time tick/candles | Historical multi-timeframe batch |\n| **State** | Signal lifecycle | Stateless |\n| **Duration** | Long-running | Completes after generation |\n\nThe Optimizer mode is not an execution mode in the traditional sense - it's a **code generation tool** that produces strategies which can then be executed via Backtest/Live/Walker modes.\n\n**Sources:** [docs/internals.md:1-507]() (Diagram 1 and 2 sections)\n\n---\n\n## Execution Mode Comparison\n\n### Feature Matrix\n\n| Feature | Backtest | Live | Walker | Optimizer |\n|---------|----------|------|--------|-----------|\n| **Loop Type** | Finite (timeframes) | Infinite (while true) | Sequential (strategies) | Single-shot |\n| **Date Source** | Frame-generated | `new Date()` | Frame-delegated | Historical batch |\n| **Persistence** | None | JSON atomic writes | None | File output |\n| **Output Type** | `IStrategyBacktestResult` | `IStrategyTickResultOpened\\|Closed` | `WalkerContract` | Code string |\n| **Crash Recovery** | Not needed | `waitForInit()` | Not needed | N/A |\n| **Stop Behavior** | Graceful at idle/closed | Graceful at idle/closed | Filtered by walkerName | N/A |\n| **Performance Optimization** | Skip-to-close | None (real-time) | Parallel not supported | Data fetching |\n| **State Management** | Cleared on start | Persisted to disk | Cleared per strategy | Stateless |\n| **Primary Use Case** | Historical validation | Production trading | Strategy comparison | Strategy generation |\n\n**Sources:** [docs/internals.md:54-82]() (Data Flow sections)\n\n### Performance Characteristics\n\n| Mode | Execution Speed | Memory Usage | Disk I/O |\n|------|----------------|--------------|----------|\n| **Backtest** | Very fast (skip-to-close) | Low (streaming) | None |\n| **Live** | Real-time (61s ticks) | Low (streaming) | Atomic writes per tick |\n| **Walker** | Slow (sequential backtests) | Moderate (accumulated stats) | None |\n| **Optimizer** | Depends on LLM latency | Moderate (multi-timeframe data) | File output |\n\n### Service Layer Dependencies\n\nAll modes share core services but use them differently:\n\n```mermaid\ngraph LR\n    subgraph \"Shared Core Services\"\n        STRAT[\"StrategyCoreService\"]\n        EXCH[\"ExchangeCoreService\"]\n        FRAME[\"FrameCoreService\"]\n    end\n    \n    subgraph \"Mode-Specific Logic\"\n        BT_LOGIC[\"BacktestLogicPrivateService\"]\n        LV_LOGIC[\"LiveLogicPrivateService\"]\n        WK_LOGIC[\"WalkerLogicPrivateService\"]\n        OPT_CLIENT[\"ClientOptimizer\"]\n    end\n    \n    BT_LOGIC -->|\"tick(), backtest()\"| STRAT\n    BT_LOGIC -->|\"getNextCandles()\"| EXCH\n    BT_LOGIC -->|\"getTimeframe()\"| FRAME\n    \n    LV_LOGIC -->|\"tick() only\"| STRAT\n    LV_LOGIC -->|\"No frame needed\"| FRAME\n    \n    WK_LOGIC -->|\"Delegates to\"| BT_LOGIC\n    \n    OPT_CLIENT -->|\"getCandles() batch\"| EXCH\n    OPT_CLIENT -->|\"No tick/backtest\"| STRAT\n```\n\n**Diagram: Execution Mode Service Dependencies**\n\n**Sources:** [src/lib/services/logic/private/BacktestLogicPrivateService.ts:33-47](), [src/lib/services/logic/private/LiveLogicPrivateService.ts:32-39](), [src/lib/services/logic/private/WalkerLogicPrivateService.ts:29-38]()\n\n---\n\n## Summary\n\nThe four execution modes provide complementary capabilities:\n\n- **Backtest:** Optimized historical validation with skip-to-close for fast signal processing\n- **Live:** Crash-safe real-time trading with atomic persistence and graceful shutdown\n- **Walker:** Sequential strategy comparison with metric-based ranking and progress callbacks\n- **Optimizer:** LLM-powered strategy code generation using multi-timeframe historical data\n\nAll modes leverage the same core service architecture (Strategy, Exchange, Frame) but implement distinct orchestration patterns via Logic services. The async generator pattern enables memory-efficient streaming, early termination, and consistent error handling across all execution modes.\n\n**Sources:** [docs/internals.md:10-27](), [docs/internals.md:54-82]()"
                    },
                    {
                        "page_plan": {
                            "id": "5.1",
                            "title": "Backtest Mode"
                        },
                        "content": "# Backtest Mode\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [assets/uml.svg](assets/uml.svg)\n- [docs/classes/WalkerCommandService.md](docs/classes/WalkerCommandService.md)\n- [docs/interfaces/BacktestStatistics.md](docs/interfaces/BacktestStatistics.md)\n- [docs/interfaces/IStrategyCallbacks.md](docs/interfaces/IStrategyCallbacks.md)\n- [docs/interfaces/LiveStatistics.md](docs/interfaces/LiveStatistics.md)\n- [docs/internals.md](docs/internals.md)\n- [docs/types/IStrategyTickResult.md](docs/types/IStrategyTickResult.md)\n- [docs/uml.puml](docs/uml.puml)\n- [scripts/uml.mjs](scripts/uml.mjs)\n- [src/classes/Backtest.ts](src/classes/Backtest.ts)\n- [src/classes/Live.ts](src/classes/Live.ts)\n- [src/classes/Walker.ts](src/classes/Walker.ts)\n- [src/lib/services/logic/private/BacktestLogicPrivateService.ts](src/lib/services/logic/private/BacktestLogicPrivateService.ts)\n- [src/lib/services/logic/private/LiveLogicPrivateService.ts](src/lib/services/logic/private/LiveLogicPrivateService.ts)\n- [src/lib/services/logic/private/WalkerLogicPrivateService.ts](src/lib/services/logic/private/WalkerLogicPrivateService.ts)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis document describes the **Backtest Mode** execution system in backtest-kit, which simulates historical trading by iterating through pre-generated timeframes and processing trading signals against historical market data. Backtest Mode enables strategy validation and performance analysis without real-time market interaction.\n\nFor real-time trading execution with crash recovery, see [Live Trading Mode](#5.2). For comparing multiple strategies, see [Walker Mode](#5.3). For strategy lifecycle and signal generation, see [Strategy Execution Flow](#4.2).\n\n**Sources:** [src/classes/Backtest.ts:1-594](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:1-481](), [docs/internals.md:54-67]()\n\n---\n\n## Overview\n\nBacktest Mode processes historical market data by generating a fixed array of timeframes (e.g., every 1 minute for 30 days) and iterating through them sequentially. When a signal opens, the system fetches historical candle data and applies fast candle processing to determine the close reason (take profit, stop loss, or time expiration). A key optimization is skipping timeframes after signal closure until the `closeTimestamp`, significantly reducing computation time.\n\nThe system uses async generators for memory efficiency, yielding closed signals without accumulating results in memory. This enables early termination via loop breaks and streaming processing of large historical datasets.\n\n**Key Characteristics:**\n\n| Feature | Description |\n|---------|-------------|\n| **Data Source** | Historical market data via ExchangeCoreService |\n| **Iteration** | Sequential timeframe array from FrameCoreService |\n| **Signal Processing** | Fast candle processing with TP/SL/time monitoring |\n| **Optimization** | Skip-to-close timestamp after signal completion |\n| **Memory Model** | Async generator yielding closed signals only |\n| **Completion** | Finite - ends when all timeframes processed |\n| **State Persistence** | None - stateless execution |\n\n**Sources:** [src/lib/services/logic/private/BacktestLogicPrivateService.ts:20-32](), [docs/internals.md:54-67]()\n\n---\n\n## Architecture Components\n\n```mermaid\ngraph TB\n    subgraph \"Public API Layer\"\n        Backtest[\"Backtest (singleton)<br/>BacktestUtils class\"]\n        BacktestInstance[\"BacktestInstance<br/>Per symbol-strategy isolation\"]\n    end\n    \n    subgraph \"Command Layer\"\n        BacktestCommand[\"BacktestCommandService<br/>Validation orchestration\"]\n    end\n    \n    subgraph \"Logic Layer\"\n        BacktestPublic[\"BacktestLogicPublicService<br/>Context setup wrapper\"]\n        BacktestPrivate[\"BacktestLogicPrivateService<br/>Generator implementation\"]\n    end\n    \n    subgraph \"Core Services\"\n        StrategyCore[\"StrategyCoreService<br/>tick() + backtest()\"]\n        ExchangeCore[\"ExchangeCoreService<br/>getNextCandles()\"]\n        FrameCore[\"FrameCoreService<br/>getTimeframe()\"]\n    end\n    \n    subgraph \"Markdown Services\"\n        BacktestMarkdown[\"BacktestMarkdownService<br/>Statistics + Reports\"]\n    end\n    \n    subgraph \"Event System\"\n        Emitters[\"signalBacktestEmitter<br/>progressBacktestEmitter<br/>doneBacktestSubject<br/>performanceEmitter\"]\n    end\n    \n    Backtest -->|\"memoize(symbol:strategy)\"| BacktestInstance\n    BacktestInstance -->|\"run(symbol, context)\"| BacktestCommand\n    BacktestCommand --> BacktestPublic\n    BacktestPublic -->|\"MethodContext.runInContext()\"| BacktestPrivate\n    \n    BacktestPrivate -->|\"getTimeframe()\"| FrameCore\n    BacktestPrivate -->|\"tick(symbol, when, true)\"| StrategyCore\n    BacktestPrivate -->|\"getNextCandles()\"| ExchangeCore\n    StrategyCore -->|\"backtest(candles)\"| StrategyCore\n    \n    BacktestPrivate -->|\"emit progress\"| Emitters\n    StrategyCore -->|\"emit signals\"| Emitters\n    Emitters -->|\"subscribe\"| BacktestMarkdown\n```\n\n**Component Responsibilities:**\n\n| Component | File | Responsibility |\n|-----------|------|----------------|\n| `BacktestUtils` | [src/classes/Backtest.ts:355-593]() | Singleton API with validation and instance management |\n| `BacktestInstance` | [src/classes/Backtest.ts:73-334]() | Isolated execution context per symbol-strategy pair |\n| `BacktestCommandService` | Service layer | Validates schemas and delegates to logic layer |\n| `BacktestLogicPublicService` | Logic layer | Sets up MethodContext and ExecutionContext |\n| `BacktestLogicPrivateService` | [src/lib/services/logic/private/BacktestLogicPrivateService.ts:33-480]() | Core async generator orchestrating timeframe iteration |\n| `StrategyCoreService` | Core services | Executes `tick()` and `backtest()` methods on strategies |\n| `ExchangeCoreService` | Core services | Fetches historical candle data with buffering |\n| `FrameCoreService` | Core services | Generates timeframe array for iteration |\n\n**Sources:** [src/classes/Backtest.ts:1-594](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:1-481](), [docs/uml.puml:128-311]()\n\n---\n\n## Execution Flow\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Backtest as \"Backtest.run()\"\n    participant Instance as \"BacktestInstance\"\n    participant Command as \"BacktestCommandService\"\n    participant LogicPublic as \"BacktestLogicPublicService\"\n    participant LogicPrivate as \"BacktestLogicPrivateService\"\n    participant FrameCore as \"FrameCoreService\"\n    participant StrategyCore as \"StrategyCoreService\"\n    participant ExchangeCore as \"ExchangeCoreService\"\n    \n    User->>Backtest: run(symbol, {strategyName, exchangeName, frameName})\n    Backtest->>Backtest: validate schemas\n    Backtest->>Instance: getInstance(symbol, strategyName)\n    Instance->>Instance: clear markdown services\n    Instance->>Instance: clear strategy state\n    Instance->>Instance: clear risk state\n    Instance->>Command: run(symbol, context)\n    Command->>LogicPublic: run(symbol)\n    LogicPublic->>LogicPublic: MethodContext.runInContext()\n    LogicPublic->>LogicPrivate: run(symbol)*\n    \n    LogicPrivate->>FrameCore: getTimeframe(symbol, frameName)\n    FrameCore-->>LogicPrivate: Date[] timeframes\n    \n    loop For each timeframe (i < timeframes.length)\n        LogicPrivate->>LogicPrivate: emit progressBacktestEmitter\n        LogicPrivate->>LogicPrivate: check getStopped()\n        LogicPrivate->>StrategyCore: tick(symbol, when, true)\n        StrategyCore-->>LogicPrivate: IStrategyTickResult\n        \n        alt result.action === \"opened\"\n            LogicPrivate->>ExchangeCore: getNextCandles(symbol, \"1m\", totalCandles)\n            ExchangeCore-->>LogicPrivate: ICandleData[]\n            LogicPrivate->>StrategyCore: backtest(symbol, candles, when, true)\n            StrategyCore-->>LogicPrivate: IStrategyBacktestResult (closed)\n            LogicPrivate->>LogicPrivate: skip timeframes until closeTimestamp\n            LogicPrivate-->>User: yield closed result\n        end\n        \n        alt result.action === \"scheduled\"\n            LogicPrivate->>ExchangeCore: getNextCandles(with buffer + await minutes)\n            ExchangeCore-->>LogicPrivate: ICandleData[]\n            LogicPrivate->>StrategyCore: backtest(symbol, candles, when, true)\n            StrategyCore-->>LogicPrivate: IStrategyBacktestResult\n            LogicPrivate->>LogicPrivate: skip timeframes until closeTimestamp\n            LogicPrivate-->>User: yield result\n        end\n    end\n    \n    LogicPrivate->>LogicPrivate: emit doneBacktestSubject\n    LogicPrivate-->>User: generator complete\n```\n\n**Execution Phases:**\n\n| Phase | Description | Key Operations |\n|-------|-------------|----------------|\n| **1. Initialization** | Setup and validation | Validate schemas, clear state, create instance |\n| **2. Timeframe Generation** | Create iteration array | `FrameCoreService.getTimeframe()` returns `Date[]` |\n| **3. Sequential Iteration** | Loop through timeframes | `while (i < timeframes.length)` at [BacktestLogicPrivateService.ts:78]() |\n| **4. Tick Processing** | Check signal status | `StrategyCoreService.tick(symbol, when, true)` |\n| **5. Signal Opening** | Handle new signal | Fetch candles, call `backtest()`, yield closed result |\n| **6. Timeframe Skipping** | Optimization | Skip to `closeTimestamp` via [BacktestLogicPrivateService.ts:403-409]() |\n| **7. Progress Emission** | Monitoring | Emit events at [BacktestLogicPrivateService.ts:84-92]() |\n| **8. Completion** | Finalize | Emit `doneBacktestSubject` at [BacktestLogicPrivateService.ts:452-461]() |\n\n**Sources:** [src/lib/services/logic/private/BacktestLogicPrivateService.ts:62-477](), [src/classes/Backtest.ts:148-177]()\n\n---\n\n## Timeframe Iteration and Skip Optimization\n\nThe backtest generator iterates through a pre-generated array of `Date` objects representing discrete time points. The `FrameCoreService` generates this array based on the frame configuration (e.g., every 1 minute from startDate to endDate).\n\n**Timeframe Generation:**\n\n```mermaid\ngraph LR\n    FrameSchema[\"IFrameSchema<br/>{startDate, endDate, interval}\"]\n    FrameCore[\"FrameCoreService.getTimeframe()\"]\n    TimeframeArray[\"Date[] timeframes<br/>[t0, t1, t2, ..., tn]\"]\n    \n    FrameSchema -->|\"getTimeframe(symbol, frameName)\"| FrameCore\n    FrameCore -->|\"generate array\"| TimeframeArray\n    \n    subgraph \"Iteration Loop\"\n        Loop[\"while (i < timeframes.length)\"]\n        ProcessTick[\"tick(symbol, timeframes[i])\"]\n        CheckResult[\"result.action?\"]\n        SkipLogic[\"Skip to closeTimestamp\"]\n    end\n    \n    TimeframeArray --> Loop\n    Loop --> ProcessTick\n    ProcessTick --> CheckResult\n    CheckResult -->|\"opened/scheduled\"| SkipLogic\n    SkipLogic -->|\"i += skip_count\"| Loop\n```\n\n**Skip-to-Close Optimization:**\n\nWhen a signal closes at timestamp `closeTimestamp`, the iterator skips all intermediate timeframes until reaching or passing that timestamp. This is implemented at [BacktestLogicPrivateService.ts:403-409]():\n\n```typescript\n// Skip timeframes until closeTimestamp\nwhile (\n  i < timeframes.length &&\n  timeframes[i].getTime() < backtestResult.closeTimestamp\n) {\n  i++;\n}\n```\n\n**Performance Impact:**\n\nFor a signal with `minuteEstimatedTime = 60` (1 hour), instead of calling `tick()` 60 times (once per minute), the system:\n1. Calls `tick()` once (signal opens)\n2. Fetches 60 candles in one request\n3. Processes all candles via `backtest()` method\n4. Skips 60 timeframe iterations\n5. Resumes iteration after the signal closes\n\nThis reduces computational overhead by ~60x for typical signals.\n\n**Sources:** [src/lib/services/logic/private/BacktestLogicPrivateService.ts:69-73](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:403-409]()\n\n---\n\n## Signal Processing: tick() and backtest()\n\nBacktest Mode uses two distinct methods for signal processing:\n\n### tick() Method\n\nCalled once per timeframe to determine signal state. Returns a discriminated union `IStrategyTickResult` with possible actions: `idle`, `opened`, `active`, `scheduled`, `closed`, `cancelled`.\n\n**Invocation:**\n[BacktestLogicPrivateService.ts:115]() calls:\n```typescript\nresult = await this.strategyCoreService.tick(symbol, when, true);\n```\n\nThe third parameter `true` indicates backtest mode, affecting:\n- VWAP calculation uses historical data\n- No persistence to disk\n- ExecutionContext has `backtest: true`\n\n### backtest() Method\n\nCalled once per signal (after `opened` or `scheduled`) to process all candles until signal closes. This method:\n1. Iterates through candle array sequentially\n2. Calculates VWAP for each candle\n3. Checks TP/SL/time conditions\n4. Returns `IStrategyBacktestResult` (always `action: \"closed\"` or `action: \"cancelled\"`)\n\n**Invocation for Opened Signals:**\n[BacktestLogicPrivateService.ts:361-366]():\n```typescript\nbacktestResult = await this.strategyCoreService.backtest(\n  symbol,\n  candles,\n  when,\n  true\n);\n```\n\n**Invocation for Scheduled Signals:**\n[BacktestLogicPrivateService.ts:223-228]():\n```typescript\nbacktestResult = await this.strategyCoreService.backtest(\n  symbol,\n  candles,\n  when,\n  true\n);\n```\n\nThe `backtest()` method handles both regular and scheduled signals, automatically detecting activation conditions for scheduled signals before proceeding to TP/SL monitoring.\n\n**Sources:** [src/lib/services/logic/private/BacktestLogicPrivateService.ts:114-129](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:304-380](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:154-243]()\n\n---\n\n## Fast Candle Processing and Buffering\n\nWhen a signal opens, the system must fetch sufficient historical candles to:\n1. Provide VWAP calculation buffer (preceding candles)\n2. Process the entire signal duration (until TP/SL/time)\n\n### Buffer Calculation for Opened Signals\n\n[BacktestLogicPrivateService.ts:315-328]():\n\n```typescript\nconst bufferMinutes = GLOBAL_CONFIG.CC_AVG_PRICE_CANDLES_COUNT - 1;\nconst bufferStartTime = new Date(when.getTime() - bufferMinutes * 60 * 1000);\nconst totalCandles = signal.minuteEstimatedTime + bufferMinutes;\n\ncandles = await this.exchangeCoreService.getNextCandles(\n  symbol,\n  \"1m\",\n  totalCandles,\n  bufferStartTime,\n  true\n);\n```\n\n**Example:** \n- `when = 2024-01-15 10:00:00`\n- `CC_AVG_PRICE_CANDLES_COUNT = 5` (need 5 candles for VWAP)\n- `minuteEstimatedTime = 60` (signal duration)\n\nThe system fetches:\n- Buffer: 4 candles before `when` (09:56, 09:57, 09:58, 09:59)\n- Signal: 60 candles from `when` onward (10:00 through 10:59)\n- Total: 64 candles in one request\n\n### Buffer Calculation for Scheduled Signals\n\n[BacktestLogicPrivateService.ts:174-176]():\n\n```typescript\nconst bufferMinutes = GLOBAL_CONFIG.CC_AVG_PRICE_CANDLES_COUNT - 1;\nconst bufferStartTime = new Date(when.getTime() - bufferMinutes * 60 * 1000);\nconst candlesNeeded = bufferMinutes + GLOBAL_CONFIG.CC_SCHEDULE_AWAIT_MINUTES + signal.minuteEstimatedTime + 1;\n```\n\nScheduled signals require additional candles for the await period (`CC_SCHEDULE_AWAIT_MINUTES`) before potential activation.\n\n### VWAP Calculation\n\nThe buffer ensures that when processing the first candle at timestamp `when`, there are already 4 preceding candles in memory to calculate VWAP using the last 5 candles (including the current one). This maintains consistency with live mode, where VWAP always uses the most recent `CC_AVG_PRICE_CANDLES_COUNT` candles.\n\n**Sources:** [src/lib/services/logic/private/BacktestLogicPrivateService.ts:315-328](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:174-186](), [docs/internals.md:18]()\n\n---\n\n## Generator Pattern and Memory Efficiency\n\nBacktest Mode uses async generators to stream results without accumulating them in memory. This enables:\n\n1. **Early Termination:** Consumers can break out of the loop at any point\n2. **Memory Bounds:** Only current signal data held in memory, not entire backtest history\n3. **Progressive Processing:** Results available as soon as each signal closes\n\n### Generator Implementation\n\n[BacktestLogicPrivateService.ts:62-477]() defines:\n```typescript\npublic async *run(symbol: string) {\n  // ... initialization\n  \n  while (i < timeframes.length) {\n    // ... process timeframe\n    \n    if (result.action === \"opened\") {\n      // ... fetch candles, call backtest()\n      yield backtestResult; // Yield point\n    }\n    \n    i++;\n  }\n}\n```\n\n### Consumer Patterns\n\n**Pattern 1: Process All Results**\n```typescript\nfor await (const result of Backtest.run(symbol, context)) {\n  console.log(result.closeReason, result.pnl.pnlPercentage);\n}\n```\n\n**Pattern 2: Early Termination**\n```typescript\nfor await (const result of Backtest.run(symbol, context)) {\n  if (result.pnl.pnlPercentage < -10) {\n    break; // Stop backtest if cumulative loss exceeds 10%\n  }\n}\n```\n\n**Pattern 3: Background Execution**\n[Backtest.ts:199-234]() implements `background()` which consumes the generator internally:\n```typescript\npublic background = (symbol: string, context: {...}) => {\n  this.task(symbol, context).catch((error) =>\n    exitEmitter.next(new Error(getErrorMessage(error)))\n  );\n  return () => { /* cancellation logic */ };\n};\n```\n\n### Memory Comparison\n\n| Approach | Memory Usage | Implementation |\n|----------|--------------|----------------|\n| **Array Accumulation** | O(n) where n = total signals | `results = []` then `results.push(signal)` |\n| **Generator (Current)** | O(1) constant per signal | `yield signal` without storage |\n\nFor a 30-day backtest with 100 signals, the generator approach uses ~99% less memory for result storage.\n\n**Sources:** [src/lib/services/logic/private/BacktestLogicPrivateService.ts:62-477](), [src/classes/Backtest.ts:199-234]()\n\n---\n\n## Event System Integration\n\nBacktest Mode emits events throughout execution for monitoring and reporting:\n\n```mermaid\ngraph TB\n    subgraph \"Event Emitters\"\n        SignalBacktest[\"signalBacktestEmitter<br/>Closed signals\"]\n        ProgressBacktest[\"progressBacktestEmitter<br/>Timeframe progress\"]\n        DoneBacktest[\"doneBacktestSubject<br/>Completion notification\"]\n        Performance[\"performanceEmitter<br/>Duration metrics\"]\n        Error[\"errorEmitter<br/>Recoverable errors\"]\n    end\n    \n    subgraph \"Logic Layer\"\n        Loop[\"Timeframe iteration loop\"]\n        TickCall[\"tick() call\"]\n        BacktestCall[\"backtest() call\"]\n        Completion[\"Loop completion\"]\n    end\n    \n    subgraph \"Subscribers\"\n        BacktestMarkdown[\"BacktestMarkdownService<br/>Statistics calculation\"]\n        ScheduleMarkdown[\"ScheduleMarkdownService<br/>Scheduled signal tracking\"]\n        UserListeners[\"User-defined listeners<br/>listenSignalBacktest()\"]\n    end\n    \n    Loop -->|\"every iteration\"| ProgressBacktest\n    TickCall -->|\"on error\"| Error\n    BacktestCall -->|\"on closed\"| SignalBacktest\n    BacktestCall -->|\"on completion\"| Performance\n    Completion -->|\"end of loop\"| DoneBacktest\n    \n    SignalBacktest --> BacktestMarkdown\n    SignalBacktest --> UserListeners\n    DoneBacktest --> UserListeners\n    ProgressBacktest --> UserListeners\n```\n\n### Event Types and Timing\n\n| Event | Emitted By | Timing | Payload |\n|-------|-----------|--------|---------|\n| `progressBacktestEmitter` | [BacktestLogicPrivateService.ts:84-92]() | Every timeframe | `{processedFrames, totalFrames, progress, symbol, strategyName, exchangeName}` |\n| `signalBacktestEmitter` | `StrategyCoreService` (indirectly) | Signal closes | `IStrategyTickResultClosed` |\n| `performanceEmitter` | [BacktestLogicPrivateService.ts:391-401]() | Signal/timeframe/total | `{duration, metricType, timestamp, strategyName, exchangeName, symbol, backtest: true}` |\n| `doneBacktestSubject` | [BacktestLogicPrivateService.ts:452-461]() or [Backtest.ts:44-50]() | Completion | `{symbol, strategyName, exchangeName, backtest: true}` |\n| `errorEmitter` | [BacktestLogicPrivateService.ts:126]() | Recoverable errors | `Error` object |\n\n### Listening to Events\n\nUsers can subscribe via public API functions:\n\n```typescript\nlistenSignalBacktest((result) => {\n  console.log(`Signal closed: ${result.signal.id}`);\n});\n\nlistenBacktestProgress((progress) => {\n  console.log(`Progress: ${progress.processedFrames}/${progress.totalFrames}`);\n});\n\nlistenDoneBacktest((done) => {\n  console.log(`Backtest complete for ${done.strategyName}`);\n});\n```\n\n**Sources:** [src/lib/services/logic/private/BacktestLogicPrivateService.ts:84-92](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:391-401](), [src/classes/Backtest.ts:44-50]()\n\n---\n\n## Public API Methods\n\n### run()\n\nReturns an async generator that yields closed signals. Intended for direct consumption by user code.\n\n**Signature:**\n[Backtest.ts:374-396]()\n```typescript\npublic run = (\n  symbol: string,\n  context: {\n    strategyName: string;\n    exchangeName: string;\n    frameName: string;\n  }\n) => AsyncGenerator<IStrategyBacktestResult>\n```\n\n**Usage:**\n```typescript\nfor await (const result of Backtest.run(\"BTCUSDT\", {\n  strategyName: \"my-strategy\",\n  exchangeName: \"binance\",\n  frameName: \"1d-backtest\"\n})) {\n  console.log(result.closeReason, result.pnl.pnlPercentage);\n}\n```\n\n### background()\n\nConsumes the generator internally without exposing results. Returns a cancellation function. Useful for running backtests for side effects (callbacks, event listeners, report generation).\n\n**Signature:**\n[Backtest.ts:419-439]()\n```typescript\npublic background = (\n  symbol: string,\n  context: {\n    strategyName: string;\n    exchangeName: string;\n    frameName: string;\n  }\n) => () => void\n```\n\n**Usage:**\n```typescript\nconst cancel = Backtest.background(\"BTCUSDT\", {\n  strategyName: \"my-strategy\",\n  exchangeName: \"binance\",\n  frameName: \"1d-backtest\"\n});\n\n// Later, to stop:\ncancel();\n```\n\n### stop()\n\nSets internal flag to prevent strategy from generating new signals. Current active signal completes normally. Backtest stops at next safe point (idle state or after signal closes).\n\n**Signature:**\n[Backtest.ts:458-469]()\n```typescript\npublic stop = async (\n  symbol: string,\n  strategyName: StrategyName\n) => Promise<void>\n```\n\n### getData()\n\nRetrieves statistical data calculated from all closed signals.\n\n**Signature:**\n[Backtest.ts:484-495]()\n```typescript\npublic getData = async (\n  symbol: string,\n  strategyName: StrategyName\n) => Promise<BacktestStatistics>\n```\n\n**Returns:** `BacktestStatistics` object with metrics like `sharpeRatio`, `winRate`, `totalPnl`, etc.\n\n### getReport()\n\nGenerates markdown-formatted report with signal table and statistics.\n\n**Signature:**\n[Backtest.ts:510-521]()\n```typescript\npublic getReport = async (\n  symbol: string,\n  strategyName: StrategyName\n) => Promise<string>\n```\n\n### dump()\n\nSaves markdown report to disk at specified path (default: `./dump/backtest/`).\n\n**Signature:**\n[Backtest.ts:539-554]()\n```typescript\npublic dump = async (\n  symbol: string,\n  strategyName: StrategyName,\n  path?: string\n) => Promise<void>\n```\n\n### list()\n\nLists all active backtest instances with their current status (`idle`, `running`, or `done`).\n\n**Signature:**\n[Backtest.ts:569-572]()\n```typescript\npublic list = async () => Promise<Array<{\n  id: string;\n  symbol: string;\n  strategyName: StrategyName;\n  status: 'idle' | 'running' | 'done';\n}>>\n```\n\n**Sources:** [src/classes/Backtest.ts:355-593]()\n\n---\n\n## Instance Management and Isolation\n\nThe `Backtest` singleton uses memoization to create isolated `BacktestInstance` objects per symbol-strategy pair. This ensures that multiple concurrent backtests don't interfere with each other.\n\n### Memoization Pattern\n\n[Backtest.ts:360-365]():\n```typescript\nprivate _getInstance = memoize<\n  (symbol: string, strategyName: StrategyName) => BacktestInstance\n>(\n  ([symbol, strategyName]) => `${symbol}:${strategyName}`,\n  (symbol: string, strategyName: StrategyName) => new BacktestInstance(symbol, strategyName)\n);\n```\n\n**Key:** `\"${symbol}:${strategyName}\"` (e.g., `\"BTCUSDT:my-strategy\"`)\n\n**Result:** Each unique symbol-strategy combination gets exactly one `BacktestInstance`, cached for the lifetime of the process.\n\n### State Isolation\n\nEach `BacktestInstance` maintains isolated state:\n\n[Backtest.ts:161-174]():\n```typescript\n// Clear markdown services\nbacktest.backtestMarkdownService.clear({ symbol, strategyName: context.strategyName });\nbacktest.scheduleMarkdownService.clear({ symbol, strategyName: context.strategyName });\n\n// Clear strategy state\nbacktest.strategyCoreService.clear({ symbol, strategyName: context.strategyName });\n\n// Clear risk state\nconst { riskName, riskList } = backtest.strategySchemaService.get(context.strategyName);\nriskName && backtest.riskGlobalService.clear(riskName);\nriskList && riskList.forEach((riskName) => backtest.riskGlobalService.clear(riskName));\n```\n\nThis clearing happens at the start of each `run()` call, ensuring clean state for repeated backtests.\n\n### Concurrent Execution\n\nThe memoization pattern enables:\n```typescript\n// These run independently without interference\nconst gen1 = Backtest.run(\"BTCUSDT\", { strategyName: \"strategy-1\", ... });\nconst gen2 = Backtest.run(\"ETHUSDT\", { strategyName: \"strategy-1\", ... });\nconst gen3 = Backtest.run(\"BTCUSDT\", { strategyName: \"strategy-2\", ... });\n```\n\nEach generator maintains its own iteration state (`i` variable in `BacktestLogicPrivateService`).\n\n**Sources:** [src/classes/Backtest.ts:360-365](), [src/classes/Backtest.ts:161-174](), [src/classes/Backtest.ts:73-334]()\n\n---\n\n## Performance Optimizations\n\nBacktest Mode implements several optimizations for fast execution:\n\n| Optimization | Implementation | Impact |\n|--------------|----------------|--------|\n| **Skip-to-Close** | [BacktestLogicPrivateService.ts:403-409]() | Reduces iterations by ~60x per signal |\n| **Single Candle Fetch** | [BacktestLogicPrivateService.ts:323-329]() | Fetches entire signal duration in one request |\n| **Fast Candle Processing** | `backtest()` method replaces repeated `tick()` calls | O(n) instead of O(n²) for monitoring |\n| **Async Generator** | Streaming results without accumulation | O(1) memory per signal vs O(n) total |\n| **Memoized Clients** | Connection services cache instances | Avoids repeated object creation |\n| **VWAP Buffer** | Pre-fetch buffer candles | Eliminates additional requests during signal |\n| **Early Termination** | User can break generator loop | Stops computation immediately |\n| **Progress Tracking** | [BacktestLogicPrivateService.ts:84-92]() | Enables progress bars without overhead |\n\n### Performance Metrics\n\nThe system tracks duration metrics via `performanceEmitter`:\n\n```mermaid\ngraph LR\n    Start[\"performance.now()\"]\n    \n    subgraph \"Measured Operations\"\n        TimeframeStart[\"Timeframe iteration start\"]\n        TimeframeEnd[\"Timeframe iteration end\"]\n        SignalStart[\"Signal processing start\"]\n        SignalEnd[\"Signal processing end\"]\n        BacktestStart[\"Total backtest start\"]\n        BacktestEnd[\"Total backtest end\"]\n    end\n    \n    TimeframeStart -->|\"measure\"| TimeframeEnd\n    SignalStart -->|\"measure\"| SignalEnd\n    BacktestStart -->|\"measure\"| BacktestEnd\n    \n    TimeframeEnd -->|\"emit {metricType: 'backtest_timeframe'}\"| PerformanceEmitter\n    SignalEnd -->|\"emit {metricType: 'backtest_signal'}\"| PerformanceEmitter\n    BacktestEnd -->|\"emit {metricType: 'backtest_total'}\"| PerformanceEmitter\n    \n    PerformanceEmitter[\"performanceEmitter\"]\n```\n\nMetrics emitted at:\n- [BacktestLogicPrivateService.ts:436-446]() - Timeframe duration\n- [BacktestLogicPrivateService.ts:391-401]() - Signal duration\n- [BacktestLogicPrivateService.ts:466-476]() - Total backtest duration\n\n**Sources:** [src/lib/services/logic/private/BacktestLogicPrivateService.ts:403-409](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:323-329](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:436-476]()\n\n---\n\n## Validation and Error Handling\n\nBefore execution, Backtest Mode validates all schema references:\n\n### Validation Sequence\n\n[Backtest.ts:382-392]():\n```typescript\n// Validate strategy exists\nbacktest.strategyValidationService.validate(context.strategyName, BACKTEST_METHOD_NAME_RUN);\n\n// Validate exchange exists\nbacktest.exchangeValidationService.validate(context.exchangeName, BACKTEST_METHOD_NAME_RUN);\n\n// Validate frame exists\nbacktest.frameValidationService.validate(context.frameName, BACKTEST_METHOD_NAME_RUN);\n\n// Validate risk profiles if specified\nconst { riskName, riskList } = backtest.strategySchemaService.get(context.strategyName);\nriskName && backtest.riskValidationService.validate(riskName, BACKTEST_METHOD_NAME_RUN);\nriskList && riskList.forEach((riskName) => backtest.riskValidationService.validate(riskName, BACKTEST_METHOD_NAME_RUN));\n```\n\n### Error Handling During Execution\n\nErrors during timeframe iteration are caught and handled gracefully:\n\n[BacktestLogicPrivateService.ts:114-129]():\n```typescript\ntry {\n  result = await this.strategyCoreService.tick(symbol, when, true);\n} catch (error) {\n  console.warn(`backtestLogicPrivateService tick failed, skipping timeframe...`);\n  this.loggerService.warn(\"backtestLogicPrivateService tick failed, skipping timeframe\", {\n    symbol,\n    when: when.toISOString(),\n    error: errorData(error),\n    message: getErrorMessage(error),\n  });\n  await errorEmitter.next(error);\n  i++; // Skip this timeframe and continue\n  continue;\n}\n```\n\n**Error Recovery Strategy:**\n1. Log warning with context\n2. Emit error event for user notification\n3. Skip problematic timeframe\n4. Continue with next timeframe\n5. Backtest completes with available data\n\nSimilarly, errors during candle fetching or `backtest()` calls are caught and handled at [BacktestLogicPrivateService.ts:179-202]() and [BacktestLogicPrivateService.ts:367-380]().\n\n**Sources:** [src/classes/Backtest.ts:382-392](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:114-129]()\n\n---\n\n## Comparison with Live Mode\n\n| Aspect | Backtest Mode | Live Mode |\n|--------|---------------|-----------|\n| **Data Source** | Historical (pre-generated timeframes) | Real-time (`new Date()` per tick) |\n| **Iteration** | Finite loop: `while (i < timeframes.length)` | Infinite loop: `while (true)` |\n| **State Persistence** | None (stateless) | Crash-safe persistence via `PersistSignalAdapter` |\n| **Signal Processing** | Fast: `backtest()` processes entire signal | Slow: `tick()` called every 61 seconds |\n| **Yielded Results** | Closed signals only | Opened and closed signals |\n| **Skip Optimization** | Yes (skip to `closeTimestamp`) | No (must check every tick) |\n| **Recovery** | Not needed (stateless) | `waitForInit()` loads persisted state |\n| **Completion** | Finite (ends when data exhausted) | Infinite (runs until stopped) |\n| **Use Case** | Strategy validation, historical analysis | Real-time trading, live monitoring |\n\n**Shared Components:** Both modes use identical validation, schema services, and core strategy/exchange/frame services. The only difference is in the orchestration logic ([BacktestLogicPrivateService.ts]() vs [LiveLogicPrivateService.ts]()).\n\n**Sources:** [src/lib/services/logic/private/BacktestLogicPrivateService.ts:1-481](), [src/lib/services/logic/private/LiveLogicPrivateService.ts:1-179](), [docs/internals.md:54-81]()"
                    },
                    {
                        "page_plan": {
                            "id": "5.2",
                            "title": "Live Trading Mode"
                        },
                        "content": "# Live Trading Mode\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [assets/uml.svg](assets/uml.svg)\n- [docs/classes/WalkerCommandService.md](docs/classes/WalkerCommandService.md)\n- [docs/interfaces/BacktestStatistics.md](docs/interfaces/BacktestStatistics.md)\n- [docs/interfaces/IStrategyCallbacks.md](docs/interfaces/IStrategyCallbacks.md)\n- [docs/interfaces/LiveStatistics.md](docs/interfaces/LiveStatistics.md)\n- [docs/internals.md](docs/internals.md)\n- [docs/types/IStrategyTickResult.md](docs/types/IStrategyTickResult.md)\n- [docs/uml.puml](docs/uml.puml)\n- [scripts/uml.mjs](scripts/uml.mjs)\n- [src/classes/Backtest.ts](src/classes/Backtest.ts)\n- [src/classes/Live.ts](src/classes/Live.ts)\n- [src/classes/Walker.ts](src/classes/Walker.ts)\n- [src/lib/services/logic/private/BacktestLogicPrivateService.ts](src/lib/services/logic/private/BacktestLogicPrivateService.ts)\n- [src/lib/services/logic/private/LiveLogicPrivateService.ts](src/lib/services/logic/private/LiveLogicPrivateService.ts)\n- [src/lib/services/logic/private/WalkerLogicPrivateService.ts](src/lib/services/logic/private/WalkerLogicPrivateService.ts)\n\n</details>\n\n\n\nThis page documents the live trading execution mode, which runs trading strategies in real-time against live market data. Live mode features an infinite loop architecture, crash-safe state persistence, automatic recovery after process restarts, and graceful shutdown mechanics.\n\nFor an overview of all execution modes and when to use each, see [Execution Modes Overview](#2.2). For detailed information about persistence and crash recovery mechanisms, see [Crash Recovery and Persistence](#9.1). For backtest simulation mode, see [Backtest Mode](#5.1).\n\n---\n\n## Architecture Overview\n\nLive mode implements a continuous monitoring system that executes indefinitely until manually stopped. Unlike backtest mode which iterates through pre-generated timeframes, live mode creates real-time dates and sleeps between iterations.\n\n```mermaid\ngraph TB\n    subgraph \"Public API Layer\"\n        LiveUtils[\"Live.run()<br/>Live.background()<br/>Live.stop()\"]\n        LiveInstance[\"LiveInstance<br/>Per symbol-strategy\"]\n    end\n    \n    subgraph \"Command Layer\"\n        LiveCommandService[\"LiveCommandService<br/>Validation wrapper\"]\n    end\n    \n    subgraph \"Logic Layer\"\n        LiveLogicPublicService[\"LiveLogicPublicService<br/>Context setup\"]\n        LiveLogicPrivateService[\"LiveLogicPrivateService<br/>Infinite generator\"]\n    end\n    \n    subgraph \"Core Execution\"\n        StrategyCoreService[\"StrategyCoreService.tick()<br/>Signal lifecycle\"]\n        PersistSignalAdapter[\"PersistSignalAdapter<br/>Atomic file writes\"]\n        ClientStrategy[\"ClientStrategy.waitForInit()<br/>State recovery\"]\n    end\n    \n    subgraph \"Time Management\"\n        RealTime[\"new Date()<br/>Current timestamp\"]\n        Sleep[\"sleep(TICK_TTL)<br/>61 seconds\"]\n    end\n    \n    subgraph \"Stop Mechanism\"\n        StopFlag[\"_isStopped flag\"]\n        GracefulWait[\"Wait for 'closed' action<br/>No forced exit\"]\n    end\n    \n    LiveUtils --> LiveInstance\n    LiveInstance --> LiveCommandService\n    LiveCommandService --> LiveLogicPublicService\n    LiveLogicPublicService --> LiveLogicPrivateService\n    \n    LiveLogicPrivateService --> RealTime\n    LiveLogicPrivateService --> StrategyCoreService\n    LiveLogicPrivateService --> Sleep\n    LiveLogicPrivateService --> StopFlag\n    \n    StrategyCoreService --> ClientStrategy\n    StrategyCoreService --> PersistSignalAdapter\n    \n    ClientStrategy --> PersistSignalAdapter\n    \n    StopFlag --> GracefulWait\n    GracefulWait --> LiveLogicPrivateService\n    \n    style LiveLogicPrivateService fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style PersistSignalAdapter fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style ClientStrategy fill:#f9f9f9,stroke:#333,stroke-width:2px\n```\n\n**Sources**: [src/classes/Live.ts:1-607](), [src/lib/services/logic/private/LiveLogicPrivateService.ts:1-179]()\n\n---\n\n## Infinite Loop Execution\n\nLive mode uses an infinite `while(true)` loop in `LiveLogicPrivateService.run()` that never completes naturally. Each iteration processes a single tick at the current real-time moment.\n\n### Loop Structure\n\n```mermaid\ngraph TB\n    Start[\"while(true) loop begins\"]\n    CreateDate[\"when = new Date()<br/>Real-time timestamp\"]\n    Tick[\"strategyCoreService.tick()<br/>symbol, when, backtest=false\"]\n    CheckAction{\"result.action\"}\n    \n    Idle[\"action === 'idle'<br/>Check stop flag\"]\n    Active[\"action === 'active'<br/>Skip yield\"]\n    Scheduled[\"action === 'scheduled'<br/>Skip yield\"]\n    Opened[\"action === 'opened'<br/>Yield result\"]\n    Closed[\"action === 'closed'<br/>Yield result\"]\n    \n    CheckStop{\"_isStopped?\"}\n    Break[\"break loop<br/>Exit gracefully\"]\n    Sleep[\"sleep(TICK_TTL)<br/>61 seconds\"]\n    Continue[\"Continue to next iteration\"]\n    \n    Start --> CreateDate\n    CreateDate --> Tick\n    Tick --> CheckAction\n    \n    CheckAction -->|idle| Idle\n    CheckAction -->|active| Active\n    CheckAction -->|scheduled| Scheduled\n    CheckAction -->|opened| Opened\n    CheckAction -->|closed| Closed\n    \n    Idle --> CheckStop\n    CheckStop -->|true| Break\n    CheckStop -->|false| Sleep\n    \n    Active --> Sleep\n    Scheduled --> Sleep\n    Opened --> Sleep\n    \n    Closed --> CheckStop\n    \n    Sleep --> Continue\n    Continue --> CreateDate\n```\n\n**Sources**: [src/lib/services/logic/private/LiveLogicPrivateService.ts:63-175]()\n\n### Tick Interval\n\nThe constant `TICK_TTL` defines the sleep duration between iterations:\n\n```typescript\nconst TICK_TTL = 1 * 60 * 1_000 + 1; // 61 seconds\n```\n\nThis 61-second interval (one minute plus one second buffer) ensures ticks are spaced for minute-based candle monitoring. The logic sleeps after every tick result, regardless of signal state.\n\n**Sources**: [src/lib/services/logic/private/LiveLogicPrivateService.ts:14]()\n\n### Real-Time Date Creation\n\nUnlike backtest mode which uses pre-generated timeframes, live mode creates timestamps dynamically:\n\n```typescript\nconst when = new Date(); // Current real-time moment\n```\n\nThis `when` variable is passed to `strategyCoreService.tick()` as the execution timestamp. This enables `ExecutionContextService` to provide the correct time to strategy callbacks via `getDate()`.\n\n**Sources**: [src/lib/services/logic/private/LiveLogicPrivateService.ts:72]()\n\n### Yielded Results\n\nThe generator yields only `opened` and `closed` results. The `idle`, `active`, and `scheduled` states are not yielded to consumers:\n\n| Action | Yielded | Reason |\n|--------|---------|--------|\n| `idle` | No | No position exists, nothing to report |\n| `scheduled` | No | Delayed entry signal, not yet activated |\n| `opened` | Yes | New position opened, consumer needs notification |\n| `active` | No | Position monitoring in progress, no state change |\n| `closed` | Yes | Position closed with PNL, final result |\n| `cancelled` | No | Scheduled signal cancelled without opening |\n\n**Sources**: [src/lib/services/logic/private/LiveLogicPrivateService.ts:118-153]()\n\n---\n\n## Crash-Safe Persistence\n\nLive mode persists signal state to disk after every tick, enabling recovery after process crashes or restarts. This \"persist-and-restart\" architecture ensures no trading data is lost.\n\n### Persistence Flow\n\n```mermaid\ngraph LR\n    Tick[\"tick() called\"]\n    GetSignal[\"getSignal() checks state\"]\n    WaitInit[\"waitForInit() loads from disk\"]\n    ProcessTick[\"Process signal logic\"]\n    SetPending[\"setPendingSignal() saves state\"]\n    WriteFile[\"PersistSignalAdapter.writeSignalData()\"]\n    AtomicWrite[\"Atomic file write<br/>./dump/persist/\"]\n    \n    Tick --> GetSignal\n    GetSignal --> WaitInit\n    WaitInit --> ProcessTick\n    ProcessTick --> SetPending\n    SetPending --> WriteFile\n    WriteFile --> AtomicWrite\n    \n    style WaitInit fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style AtomicWrite fill:#f9f9f9,stroke:#333,stroke-width:2px\n```\n\n**Sources**: [docs/internals.md:68-81]()\n\n### PersistSignalAdapter\n\nThe `PersistSignalAdapter` class handles atomic file writes to prevent corruption during crashes. Each symbol-strategy pair has its own JSON file:\n\n**File Path Pattern**: `./dump/persist/{symbol}_{strategyName}.json`\n\nThe adapter performs:\n1. Serialization of signal state to JSON\n2. Atomic write to temporary file\n3. Rename to final filename (atomic operation)\n\n**Sources**: Referenced in [src/lib/services/logic/private/LiveLogicPrivateService.ts](), implementation in persistence layer\n\n### Persisted Data Structure\n\nThe following signal properties are persisted:\n\n| Property | Type | Purpose |\n|----------|------|---------|\n| `id` | string | Unique signal identifier |\n| `type` | \"long\" \\| \"short\" | Position direction |\n| `priceOpen` | number | Entry price (VWAP) |\n| `takeProfit` | number | TP target price |\n| `stopLoss` | number | SL exit price |\n| `quantityOpen` | number | Position size |\n| `timestampOpen` | number | Entry timestamp |\n| `minuteEstimatedTime` | number | Max duration |\n\n**Sources**: Signal structure defined in strategy interface\n\n---\n\n## State Recovery with waitForInit\n\nWhen a live process starts (or restarts after crash), `ClientStrategy.waitForInit()` recovers the persisted state before processing the first tick.\n\n### Recovery Sequence\n\n```mermaid\nsequenceDiagram\n    participant Process as \"New Process Start\"\n    participant CS as \"ClientStrategy\"\n    participant PSA as \"PersistSignalAdapter\"\n    participant FS as \"File System\"\n    \n    Process->>CS: First tick() call\n    CS->>CS: waitForInit() runs once\n    CS->>PSA: readSignalData(symbol, strategyName)\n    PSA->>FS: Read JSON file\n    FS-->>PSA: Signal data or null\n    PSA-->>CS: Restore signal state\n    CS->>CS: Mark initialized\n    CS->>CS: Continue normal tick processing\n```\n\n**Sources**: [docs/internals.md:76]()\n\n### Initialization Pattern\n\nThe `waitForInit()` method uses the singleshot pattern from `functools-kit` to ensure it runs exactly once per instance:\n\n1. First tick triggers `waitForInit()`\n2. Method reads persisted file\n3. If file exists, restores signal to in-memory state\n4. If file doesn't exist, starts fresh (idle state)\n5. Method completes and never runs again\n\nThis ensures recovery is transparent - the strategy continues from its exact state before the crash.\n\n**Sources**: [docs/internals.md:49-50]()\n\n---\n\n## Graceful Shutdown\n\nLive mode supports graceful shutdown that waits for open positions to close naturally before stopping the process. This prevents forced exits that could leave positions unmonitored.\n\n### Stop Flag Mechanism\n\nThe `LiveInstance` class maintains two internal flags:\n\n```typescript\n_isStopped: boolean  // User requested stop\n_isDone: boolean     // Process completed\n```\n\nCalling `Live.stop()` or the cancellation closure sets `_isStopped = true`. The main loop checks this flag at safe points.\n\n**Sources**: [src/classes/Live.ts:82-86]()\n\n### Safe Stop Points\n\nThe loop checks the stop flag at two locations:\n\n1. **Idle state** - No active position exists, safe to exit immediately:\n   ```typescript\n   if (result.action === \"idle\") {\n     if (await strategyCoreService.getStopped(symbol, strategyName)) {\n       break; // Exit loop immediately\n     }\n   }\n   ```\n\n2. **After closed** - Position just closed, safe to exit:\n   ```typescript\n   if (result.action === \"closed\") {\n     if (await strategyCoreService.getStopped(symbol, strategyName)) {\n       break; // Exit after position closed\n     }\n   }\n   ```\n\n**Sources**: [src/lib/services/logic/private/LiveLogicPrivateService.ts:118-171]()\n\n### Stop Flow Diagram\n\n```mermaid\ngraph TB\n    UserCall[\"User calls Live.stop()<br/>or cancellation closure\"]\n    SetFlag[\"Set _isStopped = true<br/>in strategyCoreService\"]\n    \n    CheckIdle{\"Current state<br/>is idle?\"}\n    ExitImmediate[\"break loop<br/>Exit immediately\"]\n    \n    CheckActive{\"Current state<br/>is active/scheduled?\"}\n    WaitClose[\"Continue monitoring<br/>Wait for position close\"]\n    \n    CheckClosed{\"Position<br/>closed?\"}\n    ExitGraceful[\"break loop<br/>Exit after close\"]\n    \n    ContinueLoop[\"Continue loop<br/>Keep monitoring\"]\n    \n    UserCall --> SetFlag\n    SetFlag --> CheckIdle\n    \n    CheckIdle -->|Yes| ExitImmediate\n    CheckIdle -->|No| CheckActive\n    \n    CheckActive -->|Yes| WaitClose\n    CheckActive -->|No| ContinueLoop\n    \n    WaitClose --> CheckClosed\n    CheckClosed -->|Yes| ExitGraceful\n    CheckClosed -->|No| ContinueLoop\n    \n    ContinueLoop --> CheckIdle\n```\n\n**Sources**: [src/classes/Live.ts:30-56](), [src/lib/services/logic/private/LiveLogicPrivateService.ts:118-171]()\n\n### Background Task Completion\n\nThe `INSTANCE_TASK_FN` handles cleanup after the loop exits:\n\n```typescript\nfor await (const signal of self.run(symbol, context)) {\n  if (signal?.action === \"closed\" && self._isStopped) {\n    break; // Exit when position closed and stop requested\n  }\n}\nif (!self._isDone) {\n  await doneLiveSubject.next({ ... }); // Emit completion event\n}\nself._isDone = true;\n```\n\nThis ensures the `doneLiveSubject` event fires exactly once, even if the process crashes during shutdown.\n\n**Sources**: [src/classes/Live.ts:30-56]()\n\n---\n\n## LiveLogicPrivateService Implementation\n\nThe `LiveLogicPrivateService` class contains the core implementation of the infinite generator pattern. This service is injected into `LiveLogicPublicService` which wraps it with context management.\n\n### Class Dependencies\n\n| Service | Purpose |\n|---------|---------|\n| `LoggerService` | Structured logging with context |\n| `StrategyCoreService` | Strategy execution (tick calls) |\n| `MethodContextService` | Strategy/exchange name context |\n\n**Sources**: [src/lib/services/logic/private/LiveLogicPrivateService.ts:32-39]()\n\n### run() Method Implementation\n\nThe `run()` method is an async generator that yields `IStrategyTickResultOpened` or `IStrategyTickResultClosed`:\n\n```mermaid\ngraph TB\n    Start[\"async *run(symbol: string)\"]\n    InitTime[\"previousEventTimestamp = null\"]\n    WhileTrue[\"while(true)\"]\n    \n    StartTick[\"tickStartTime = performance.now()\"]\n    CreateDate[\"when = new Date()\"]\n    CallTick[\"result = await strategyCoreService.tick()\"]\n    \n    ErrorCatch[\"catch error\"]\n    LogError[\"Log error with errorEmitter\"]\n    SleepError[\"await sleep(TICK_TTL)\"]\n    ContinueError[\"continue loop\"]\n    \n    TrackPerf[\"Emit performanceEmitter event<br/>metricType: 'live_tick'\"]\n    \n    CheckAction{\"result.action\"}\n    HandleIdle[\"Check stop flag<br/>sleep(TICK_TTL)<br/>continue\"]\n    HandleActive[\"sleep(TICK_TTL)<br/>continue\"]\n    HandleScheduled[\"sleep(TICK_TTL)<br/>continue\"]\n    HandleOpened[\"yield result<br/>sleep(TICK_TTL)\"]\n    HandleClosed[\"yield result<br/>Check stop flag<br/>sleep(TICK_TTL)\"]\n    \n    Start --> InitTime\n    InitTime --> WhileTrue\n    WhileTrue --> StartTick\n    StartTick --> CreateDate\n    CreateDate --> CallTick\n    \n    CallTick -->|error| ErrorCatch\n    ErrorCatch --> LogError\n    LogError --> SleepError\n    SleepError --> ContinueError\n    ContinueError --> WhileTrue\n    \n    CallTick -->|success| TrackPerf\n    TrackPerf --> CheckAction\n    \n    CheckAction -->|idle| HandleIdle\n    CheckAction -->|active| HandleActive\n    CheckAction -->|scheduled| HandleScheduled\n    CheckAction -->|opened| HandleOpened\n    CheckAction -->|closed| HandleClosed\n    \n    HandleIdle --> WhileTrue\n    HandleActive --> WhileTrue\n    HandleScheduled --> WhileTrue\n    HandleOpened --> WhileTrue\n    HandleClosed --> WhileTrue\n    \n    style CallTick fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style TrackPerf fill:#f9f9f9,stroke:#333,stroke-width:2px\n```\n\n**Sources**: [src/lib/services/logic/private/LiveLogicPrivateService.ts:63-175]()\n\n### Error Handling\n\nWhen `tick()` throws an error, the service:\n\n1. Logs the error with `errorData()` and `getErrorMessage()`\n2. Emits to `errorEmitter` for external handling\n3. Sleeps for `TICK_TTL` to avoid rapid retry loops\n4. Continues to next iteration (doesn't break loop)\n\nThis resilient design ensures temporary errors (network issues, API rate limits) don't crash the process.\n\n**Sources**: [src/lib/services/logic/private/LiveLogicPrivateService.ts:75-95]()\n\n### Performance Tracking\n\nEach tick duration is tracked and emitted:\n\n```typescript\nawait performanceEmitter.next({\n  timestamp: currentTimestamp,\n  previousTimestamp: previousEventTimestamp,\n  metricType: \"live_tick\",\n  duration: tickEndTime - tickStartTime,\n  strategyName: this.methodContextService.context.strategyName,\n  exchangeName: this.methodContextService.context.exchangeName,\n  symbol,\n  backtest: false\n});\n```\n\nThis enables monitoring of tick execution time for performance analysis.\n\n**Sources**: [src/lib/services/logic/private/LiveLogicPrivateService.ts:103-115]()\n\n---\n\n## Live vs Backtest Comparison\n\nThe following table highlights key differences between live and backtest execution modes:\n\n| Aspect | Live Mode | Backtest Mode |\n|--------|-----------|---------------|\n| **Loop Type** | `while(true)` infinite | `for` loop over timeframes |\n| **Time Source** | `new Date()` real-time | Pre-generated timeframe array |\n| **Completion** | Never (manual stop only) | When timeframes exhausted |\n| **Sleep** | `sleep(TICK_TTL)` after each tick | None (fast processing) |\n| **Persistence** | Atomic writes after every tick | None (in-memory only) |\n| **Recovery** | `waitForInit()` on start | None needed |\n| **Yielded Results** | `opened`, `closed` only | `closed` only |\n| **Candle Processing** | Tick-by-tick monitoring | `backtest()` fast batch |\n| **Stop Mechanism** | Graceful wait for position close | Immediate at idle or after close |\n| **Event Emitters** | `signalLiveEmitter` | `signalBacktestEmitter` |\n| **Backtest Flag** | `false` | `true` |\n\n**Sources**: [src/lib/services/logic/private/LiveLogicPrivateService.ts:1-179](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:1-481]()\n\n---\n\n## Event System\n\nLive mode emits several events during execution for external monitoring and integration.\n\n### Signal Events\n\n| Emitter | Event Type | Trigger | Payload |\n|---------|-----------|---------|---------|\n| `signalEmitter` | All signals | Every tick result | `IStrategyTickResult` |\n| `signalLiveEmitter` | Live signals only | Filtered: backtest=false | `IStrategyTickResult` |\n| `doneLiveSubject` | Completion | Loop exits | `DoneContract` |\n| `performanceEmitter` | Performance metric | After each tick | `PerformanceContract` |\n| `errorEmitter` | Recoverable error | tick() throws | Error object |\n\n**Sources**: [src/lib/services/logic/private/LiveLogicPrivateService.ts:6](), [docs/internals.md:84-89]()\n\n### Event Listener Usage\n\nUsers can subscribe to events using the public listener API:\n\n```typescript\n// Listen to all live signals\nlistenSignalLive((result) => {\n  console.log(result.action, result.symbol);\n});\n\n// Listen to live completion\nlistenDoneLive((contract) => {\n  console.log(\"Live trading stopped:\", contract.symbol);\n});\n\n// Monitor errors\nlistenError((error) => {\n  console.error(\"Recoverable error:\", error);\n});\n```\n\nAll listeners use queued processing from `functools-kit` to ensure sequential execution even with async callbacks.\n\n**Sources**: [docs/internals.md:84-89]()\n\n---\n\n## API Usage Examples\n\n### Running Live Trading with run()\n\nThe `Live.run()` method returns an async generator that yields opened and closed signals:\n\n```typescript\n// Infinite generator - use Ctrl+C to stop\nfor await (const result of Live.run(\"BTCUSDT\", {\n  strategyName: \"my-strategy\",\n  exchangeName: \"my-exchange\"\n})) {\n  if (result.action === \"opened\") {\n    console.log(\"Position opened:\", result.signal.priceOpen);\n  } else if (result.action === \"closed\") {\n    console.log(\"Position closed, PNL:\", result.pnl.pnlPercentage);\n  }\n}\n```\n\n**File Reference**: [src/classes/Live.ts:394-414]()\n\n### Running in Background with background()\n\nThe `Live.background()` method runs without yielding, consuming results internally. It returns a cancellation function:\n\n```typescript\n// Start live trading in background\nconst cancel = Live.background(\"BTCUSDT\", {\n  strategyName: \"my-strategy\",\n  exchangeName: \"my-exchange\"\n});\n\n// Use event listeners for monitoring\nlistenSignalLive((result) => {\n  console.log(\"Event:\", result.action);\n});\n\n// Stop gracefully when needed\n// cancel();\n```\n\n**File Reference**: [src/classes/Live.ts:437-455]()\n\n### Graceful Stop\n\nCall `Live.stop()` to initiate graceful shutdown:\n\n```typescript\n// Request stop - will wait for position to close\nawait Live.stop(\"BTCUSDT\", \"my-strategy\");\n\n// Or use cancellation closure from background()\nconst cancel = Live.background(\"BTCUSDT\", { ... });\ncancel(); // Same graceful behavior\n```\n\n**File Reference**: [src/classes/Live.ts:474-485]()\n\n### Instance Management\n\nThe `LiveUtils` class uses memoization to maintain separate instances per symbol-strategy pair:\n\n```typescript\n// Each symbol-strategy gets isolated instance\nconst btcInstance = Live.run(\"BTCUSDT\", { strategyName: \"strat-a\", ... });\nconst ethInstance = Live.run(\"ETHUSDT\", { strategyName: \"strat-a\", ... });\n\n// List all active instances with status\nconst statusList = await Live.list();\nstatusList.forEach(status => {\n  console.log(`${status.symbol} - ${status.strategyName}: ${status.status}`);\n});\n```\n\n**File Reference**: [src/classes/Live.ts:377-382](), [src/classes/Live.ts:585-588]()\n\n### Crash Recovery Example\n\nLive mode automatically recovers after crashes:\n\n```typescript\n// First run - process crashes mid-execution\nLive.background(\"BTCUSDT\", { strategyName: \"my-strategy\", ... });\n// Position opens, state persisted to disk\n// Process crashes...\n\n// Second run - same code, automatic recovery\nLive.background(\"BTCUSDT\", { strategyName: \"my-strategy\", ... });\n// waitForInit() reads persisted state\n// Continues monitoring from last known state\n// Position closes normally\n```\n\nNo code changes needed - recovery is automatic via `waitForInit()` and `PersistSignalAdapter`.\n\n**Sources**: [docs/internals.md:76]()\n\n---\n\n## Reporting and Statistics\n\nLive mode provides statistical analysis of trading performance through `LiveMarkdownService`.\n\n### Statistics Data Structure\n\nThe `LiveStatistics` interface provides comprehensive metrics:\n\n| Metric | Type | Description |\n|--------|------|-------------|\n| `eventList` | `TickEvent[]` | All events (idle, opened, active, closed) |\n| `totalEvents` | `number` | Count of all events |\n| `totalClosed` | `number` | Count of closed signals |\n| `winCount` | `number` | Winning signals (PNL > 0) |\n| `lossCount` | `number` | Losing signals (PNL < 0) |\n| `winRate` | `number \\| null` | Win rate percentage (0-100) |\n| `avgPnl` | `number \\| null` | Average PNL per signal |\n| `totalPnl` | `number \\| null` | Cumulative PNL |\n| `stdDev` | `number \\| null` | Standard deviation of returns |\n| `sharpeRatio` | `number \\| null` | Risk-adjusted return metric |\n| `annualizedSharpeRatio` | `number \\| null` | Annualized Sharpe ratio |\n| `certaintyRatio` | `number \\| null` | avgWin / \\|avgLoss\\| |\n| `expectedYearlyReturns` | `number \\| null` | Projected annual returns |\n\n**Sources**: [docs/interfaces/LiveStatistics.md:1-118]()\n\n### Accessing Statistics\n\n```typescript\n// Get statistical data\nconst stats = await Live.getData(\"BTCUSDT\", \"my-strategy\");\nconsole.log(\"Win rate:\", stats.winRate);\nconsole.log(\"Sharpe ratio:\", stats.sharpeRatio);\n\n// Generate markdown report\nconst report = await Live.getReport(\"BTCUSDT\", \"my-strategy\");\nconsole.log(report);\n\n// Save report to disk\nawait Live.dump(\"BTCUSDT\", \"my-strategy\", \"./reports\");\n```\n\n**File Reference**: [src/classes/Live.ts:500-511](), [src/classes/Live.ts:526-537](), [src/classes/Live.ts:555-570]()\n\n---\n\n**Sources**: [src/classes/Live.ts:1-607](), [src/lib/services/logic/private/LiveLogicPrivateService.ts:1-179](), [docs/internals.md:68-81](), [docs/interfaces/LiveStatistics.md:1-118]()"
                    },
                    {
                        "page_plan": {
                            "id": "5.3",
                            "title": "Walker Mode"
                        },
                        "content": "# Walker Mode\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [src/classes/Backtest.ts](src/classes/Backtest.ts)\n- [src/classes/Live.ts](src/classes/Live.ts)\n- [src/classes/Walker.ts](src/classes/Walker.ts)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [src/lib/services/logic/private/BacktestLogicPrivateService.ts](src/lib/services/logic/private/BacktestLogicPrivateService.ts)\n- [src/lib/services/logic/private/LiveLogicPrivateService.ts](src/lib/services/logic/private/LiveLogicPrivateService.ts)\n- [src/lib/services/logic/private/WalkerLogicPrivateService.ts](src/lib/services/logic/private/WalkerLogicPrivateService.ts)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\nWalker Mode provides strategy comparison and A/B testing capabilities by executing multiple backtests sequentially and ranking strategies by a chosen metric. This execution mode automates the process of running the same backtest configuration across different strategies and identifying the best performer.\n\nFor general execution mode concepts, see [Execution Modes Overview](#2.2). For individual backtest mechanics, see [Backtest Mode](#5.1). For LLM-based strategy generation, see [Optimizer Mode](#5.4).\n\n**Sources**: [src/classes/Walker.ts:1-678](), [src/lib/services/logic/private/WalkerLogicPrivateService.ts:1-263]()\n\n## Overview\n\nWalker Mode executes backtests sequentially for a list of strategies, tracking the best-performing strategy in real-time. It yields progress updates after each strategy completes, allowing consumers to monitor comparison progress or terminate early.\n\n### Key Components\n\n| Component | Location | Purpose |\n|-----------|----------|---------|\n| `WalkerUtils` | [src/classes/Walker.ts:418-660]() | Singleton utility class with validation |\n| `WalkerInstance` | [src/classes/Walker.ts:71-397]() | Per-symbol-walker instance with state management |\n| `WalkerLogicPrivateService` | [src/lib/services/logic/private/WalkerLogicPrivateService.ts:29-260]() | Core sequential execution and metric comparison |\n| `BacktestLogicPublicService` | [src/lib/services/logic/public/BacktestLogicPublicService.ts]() | Delegates to individual backtests |\n| `BacktestMarkdownService` | [src/lib/services/markdown/BacktestMarkdownService.ts]() | Retrieves strategy statistics |\n| `WalkerMarkdownService` | [src/lib/services/markdown/WalkerMarkdownService.ts]() | Aggregates comparison results |\n\n**Sources**: [src/classes/Walker.ts:1-678](), [src/lib/services/logic/private/WalkerLogicPrivateService.ts:1-263]()\n\n## Walker Schema Configuration\n\nWalker Mode requires registration via `addWalker()` with an `IWalkerSchema` configuration:\n\n```typescript\ninterface IWalkerSchema {\n  walkerName: WalkerName;\n  strategies: StrategyName[];\n  metric: WalkerMetric;\n  exchangeName: ExchangeName;\n  frameName: FrameName;\n  note?: string;\n  callbacks?: Partial<IWalkerCallbacks>;\n}\n```\n\n### Available Metrics\n\nThe `metric` field determines which strategy statistic is used for comparison:\n\n```typescript\ntype WalkerMetric = \n  | \"sharpeRatio\"\n  | \"winRate\" \n  | \"profitFactor\"\n  | \"maxDrawdownPercent\"\n  | \"totalPnlPercent\"\n  | \"avgPnlPercent\"\n  | \"totalTrades\";\n```\n\nHigher values are always considered better. The walker selects the strategy with the maximum metric value.\n\n### Lifecycle Callbacks\n\n```typescript\ninterface IWalkerCallbacks {\n  onStrategyStart: (strategyName: string, symbol: string) => void;\n  onStrategyComplete: (strategyName: string, symbol: string, stats: BacktestStatistics, metricValue: number | null) => Promise<void> | void;\n  onStrategyError: (strategyName: string, symbol: string, error: unknown) => void;\n  onComplete: (results: IWalkerResults) => void;\n}\n```\n\nCallbacks fire at key points during walker execution: before starting each strategy, after completing each strategy, on strategy errors, and when all strategies finish.\n\n**Sources**: [types.d.ts:1385-1520](), [src/function/add.ts:200-250]()\n\n## Execution Flow\n\n### High-Level Walker Execution\n\n```mermaid\ngraph TB\n    START[\"Walker.run(symbol, {walkerName})\"]\n    VALIDATE[\"WalkerValidationService<br/>Validate walkerName\"]\n    GET_SCHEMA[\"WalkerSchemaService.get()<br/>Retrieve walker configuration\"]\n    VALIDATE_DEPS[\"Validate dependencies:<br/>- exchangeName<br/>- frameName<br/>- all strategies\"]\n    CLEAR_STATE[\"Clear state for all strategies:<br/>- BacktestMarkdownService<br/>- ScheduleMarkdownService<br/>- StrategyCoreService<br/>- RiskGlobalService\"]\n    WALKER_CMD[\"WalkerCommandService.run()<br/>Delegate to WalkerLogicPrivateService\"]\n    \n    START --> VALIDATE\n    VALIDATE --> GET_SCHEMA\n    GET_SCHEMA --> VALIDATE_DEPS\n    VALIDATE_DEPS --> CLEAR_STATE\n    CLEAR_STATE --> WALKER_CMD\n    \n    subgraph \"WalkerLogicPrivateService.run()\"\n        INIT[\"Initialize tracking:<br/>bestMetric = null<br/>bestStrategy = null<br/>strategiesTested = 0\"]\n        SUBSCRIBE[\"Subscribe to walkerStopSubject<br/>Filter by symbol + walkerName\"]\n        LOOP_START[\"for each strategy in strategies[]\"]\n        CHECK_STOP[\"Check if stopped<br/>via stoppedStrategies Set\"]\n        CALLBACK_START[\"Call onStrategyStart callback\"]\n        RUN_BACKTEST[\"BacktestLogicPublicService.run()<br/>Execute backtest for strategy\"]\n        GET_STATS[\"BacktestMarkdownService.getData()<br/>Retrieve statistics\"]\n        EXTRACT_METRIC[\"Extract metric value<br/>from stats[metric]\"]\n        COMPARE[\"Compare with bestMetric<br/>Update if metricValue > bestMetric\"]\n        INCREMENT[\"strategiesTested++\"]\n        EMIT_PROGRESS[\"Emit progressWalkerEmitter\"]\n        CALLBACK_COMPLETE[\"Call onStrategyComplete callback\"]\n        EMIT_WALKER[\"Emit walkerEmitter\"]\n        YIELD[\"yield WalkerContract\"]\n        LOOP_END[\"Next strategy\"]\n        UNSUBSCRIBE[\"Unsubscribe from walkerStopSubject\"]\n        CALLBACK_FINAL[\"Call onComplete callback\"]\n        EMIT_COMPLETE[\"Emit walkerCompleteSubject\"]\n        \n        WALKER_CMD --> INIT\n        INIT --> SUBSCRIBE\n        SUBSCRIBE --> LOOP_START\n        LOOP_START --> CHECK_STOP\n        CHECK_STOP -->|stopped| UNSUBSCRIBE\n        CHECK_STOP -->|continue| CALLBACK_START\n        CALLBACK_START --> RUN_BACKTEST\n        RUN_BACKTEST -->|error| CALLBACK_COMPLETE\n        RUN_BACKTEST -->|success| GET_STATS\n        GET_STATS --> EXTRACT_METRIC\n        EXTRACT_METRIC --> COMPARE\n        COMPARE --> INCREMENT\n        INCREMENT --> EMIT_PROGRESS\n        EMIT_PROGRESS --> CALLBACK_COMPLETE\n        CALLBACK_COMPLETE --> EMIT_WALKER\n        EMIT_WALKER --> YIELD\n        YIELD --> LOOP_END\n        LOOP_END --> LOOP_START\n        LOOP_START -->|done| UNSUBSCRIBE\n        UNSUBSCRIBE --> CALLBACK_FINAL\n        CALLBACK_FINAL --> EMIT_COMPLETE\n    end\n    \n    style WALKER_CMD fill:#e1f5ff,stroke:#333,stroke-width:3px\n    style YIELD fill:#fff4e1,stroke:#333,stroke-width:2px\n    style COMPARE fill:#ffe1e1,stroke:#333,stroke-width:2px\n```\n\n**Sources**: [src/classes/Walker.ts:144-193](), [src/lib/services/logic/private/WalkerLogicPrivateService.ts:68-260]()\n\n### Sequential Backtest Execution\n\n```mermaid\ngraph LR\n    subgraph \"Strategy 1\"\n        S1_START[\"onStrategyStart\"]\n        S1_BT[\"Run Backtest\"]\n        S1_STATS[\"Get Statistics\"]\n        S1_COMPARE[\"Compare Metric\"]\n        S1_YIELD[\"Yield Progress\"]\n        S1_COMPLETE[\"onStrategyComplete\"]\n        \n        S1_START --> S1_BT\n        S1_BT --> S1_STATS\n        S1_STATS --> S1_COMPARE\n        S1_COMPARE --> S1_YIELD\n        S1_YIELD --> S1_COMPLETE\n    end\n    \n    subgraph \"Strategy 2\"\n        S2_START[\"onStrategyStart\"]\n        S2_BT[\"Run Backtest\"]\n        S2_STATS[\"Get Statistics\"]\n        S2_COMPARE[\"Compare Metric\"]\n        S2_YIELD[\"Yield Progress\"]\n        S2_COMPLETE[\"onStrategyComplete\"]\n        \n        S2_START --> S2_BT\n        S2_BT --> S2_STATS\n        S2_STATS --> S2_COMPARE\n        S2_COMPARE --> S2_YIELD\n        S2_YIELD --> S2_COMPLETE\n    end\n    \n    subgraph \"Strategy N\"\n        SN_START[\"onStrategyStart\"]\n        SN_BT[\"Run Backtest\"]\n        SN_STATS[\"Get Statistics\"]\n        SN_COMPARE[\"Compare Metric\"]\n        SN_YIELD[\"Yield Progress\"]\n        SN_COMPLETE[\"onStrategyComplete\"]\n        \n        SN_START --> SN_BT\n        SN_BT --> SN_STATS\n        SN_STATS --> SN_COMPARE\n        SN_COMPARE --> SN_YIELD\n        SN_YIELD --> SN_COMPLETE\n    end\n    \n    S1_COMPLETE --> S2_START\n    S2_COMPLETE -.->|...| SN_START\n    SN_COMPLETE --> FINAL[\"onComplete<br/>walkerCompleteSubject\"]\n```\n\nEach strategy executes a complete backtest before the next strategy begins. Progress is yielded after each strategy completes, not during individual strategy execution.\n\n**Sources**: [src/lib/services/logic/private/WalkerLogicPrivateService.ts:115-232]()\n\n## Strategy Comparison Logic\n\n### Metric Extraction and Comparison\n\nThe walker retrieves statistics from `BacktestMarkdownService` for each completed strategy and extracts the configured metric value:\n\n```typescript\n// Get statistics from BacktestMarkdownService\nconst stats = await this.backtestMarkdownService.getData(symbol, strategyName);\n\n// Extract metric value\nconst value = stats[metric];\nconst metricValue = \n  value !== null && \n  value !== undefined && \n  typeof value === \"number\" && \n  !isNaN(value) && \n  isFinite(value) \n    ? value \n    : null;\n\n// Update best strategy if needed\nconst isBetter = \n  bestMetric === null || \n  (metricValue !== null && metricValue > bestMetric);\n\nif (isBetter && metricValue !== null) {\n  bestMetric = metricValue;\n  bestStrategy = strategyName;\n}\n```\n\nInvalid metric values (null, undefined, NaN, Infinity) are treated as `null` and never considered best. The comparison always uses `>` (greater than), so higher values win.\n\n**Sources**: [src/lib/services/logic/private/WalkerLogicPrivateService.ts:169-190]()\n\n### WalkerContract Structure\n\nAfter each strategy completes, the walker yields a `WalkerContract` with progress and current best:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `walkerName` | `string` | Walker identifier |\n| `exchangeName` | `string` | Exchange used for backtests |\n| `frameName` | `string` | Frame used for backtests |\n| `symbol` | `string` | Trading pair symbol |\n| `strategyName` | `string` | Strategy just completed |\n| `stats` | `BacktestStatistics` | Full statistics for completed strategy |\n| `metricValue` | `number \\| null` | Extracted metric value |\n| `metric` | `WalkerMetric` | Metric being compared |\n| `bestMetric` | `number \\| null` | Best metric value so far |\n| `bestStrategy` | `string \\| null` | Best strategy name so far |\n| `strategiesTested` | `number` | Number of strategies completed |\n| `totalStrategies` | `number` | Total strategies to test |\n\n**Sources**: [src/contract/Walker.contract.ts:1-20](), [src/lib/services/logic/private/WalkerLogicPrivateService.ts:194-207]()\n\n### Final Results Structure\n\nWhen all strategies complete, the walker emits `IWalkerResults`:\n\n```typescript\ninterface IWalkerResults {\n  walkerName: string;\n  symbol: string;\n  exchangeName: string;\n  frameName: string;\n  metric: WalkerMetric;\n  totalStrategies: number;\n  bestStrategy: string | null;\n  bestMetric: number | null;\n  bestStats: BacktestStatistics | null;\n}\n```\n\nThe `bestStats` field contains the full statistics object for the winning strategy, retrieved via `BacktestMarkdownService.getData()`.\n\n**Sources**: [types.d.ts:1485-1520](), [src/lib/services/logic/private/WalkerLogicPrivateService.ts:238-251]()\n\n## Event System\n\n### Walker Event Emitters\n\n```mermaid\ngraph TB\n    subgraph \"Event Producers\"\n        WALKER_LOGIC[\"WalkerLogicPrivateService\"]\n    end\n    \n    subgraph \"Event Emitters\"\n        PROGRESS[\"progressWalkerEmitter<br/>ProgressWalkerContract<br/>After each strategy\"]\n        WALKER[\"walkerEmitter<br/>WalkerContract<br/>After each strategy\"]\n        COMPLETE[\"walkerCompleteSubject<br/>IWalkerResults<br/>When all strategies finish\"]\n        DONE[\"doneWalkerSubject<br/>DoneContract<br/>Background execution complete\"]\n        STOP[\"walkerStopSubject<br/>WalkerStopContract<br/>Bidirectional stop signals\"]\n    end\n    \n    subgraph \"Event Consumers\"\n        LISTEN_PROGRESS[\"listenWalkerProgress()\"]\n        LISTEN_WALKER[\"listenWalker()\"]\n        LISTEN_WALKER_ONCE[\"listenWalkerOnce()\"]\n        LISTEN_COMPLETE[\"listenWalkerComplete()\"]\n        LISTEN_DONE[\"listenDoneWalker()\"]\n        LISTEN_DONE_ONCE[\"listenDoneWalkerOnce()\"]\n        MARKDOWN[\"WalkerMarkdownService\"]\n    end\n    \n    WALKER_LOGIC --> PROGRESS\n    WALKER_LOGIC --> WALKER\n    WALKER_LOGIC --> COMPLETE\n    WALKER_LOGIC --> DONE\n    \n    PROGRESS --> LISTEN_PROGRESS\n    WALKER --> LISTEN_WALKER\n    WALKER --> LISTEN_WALKER_ONCE\n    WALKER --> MARKDOWN\n    COMPLETE --> LISTEN_COMPLETE\n    DONE --> LISTEN_DONE\n    DONE --> LISTEN_DONE_ONCE\n    \n    LISTEN_WALKER_ONCE -.->|user calls Walker.stop()| STOP\n    STOP -.->|filtered by symbol+walkerName| WALKER_LOGIC\n    \n    style STOP fill:#ffe1e1,stroke:#333,stroke-width:2px\n    style WALKER_LOGIC fill:#e1f5ff,stroke:#333,stroke-width:2px\n```\n\n**Sources**: [src/config/emitters.ts:68-106](), [src/function/event.ts:514-731]()\n\n### Progress Tracking\n\nThe `progressWalkerEmitter` emits after each strategy completes:\n\n```typescript\ninterface ProgressWalkerContract {\n  walkerName: string;\n  exchangeName: string;\n  frameName: string;\n  symbol: string;\n  totalStrategies: number;\n  processedStrategies: number;\n  progress: number; // 0.0 to 1.0\n}\n```\n\nProgress is calculated as `processedStrategies / totalStrategies`.\n\n**Sources**: [src/contract/ProgressWalker.contract.ts:1-8](), [src/lib/services/logic/private/WalkerLogicPrivateService.ts:210-218]()\n\n## Stop Mechanism\n\n### Multi-Walker Support\n\nWalker Mode supports multiple walkers running on the same symbol simultaneously. The stop mechanism uses both `symbol` and `walkerName` to filter stop signals, preventing cross-walker interference:\n\n```typescript\n// Subscribe to stop signals filtered by symbol AND walkerName\nconst unsubscribe = walkerStopSubject\n  .filter((data) => \n    data.symbol === symbol && \n    data.walkerName === context.walkerName\n  )\n  .connect((data) => {\n    stoppedStrategies.add(data.strategyName);\n  });\n```\n\nThe `stoppedStrategies` Set accumulates stop signals for strategies in this walker instance only.\n\n**Sources**: [src/lib/services/logic/private/WalkerLogicPrivateService.ts:93-111]()\n\n### Stop Propagation\n\n```mermaid\ngraph TB\n    USER[\"User calls Walker.stop()\"]\n    WALKER_STOP[\"Walker.stop() implementation\"]\n    GET_SCHEMA[\"Get walker schema<br/>for strategy list\"]\n    LOOP[\"For each strategy\"]\n    EMIT_STOP[\"walkerStopSubject.next()<br/>{symbol, strategyName, walkerName}\"]\n    STOP_FLAG[\"StrategyCoreService.stop()<br/>Set internal stop flag\"]\n    \n    SUBSCRIBE[\"WalkerLogicPrivateService<br/>subscribed to walkerStopSubject\"]\n    FILTER[\"Filter by symbol + walkerName\"]\n    ADD_SET[\"Add strategyName to<br/>stoppedStrategies Set\"]\n    CHECK[\"Check Set before<br/>starting next strategy\"]\n    BREAK[\"Break loop if stopped\"]\n    \n    USER --> WALKER_STOP\n    WALKER_STOP --> GET_SCHEMA\n    GET_SCHEMA --> LOOP\n    LOOP --> EMIT_STOP\n    EMIT_STOP --> STOP_FLAG\n    LOOP --> LOOP\n    \n    EMIT_STOP -.->|event| SUBSCRIBE\n    SUBSCRIBE --> FILTER\n    FILTER --> ADD_SET\n    \n    ADD_SET -.->|checked before each strategy| CHECK\n    CHECK --> BREAK\n    \n    style EMIT_STOP fill:#ffe1e1,stroke:#333,stroke-width:2px\n    style CHECK fill:#fff4e1,stroke:#333,stroke-width:2px\n```\n\nWhen `Walker.stop()` is called, it:\n1. Retrieves the walker schema to get the strategy list\n2. Emits a stop signal for each strategy via `walkerStopSubject`\n3. Sets the internal stop flag for each strategy via `StrategyCoreService.stop()`\n\nThe `WalkerLogicPrivateService` receives stop signals and accumulates them in a Set. Before starting each new strategy, it checks if that strategy is in the stopped Set and breaks the loop if true.\n\n**Sources**: [src/classes/Walker.ts:270-282](), [src/classes/Walker.ts:527-541](), [src/lib/services/logic/private/WalkerLogicPrivateService.ts:93-111](), [src/lib/services/logic/private/WalkerLogicPrivateService.ts:117-125]()\n\n### Graceful Termination\n\nStop signals do not interrupt currently running backtests. The active strategy completes its backtest normally, then the walker checks the stopped Set before starting the next strategy and terminates gracefully.\n\n**Sources**: [src/lib/services/logic/private/WalkerLogicPrivateService.ts:117-125]()\n\n## Results and Reporting\n\n### Retrieving Results\n\nThe `Walker` class provides methods to access comparison results:\n\n```typescript\n// Get structured data\nconst results = await Walker.getData(\"BTCUSDT\", \"my-walker\");\n// Returns: IWalkerResults with bestStrategy, bestMetric, bestStats\n\n// Get markdown report\nconst markdown = await Walker.getReport(\"BTCUSDT\", \"my-walker\");\n// Returns: Formatted markdown table with all strategies ranked\n\n// Dump report to disk\nawait Walker.dump(\"BTCUSDT\", \"my-walker\");\n// Writes to: ./dump/walker/my-walker.md (default)\n```\n\n**Sources**: [src/classes/Walker.ts:556-641]()\n\n### WalkerMarkdownService\n\nThe `WalkerMarkdownService` aggregates walker progress events and generates comparison reports:\n\n```typescript\n// Internal structure maintained by WalkerMarkdownService\ninterface WalkerStatistics {\n  walkerName: string;\n  symbol: string;\n  exchangeName: string;\n  frameName: string;\n  metric: WalkerMetric;\n  strategies: IWalkerStrategyResult[];\n  bestStrategy: string | null;\n  bestMetric: number | null;\n  bestStats: BacktestStatistics | null;\n}\n\ninterface IWalkerStrategyResult {\n  strategyName: string;\n  stats: BacktestStatistics;\n  metricValue: number | null;\n}\n```\n\nThe service subscribes to `walkerEmitter` and accumulates results for each strategy. When `getData()` or `getReport()` is called, it sorts strategies by metric value (descending) and generates a ranked comparison.\n\n**Sources**: [src/lib/services/markdown/WalkerMarkdownService.ts](), [types.d.ts:1465-1483]()\n\n## Instance Management\n\n### Memoized Instance Pattern\n\nThe `WalkerUtils` singleton uses memoization to create one `WalkerInstance` per `symbol:walkerName` combination:\n\n```typescript\nprivate _getInstance = memoize<\n  (symbol: string, walkerName: WalkerName) => WalkerInstance\n>(\n  ([symbol, walkerName]) => `${symbol}:${walkerName}`,\n  (symbol: string, walkerName: WalkerName) => \n    new WalkerInstance(symbol, walkerName)\n);\n```\n\nEach instance maintains its own state:\n- `_isStopped` flag for manual termination\n- `_isDone` flag for completion tracking\n- `task` wrapped in `singlerun()` to prevent concurrent execution\n\nThis allows multiple walkers to run on the same symbol simultaneously without interference.\n\n**Sources**: [src/classes/Walker.ts:423-428](), [src/classes/Walker.ts:71-135]()\n\n### Status Tracking\n\nThe `Walker.list()` method returns status for all active walker instances:\n\n```typescript\nconst statusList = await Walker.list();\n// Returns array of:\n// {\n//   id: string,           // Random UUID\n//   symbol: string,\n//   walkerName: string,\n//   status: \"idle\" | \"running\" | \"done\"\n// }\n```\n\nThe status is determined by the `singlerun` wrapper around the internal task function.\n\n**Sources**: [src/classes/Walker.ts:656-659](), [src/classes/Walker.ts:127-135]()\n\n## Usage Example\n\n### Complete Walker Setup and Execution\n\n```typescript\nimport { \n  addWalker, \n  Walker, \n  listenWalker, \n  listenWalkerComplete \n} from \"backtest-kit\";\n\n// Register walker configuration\naddWalker({\n  walkerName: \"strategy-comparison\",\n  strategies: [\n    \"rsi-strategy\",\n    \"macd-strategy\", \n    \"bollinger-strategy\"\n  ],\n  metric: \"sharpeRatio\",\n  exchangeName: \"binance\",\n  frameName: \"30d-backtest\",\n  callbacks: {\n    onStrategyStart: (strategyName, symbol) => {\n      console.log(`Testing ${strategyName} on ${symbol}...`);\n    },\n    onStrategyComplete: (strategyName, symbol, stats, metricValue) => {\n      console.log(`${strategyName}: Sharpe Ratio = ${metricValue}`);\n    },\n    onComplete: (results) => {\n      console.log(`Winner: ${results.bestStrategy}`);\n      console.log(`Best Sharpe: ${results.bestMetric}`);\n    }\n  }\n});\n\n// Subscribe to progress events\nlistenWalker((progress) => {\n  console.log(\n    `Progress: ${progress.strategiesTested}/${progress.totalStrategies}`\n  );\n  console.log(`Current best: ${progress.bestStrategy}`);\n});\n\n// Subscribe to completion\nlistenWalkerComplete((results) => {\n  console.log(\"Final results:\", results);\n});\n\n// Run walker comparison\nfor await (const update of Walker.run(\"BTCUSDT\", {\n  walkerName: \"strategy-comparison\"\n})) {\n  console.log(`Completed: ${update.strategyName}`);\n  console.log(`Metric: ${update.metricValue}`);\n  console.log(`Best so far: ${update.bestStrategy} (${update.bestMetric})`);\n}\n\n// After completion, get results\nconst results = await Walker.getData(\"BTCUSDT\", \"strategy-comparison\");\nconsole.log(\"Best strategy:\", results.bestStrategy);\nconsole.log(\"Best stats:\", results.bestStats);\n\n// Generate report\nawait Walker.dump(\"BTCUSDT\", \"strategy-comparison\");\n```\n\n**Sources**: [src/classes/Walker.ts:437-459](), [src/function/event.ts:645-695](), [src/function/event.ts:728-731]()\n\n### Background Execution with Cancellation\n\n```typescript\nimport { Walker } from \"backtest-kit\";\n\n// Start walker in background\nconst cancel = Walker.background(\"BTCUSDT\", {\n  walkerName: \"strategy-comparison\"\n});\n\n// Cancel after some condition\nsetTimeout(() => {\n  cancel(); // Stops walker gracefully\n}, 60000);\n```\n\nThe `background()` method returns a cancellation closure that:\n1. Stops all strategies via `StrategyCoreService.stop()`\n2. Emits stop signals via `walkerStopSubject` for each strategy\n3. Sets `_isStopped = true` on the instance\n4. Emits completion via `doneWalkerSubject` if not already done\n\n**Sources**: [src/classes/Walker.ts:480-502](), [src/classes/Walker.ts:213-245]()\n\n## State Cleanup\n\n### Pre-Execution Cleanup\n\nBefore starting walker execution, the system clears state for all strategies to prevent data contamination:\n\n```typescript\n// Clear backtest/schedule markdown services\nfor (const strategyName of walkerSchema.strategies) {\n  backtest.backtestMarkdownService.clear({ symbol, strategyName });\n  backtest.scheduleMarkdownService.clear({ symbol, strategyName });\n  \n  // Clear strategy core service\n  backtest.strategyCoreService.clear({ symbol, strategyName });\n  \n  // Clear risk state\n  const { riskName, riskList } = backtest.strategySchemaService.get(strategyName);\n  riskName && backtest.riskGlobalService.clear(riskName);\n  riskList && riskList.forEach((riskName) => \n    backtest.riskGlobalService.clear(riskName)\n  );\n}\n```\n\nThis ensures each strategy backtest starts from a clean state, preventing cross-contamination between sequential backtests.\n\n**Sources**: [src/classes/Walker.ts:169-186]()\n\n### Walker Markdown Cleanup\n\nThe walker markdown service is also cleared before execution:\n\n```typescript\nbacktest.walkerMarkdownService.clear(context.walkerName);\n```\n\nThis removes any previous walker results for the same walker name, ensuring a fresh comparison.\n\n**Sources**: [src/classes/Walker.ts:166]()"
                    },
                    {
                        "page_plan": {
                            "id": "5.4",
                            "title": "Optimizer Mode"
                        },
                        "content": "# Optimizer Mode\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [demo/optimization/.env.example](demo/optimization/.env.example)\n- [demo/optimization/.gitignore](demo/optimization/.gitignore)\n- [demo/optimization/src/index.mjs](demo/optimization/src/index.mjs)\n- [src/classes/Optimizer.ts](src/classes/Optimizer.ts)\n- [src/client/ClientOptimizer.ts](src/client/ClientOptimizer.ts)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/contract/ProgressOptimizer.contract.ts](src/contract/ProgressOptimizer.contract.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [src/interfaces/Optimizer.interface.ts](src/interfaces/Optimizer.interface.ts)\n- [src/lib/services/connection/OptimizerConnectionService.ts](src/lib/services/connection/OptimizerConnectionService.ts)\n- [src/lib/services/global/OptimizerGlobalService.ts](src/lib/services/global/OptimizerGlobalService.ts)\n- [src/lib/services/schema/OptimizerSchemaService.ts](src/lib/services/schema/OptimizerSchemaService.ts)\n- [src/lib/services/template/OptimizerTemplateService.ts](src/lib/services/template/OptimizerTemplateService.ts)\n- [src/lib/services/validation/OptimizerValidationService.ts](src/lib/services/validation/OptimizerValidationService.ts)\n- [src/model/Message.model.ts](src/model/Message.model.ts)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\n**Purpose**: This page documents the Optimizer execution mode, which generates executable trading strategies using Large Language Model (LLM) integration. Unlike other execution modes that run strategies directly, Optimizer Mode produces complete strategy code files by collecting multi-timeframe historical data, formatting it for LLM consumption via the Ollama API, and assembling executable `.mjs` files with integrated Walker-based backtesting.\n\nFor information about executing strategies in historical simulation, see [Backtest Mode](#5.1). For comparing multiple strategies, see [Walker Mode](#5.3). For LLM-based strategy definition, see [Defining Strategies](#4.1).\n\n---\n\n## Overview\n\nOptimizer Mode is a code generation system that bridges historical market data with LLM-powered strategy logic. The system fetches data from configurable sources (such as pre-computed technical indicators), formats it into LLM conversation messages, generates strategy prompts via Ollama API, and assembles complete executable JavaScript modules.\n\nThe generated code includes:\n- Exchange configuration with CCXT integration\n- Training and testing frame definitions\n- Multiple strategy variants (one per training period)\n- Walker configuration for strategy comparison\n- Event listeners and progress tracking\n- Helper functions for LLM interaction and debug logging\n\n**Key Characteristics**:\n- **Generative**: Produces code artifacts rather than execution results\n- **Multi-Source**: Fetches data from multiple configurable sources with pagination\n- **Multi-Timeframe**: Typically processes 1m, 15m, 30m, 1h candle data\n- **Template-Based**: Uses customizable templates for each code section\n- **LLM-Integrated**: Communicates with Ollama API for strategy generation\n\nSources: [src/interfaces/Optimizer.interface.ts:1-490](), [demo/optimization/src/index.mjs:1-450]()\n\n---\n\n## Optimizer Schema Registration\n\nOptimizer configurations are registered via `addOptimizer()` function, which accepts an `IOptimizerSchema` object defining data sources, time ranges, and code generation logic.\n\n### Registration API\n\n```typescript\naddOptimizer({\n  optimizerName: \"my-optimizer\",\n  rangeTrain: [\n    {\n      note: \"Training period 1\",\n      startDate: new Date(\"2025-11-24T00:00:00Z\"),\n      endDate: new Date(\"2025-11-24T23:59:59Z\"),\n    },\n    // Additional training periods...\n  ],\n  rangeTest: {\n    note: \"Testing period\",\n    startDate: new Date(\"2025-12-01T00:00:00Z\"),\n    endDate: new Date(\"2025-12-01T23:59:59Z\"),\n  },\n  source: [\n    {\n      name: \"1h-candles\",\n      fetch: async ({ symbol, startDate, endDate, limit, offset }) => {\n        // Fetch paginated data with unique IDs\n        return data;\n      },\n      user: (symbol, data, name) => {\n        // Format data as user message for LLM\n        return markdownTable;\n      },\n      assistant: () => {\n        // Format acknowledgment as assistant message\n        return \"Data received\";\n      }\n    }\n  ],\n  getPrompt: async (symbol, messages) => {\n    // Generate strategy logic from conversation history\n    const ollama = new Ollama({ /* ... */ });\n    const response = await ollama.chat({ messages });\n    return response.message.content;\n  },\n  template: {\n    // Optional template overrides\n  },\n  callbacks: {\n    onData: (symbol, strategyData) => { /* ... */ },\n    onCode: (symbol, code) => { /* ... */ },\n    onDump: (symbol, filepath) => { /* ... */ }\n  }\n});\n```\n\nSources: [src/interfaces/Optimizer.interface.ts:377-433](), [src/function/add.ts:1-300]()\n\n### Schema Structure\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `optimizerName` | `string` | Unique identifier for this optimizer |\n| `rangeTrain` | `IOptimizerRange[]` | Training time ranges (one strategy per range) |\n| `rangeTest` | `IOptimizerRange` | Testing time range for Walker validation |\n| `source` | `Source[]` | Data sources with fetch and format functions |\n| `getPrompt` | `function` | Generates strategy logic from conversation |\n| `template` | `Partial<IOptimizerTemplate>` | Optional template overrides |\n| `callbacks` | `Partial<IOptimizerCallbacks>` | Lifecycle event hooks |\n\nEach `IOptimizerRange` contains:\n- `startDate`: Start of data collection period (inclusive)\n- `endDate`: End of data collection period (inclusive)\n- `note`: Optional description\n\nEach `Source` can be either:\n- A simple fetch function: `(args: IOptimizerFetchArgs) => Data[]`\n- A full configuration object with `name`, `fetch`, `user`, `assistant` fields\n\nSources: [src/interfaces/Optimizer.interface.ts:15-433](), [demo/optimization/src/index.mjs:19-61]()\n\n### Data Source Requirements\n\nAll data returned by `fetch` functions must implement `IOptimizerData`:\n\n```typescript\ninterface IOptimizerData {\n  id: string | number; // Unique identifier for deduplication\n}\n```\n\nThe `fetch` function receives paginated query parameters:\n\n```typescript\ninterface IOptimizerFetchArgs {\n  symbol: string;\n  startDate: Date;\n  endDate: Date;\n  limit: number;  // Max records per request (default: 25)\n  offset: number; // Records to skip for pagination\n}\n```\n\nThe system automatically handles pagination using `iterateDocuments` from `functools-kit`, fetching all available data and deduplicating by `id` field.\n\nSources: [src/interfaces/Optimizer.interface.ts:34-84](), [src/client/ClientOptimizer.ts:63-88]()\n\n---\n\n## System Architecture\n\n```mermaid\ngraph TB\n    subgraph \"Public API\"\n        ADD[\"addOptimizer()<br/>(registration)\"]\n        OPT_CLASS[\"Optimizer.getData()<br/>Optimizer.getCode()<br/>Optimizer.dump()\"]\n    end\n    \n    subgraph \"Validation Layer\"\n        OPT_VAL[\"OptimizerValidationService<br/>validate()<br/>addOptimizer()\"]\n    end\n    \n    subgraph \"Schema Layer\"\n        OPT_SCHEMA[\"OptimizerSchemaService<br/>register()<br/>get()<br/>ToolRegistry storage\"]\n    end\n    \n    subgraph \"Global Service Layer\"\n        OPT_GLOBAL[\"OptimizerGlobalService<br/>getData()<br/>getCode()<br/>dump()\"]\n    end\n    \n    subgraph \"Connection Layer\"\n        OPT_CONN[\"OptimizerConnectionService<br/>getOptimizer() [memoized]<br/>Template merging\"]\n    end\n    \n    subgraph \"Template Layer\"\n        OPT_TEMPLATE[\"OptimizerTemplateService<br/>getTopBanner()<br/>getStrategyTemplate()<br/>getWalkerTemplate()<br/>etc.\"]\n    end\n    \n    subgraph \"Client Layer\"\n        CLIENT_OPT[\"ClientOptimizer<br/>getData()<br/>getCode()<br/>dump()\"]\n    end\n    \n    subgraph \"Event System\"\n        PROGRESS_EMIT[\"progressOptimizerEmitter<br/>ProgressOptimizerContract\"]\n    end\n    \n    ADD --> OPT_VAL\n    ADD --> OPT_SCHEMA\n    \n    OPT_CLASS --> OPT_VAL\n    OPT_CLASS --> OPT_GLOBAL\n    \n    OPT_GLOBAL --> OPT_VAL\n    OPT_GLOBAL --> OPT_CONN\n    \n    OPT_CONN --> OPT_SCHEMA\n    OPT_CONN --> OPT_TEMPLATE\n    OPT_CONN --> CLIENT_OPT\n    \n    CLIENT_OPT --> PROGRESS_EMIT\n```\n\n**Architecture Diagram: Optimizer Mode Component Structure**\n\nThe architecture follows a layered pattern:\n\n1. **Public API**: `addOptimizer()` for registration, `Optimizer` class for operations\n2. **Validation Layer**: Maintains registry and validates optimizer existence\n3. **Schema Layer**: Immutable storage using `ToolRegistry` pattern\n4. **Global Service**: Entry point with validation before delegation\n5. **Connection Layer**: Memoized client factory with template merging\n6. **Template Layer**: Default implementations for all code generation methods\n7. **Client Layer**: Core business logic for data collection and code assembly\n8. **Event System**: Progress tracking via `progressOptimizerEmitter`\n\nSources: [src/lib/services/global/OptimizerGlobalService.ts:1-105](), [src/lib/services/connection/OptimizerConnectionService.ts:1-175](), [src/lib/services/schema/OptimizerSchemaService.ts:1-97]()\n\n---\n\n## Data Collection and Processing\n\nThe optimizer collects data through a multi-stage pipeline that iterates through training ranges and data sources, building LLM conversation history.\n\n### Data Flow Diagram\n\n```mermaid\ngraph TB\n    START[\"Optimizer.getData(symbol)\"]\n    VALIDATE[\"OptimizerValidationService<br/>validate()\"]\n    GET_SCHEMA[\"OptimizerSchemaService<br/>get(optimizerName)\"]\n    GET_CLIENT[\"OptimizerConnectionService<br/>getOptimizer() [memoized]\"]\n    \n    RANGE_LOOP[\"For each rangeTrain\"]\n    SOURCE_LOOP[\"For each source\"]\n    \n    EMIT_START[\"Emit progress event<br/>processedSources/totalSources\"]\n    \n    FETCH[\"RESOLVE_PAGINATION_FN<br/>iterateDocuments()<br/>distinctDocuments()<br/>resolveDocuments()\"]\n    \n    FORMAT_USER[\"Format user message<br/>user() or getUserMessage()\"]\n    FORMAT_ASSIST[\"Format assistant message<br/>assistant() or getAssistantMessage()\"]\n    \n    APPEND_MSG[\"Append to messageList<br/>{role: 'user', content}<br/>{role: 'assistant', content}\"]\n    \n    CALLBACK_SOURCE[\"callbacks.onSourceData()<br/>(if defined)\"]\n    \n    GET_PROMPT[\"getPrompt(symbol, messageList)<br/>Generate strategy logic\"]\n    \n    APPEND_STRAT[\"Append to strategyList<br/>{symbol, name, messages, strategy}\"]\n    \n    EMIT_END[\"Emit final progress<br/>progress: 1.0\"]\n    \n    CALLBACK_DATA[\"callbacks.onData()<br/>(if defined)\"]\n    \n    RETURN[\"Return IOptimizerStrategy[]\"]\n    \n    START --> VALIDATE\n    VALIDATE --> GET_SCHEMA\n    GET_SCHEMA --> GET_CLIENT\n    GET_CLIENT --> RANGE_LOOP\n    \n    RANGE_LOOP --> SOURCE_LOOP\n    SOURCE_LOOP --> EMIT_START\n    EMIT_START --> FETCH\n    \n    FETCH --> CALLBACK_SOURCE\n    CALLBACK_SOURCE --> FORMAT_USER\n    FORMAT_USER --> FORMAT_ASSIST\n    FORMAT_ASSIST --> APPEND_MSG\n    \n    APPEND_MSG --> SOURCE_LOOP\n    SOURCE_LOOP --> GET_PROMPT\n    GET_PROMPT --> APPEND_STRAT\n    \n    APPEND_STRAT --> RANGE_LOOP\n    RANGE_LOOP --> EMIT_END\n    EMIT_END --> CALLBACK_DATA\n    CALLBACK_DATA --> RETURN\n```\n\n**Data Flow Diagram: Strategy Data Collection Process**\n\nSources: [src/client/ClientOptimizer.ts:90-215]()\n\n### Pagination and Deduplication\n\nThe system uses `functools-kit` utilities for efficient data fetching:\n\n```typescript\nconst RESOLVE_PAGINATION_FN = async <Data extends IOptimizerData = any>(\n  fetch: IOptimizerSourceFn,\n  filterData: IOptimizerFilterArgs\n) => {\n  const iterator = iterateDocuments<Data>({\n    limit: ITERATION_LIMIT,  // 25 records per request\n    async createRequest({ limit, offset }) {\n      return await fetch({\n        symbol: filterData.symbol,\n        startDate: filterData.startDate,\n        endDate: filterData.endDate,\n        limit,\n        offset,\n      });\n    },\n  });\n  const distinct = distinctDocuments(iterator, (data) => data.id);\n  return await resolveDocuments(distinct);\n};\n```\n\nThis approach:\n- Fetches 25 records at a time (configurable via `ITERATION_LIMIT`)\n- Automatically continues pagination until no more data\n- Deduplicates by `id` field to handle overlapping requests\n- Returns complete resolved array\n\nSources: [src/client/ClientOptimizer.ts:63-88]()\n\n### Conversation Building\n\nFor each training range, the system builds a conversation history:\n\n1. **Iterate Sources**: Process each source sequentially\n2. **Emit Progress**: Update progress before fetching each source\n3. **Fetch Data**: Call `RESOLVE_PAGINATION_FN` for complete dataset\n4. **Format Messages**:\n   - Call `user()` or default `getUserMessage()` for user message\n   - Call `assistant()` or default `getAssistantMessage()` for assistant response\n5. **Append to History**: Add user/assistant message pair to `messageList`\n6. **Generate Prompt**: After all sources, call `getPrompt()` with complete conversation\n7. **Store Strategy**: Save `{symbol, name, messages, strategy}` to `strategyList`\n\nSources: [src/client/ClientOptimizer.ts:99-214]()\n\n---\n\n## Template System\n\nThe template system generates executable code sections through customizable template methods. Each template method returns a string of TypeScript/JavaScript code.\n\n### Template Interface\n\n```typescript\ninterface IOptimizerTemplate {\n  getTopBanner(symbol: string): string | Promise<string>;\n  getUserMessage(symbol: string, data: IOptimizerData[], name: string): string | Promise<string>;\n  getAssistantMessage(symbol: string, data: IOptimizerData[], name: string): string | Promise<string>;\n  getWalkerTemplate(walkerName: string, exchangeName: string, frameName: string, strategies: string[]): string | Promise<string>;\n  getExchangeTemplate(symbol: string, exchangeName: string): string | Promise<string>;\n  getFrameTemplate(symbol: string, frameName: string, interval: CandleInterval, startDate: Date, endDate: Date): string | Promise<string>;\n  getStrategyTemplate(strategyName: string, interval: string, prompt: string): string | Promise<string>;\n  getLauncherTemplate(symbol: string, walkerName: string): string | Promise<string>;\n  getTextTemplate(symbol: string): string | Promise<string>;\n  getJsonTemplate(symbol: string): string | Promise<string>;\n  getJsonDumpTemplate(symbol: string): string | Promise<string>;\n}\n```\n\nSources: [src/interfaces/Optimizer.interface.ts:240-374]()\n\n### Template Merging Process\n\n```mermaid\ngraph LR\n    SCHEMA[\"IOptimizerSchema<br/>template: Partial\"]\n    DEFAULT[\"OptimizerTemplateService<br/>Default implementations\"]\n    CONN[\"OptimizerConnectionService<br/>getOptimizer()\"]\n    MERGED[\"Complete IOptimizerTemplate<br/>All methods defined\"]\n    CLIENT[\"ClientOptimizer<br/>Uses complete template\"]\n    \n    SCHEMA -->|\"Custom overrides\"| CONN\n    DEFAULT -->|\"Default implementations\"| CONN\n    CONN -->|\"Merge with ||=\"| MERGED\n    MERGED --> CLIENT\n```\n\n**Template Merging Diagram: How Custom and Default Templates Combine**\n\nThe `OptimizerConnectionService.getOptimizer()` method performs template merging:\n\n```typescript\nconst {\n  getAssistantMessage = this.optimizerTemplateService.getAssistantMessage,\n  getExchangeTemplate = this.optimizerTemplateService.getExchangeTemplate,\n  // ... other methods with default fallbacks\n} = rawTemplate;\n\nconst template: IOptimizerTemplate = {\n  getAssistantMessage,\n  getExchangeTemplate,\n  // ... complete template object\n};\n```\n\nThis allows partial overrides - any method not provided in schema falls back to `OptimizerTemplateService` defaults.\n\nSources: [src/lib/services/connection/OptimizerConnectionService.ts:59-113]()\n\n### Default Template Implementations\n\nThe `OptimizerTemplateService` provides default implementations for all template methods:\n\n| Method | Purpose | Example Output |\n|--------|---------|----------------|\n| `getTopBanner()` | Imports and constants | `#!/usr/bin/env node\\nimport { Ollama } from \"ollama\";` |\n| `getUserMessage()` | LLM user prompt | `\"Прочитай данные и скажи ОК\\n\\n\" + JSON.stringify(data)` |\n| `getAssistantMessage()` | LLM acknowledgment | `\"ОК\"` |\n| `getExchangeTemplate()` | Exchange config | `addExchange({ exchangeName, getCandles: async (...) => { ... } })` |\n| `getFrameTemplate()` | Frame config | `addFrame({ frameName, interval, startDate, endDate })` |\n| `getStrategyTemplate()` | Strategy with LLM | `addStrategy({ strategyName, interval, getSignal: async (...) => { ... } })` |\n| `getWalkerTemplate()` | Walker config | `addWalker({ walkerName, exchangeName, frameName, strategies })` |\n| `getLauncherTemplate()` | Execution code | `Walker.background(symbol, { walkerName })` |\n| `getTextTemplate()` | Text LLM helper | `async function text(messages) { ... }` |\n| `getJsonTemplate()` | JSON LLM helper | `async function json(messages) { ... }` |\n| `getJsonDumpTemplate()` | Debug logger | `async function dumpJson(...) { ... }` |\n\nSources: [src/lib/services/template/OptimizerTemplateService.ts:1-716]()\n\n### Strategy Template Example\n\nThe `getStrategyTemplate()` method generates multi-timeframe strategy code:\n\n```typescript\npublic getStrategyTemplate = async (\n  strategyName: string,\n  interval: string,\n  prompt: string\n) => {\n  const escapedPrompt = String(prompt)\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(/`/g, '\\\\`')\n    .replace(/\\$/g, '\\\\$');\n\n  return [\n    `addStrategy({`,\n    `    strategyName: \"${strategyName}\",`,\n    `    interval: \"${interval}\",`,\n    `    getSignal: async (symbol) => {`,\n    `        const messages = [];`,\n    ``,\n    `        // Загружаем данные всех таймфреймов`,\n    `        const microTermCandles = await getCandles(symbol, \"1m\", 30);`,\n    `        const mainTermCandles = await getCandles(symbol, \"5m\", 24);`,\n    // ... message building for each timeframe\n    `        messages.push({`,\n    `            role: \"user\",`,\n    `            content: [`,\n    `                \"Проанализируй все таймфреймы и сгенерируй торговый сигнал...\",`,\n    `                \"\",`,\n    `                \\`${escapedPrompt}\\`,`,\n    `            ].join(\"\\\\n\"),`,\n    `        });`,\n    ``,\n    `        const result = await json(messages);`,\n    `        return result;`,\n    `    },`,\n    `});`\n  ].join(\"\\n\");\n};\n```\n\nKey features:\n- Fetches 1m, 5m, 15m, 1h candles via `getCandles()`\n- Formats each timeframe as separate user/assistant message pair\n- Includes custom strategy prompt from `getPrompt()`\n- Calls `json()` helper for structured LLM output\n- Returns `ISignalDto` compatible object\n\nSources: [src/lib/services/template/OptimizerTemplateService.ts:160-304]()\n\n---\n\n## Code Generation Process\n\nThe `getCode()` method assembles all template sections into complete executable code.\n\n### Code Assembly Flow\n\n```mermaid\ngraph TB\n    START[\"Optimizer.getCode(symbol)\"]\n    GET_DATA[\"ClientOptimizer.getData()<br/>Fetch strategy data\"]\n    CREATE_PREFIX[\"CREATE_PREFIX_FN()<br/>Generate unique prefix\"]\n    \n    SECTIONS[\"sections: string[] = []\"]\n    \n    BANNER[\"1. getTopBanner()<br/>Imports and constants\"]\n    DUMP_HELPER[\"2. getJsonDumpTemplate()<br/>Debug logger function\"]\n    TEXT_HELPER[\"3. getTextTemplate()<br/>LLM text helper\"]\n    JSON_HELPER[\"4. getJsonTemplate()<br/>LLM JSON helper\"]\n    \n    EXCHANGE[\"5. getExchangeTemplate()<br/>CCXT exchange config\"]\n    \n    TRAIN_FRAMES[\"6. Loop rangeTrain<br/>getFrameTemplate() for each\"]\n    TEST_FRAME[\"7. getFrameTemplate()<br/>Test frame\"]\n    \n    STRATEGIES[\"8. Loop strategyData<br/>getStrategyTemplate() for each\"]\n    \n    WALKER[\"9. getWalkerTemplate()<br/>Walker config with all strategies\"]\n    LAUNCHER[\"10. getLauncherTemplate()<br/>Walker.background() + listeners\"]\n    \n    JOIN[\"sections.join('\\\\n')<br/>Combine all sections\"]\n    \n    CALLBACK[\"callbacks.onCode()<br/>(if defined)\"]\n    RETURN[\"Return complete code string\"]\n    \n    START --> GET_DATA\n    GET_DATA --> CREATE_PREFIX\n    CREATE_PREFIX --> SECTIONS\n    \n    SECTIONS --> BANNER\n    BANNER --> DUMP_HELPER\n    DUMP_HELPER --> TEXT_HELPER\n    TEXT_HELPER --> JSON_HELPER\n    \n    JSON_HELPER --> EXCHANGE\n    \n    EXCHANGE --> TRAIN_FRAMES\n    TRAIN_FRAMES --> TEST_FRAME\n    \n    TEST_FRAME --> STRATEGIES\n    \n    STRATEGIES --> WALKER\n    WALKER --> LAUNCHER\n    \n    LAUNCHER --> JOIN\n    JOIN --> CALLBACK\n    CALLBACK --> RETURN\n```\n\n**Code Assembly Diagram: How Template Sections Are Combined**\n\nSources: [src/client/ClientOptimizer.ts:217-350]()\n\n### Naming Convention\n\nAll generated entities use a unique prefix to avoid conflicts:\n\n```typescript\nconst prefix = CREATE_PREFIX_FN(); // e.g., \"a7f3k2\"\n\nconst exchangeName = `${prefix}_exchange`;       // \"a7f3k2_exchange\"\nconst trainFrameName = `${prefix}_train_frame-1`; // \"a7f3k2_train_frame-1\"\nconst testFrameName = `${prefix}_test_frame`;     // \"a7f3k2_test_frame\"\nconst strategyName = `${prefix}_strategy-1`;      // \"a7f3k2_strategy-1\"\nconst walkerName = `${prefix}_walker`;            // \"a7f3k2_walker\"\n```\n\nThe prefix is generated using: `(Math.random() + 1).toString(36).substring(7)`\n\nSources: [src/client/ClientOptimizer.ts:22-341]()\n\n### Generated Code Structure\n\nThe final code has this structure:\n\n```\n#!/usr/bin/env node\n\n// Imports (Ollama, ccxt, backtest-kit, fs, uuid, path)\nimport { Ollama } from \"ollama\";\nimport ccxt from \"ccxt\";\nimport { addExchange, addStrategy, addFrame, addWalker, Walker, ... } from \"backtest-kit\";\n\nconst WARN_KB = 100;\n\n// Helper: dumpJson() - Saves LLM conversations to ./dump/strategy/{resultId}/\nasync function dumpJson(resultId, history, result, outputDir = \"./dump/strategy\") { ... }\n\n// Helper: text() - LLM text generation via Ollama\nasync function text(messages) { ... }\n\n// Helper: json() - LLM structured output with signal schema\nasync function json(messages) { ... }\n\n// Exchange configuration\naddExchange({\n    exchangeName: \"a7f3k2_exchange\",\n    getCandles: async (symbol, interval, since, limit) => { ... },\n    formatPrice: async (symbol, price) => price.toFixed(2),\n    formatQuantity: async (symbol, quantity) => quantity.toFixed(8),\n});\n\n// Training frames (one per rangeTrain)\naddFrame({ frameName: \"a7f3k2_train_frame-1\", interval: \"1m\", startDate: ..., endDate: ... });\naddFrame({ frameName: \"a7f3k2_train_frame-2\", interval: \"1m\", startDate: ..., endDate: ... });\n\n// Test frame (from rangeTest)\naddFrame({ frameName: \"a7f3k2_test_frame\", interval: \"1m\", startDate: ..., endDate: ... });\n\n// Strategies (one per training range/source)\naddStrategy({\n    strategyName: \"a7f3k2_strategy-1\",\n    interval: \"5m\",\n    getSignal: async (symbol) => {\n        // Multi-timeframe data fetching\n        const microTermCandles = await getCandles(symbol, \"1m\", 30);\n        const mainTermCandles = await getCandles(symbol, \"5m\", 24);\n        // ... message building\n        const result = await json(messages);\n        return result;\n    },\n});\naddStrategy({ strategyName: \"a7f3k2_strategy-2\", ... });\n\n// Walker configuration\naddWalker({\n    walkerName: \"a7f3k2_walker\",\n    exchangeName: \"a7f3k2_exchange\",\n    frameName: \"a7f3k2_test_frame\",\n    strategies: [\"a7f3k2_strategy-1\", \"a7f3k2_strategy-2\"],\n});\n\n// Launcher with event listeners\nWalker.background(\"BTCUSDT\", { walkerName: \"a7f3k2_walker\" });\nlistenSignalBacktest((event) => { ... });\nlistenWalkerComplete((results) => { ... });\n```\n\nSources: [src/lib/services/template/OptimizerTemplateService.ts:36-716]()\n\n---\n\n## Public API Methods\n\nThe `Optimizer` class provides three main methods for interacting with the optimizer system.\n\n### Optimizer.getData()\n\nFetches data from all sources and generates strategy metadata without generating code:\n\n```typescript\nconst strategies = await Optimizer.getData(\"BTCUSDT\", {\n  optimizerName: \"my-optimizer\"\n});\n\n// Returns: IOptimizerStrategy[]\n// [\n//   {\n//     symbol: \"BTCUSDT\",\n//     name: \"1h-candles\",\n//     messages: [\n//       { role: \"user\", content: \"...\" },\n//       { role: \"assistant\", content: \"...\" },\n//       // ... more messages\n//     ],\n//     strategy: \"Trading strategy prompt...\"\n//   },\n//   // ... more strategies (one per training range)\n// ]\n```\n\nUseful for:\n- Inspecting generated strategy prompts\n- Debugging data source formatting\n- Validating conversation history\n- Testing `getPrompt()` output\n\nSources: [src/classes/Optimizer.ts:32-59]()\n\n### Optimizer.getCode()\n\nGenerates complete executable strategy code as a string:\n\n```typescript\nconst code = await Optimizer.getCode(\"BTCUSDT\", {\n  optimizerName: \"my-optimizer\"\n});\n\n// Returns: string (complete .mjs file content)\n// Can be executed directly or written to file\n```\n\nThis method:\n1. Calls `getData()` internally\n2. Generates all template sections\n3. Combines sections with newlines\n4. Invokes `callbacks.onCode()` if defined\n5. Returns complete code string\n\nSources: [src/classes/Optimizer.ts:61-87]()\n\n### Optimizer.dump()\n\nGenerates code and writes it to the file system:\n\n```typescript\nawait Optimizer.dump(\"BTCUSDT\", {\n  optimizerName: \"my-optimizer\"\n}, \"./output\");\n\n// Creates: ./output/my-optimizer_BTCUSDT.mjs\n```\n\nFile naming: `{optimizerName}_{symbol}.mjs`\n\nThis method:\n1. Calls `getCode()` internally\n2. Creates output directory (recursive)\n3. Writes file with UTF-8 encoding\n4. Invokes `callbacks.onDump()` if defined\n5. Logs success/failure via logger\n\nDefault path: `./` (current directory)\n\nSources: [src/classes/Optimizer.ts:89-121](), [src/client/ClientOptimizer.ts:353-384]()\n\n---\n\n## Progress Monitoring\n\nThe optimizer emits progress events during data collection to track source processing.\n\n### Progress Event Structure\n\n```typescript\ninterface ProgressOptimizerContract {\n  optimizerName: string;      // Optimizer being executed\n  symbol: string;             // Trading symbol (e.g., \"BTCUSDT\")\n  totalSources: number;       // Total sources to process\n  processedSources: number;   // Sources processed so far\n  progress: number;           // Completion (0.0 to 1.0)\n}\n```\n\nSources: [src/contract/ProgressOptimizer.contract.ts:1-31]()\n\n### Listening to Progress\n\n```typescript\nimport { listenOptimizerProgress } from \"backtest-kit\";\n\nconst unsubscribe = listenOptimizerProgress((event) => {\n  console.log(`Progress: ${(event.progress * 100).toFixed(2)}%`);\n  console.log(`Processed: ${event.processedSources} / ${event.totalSources}`);\n  console.log(`Optimizer: ${event.optimizerName}, Symbol: ${event.symbol}`);\n});\n\n// Later: stop listening\nunsubscribe();\n```\n\nProgress is emitted:\n1. **Before each source** is fetched (start of processing)\n2. **After all sources** are complete (final 100% event)\n\nCalculation: `progress = processedSources / totalSources`\n\nTotal sources: `rangeTrain.length * source.length`\n\nSources: [src/function/event.ts:30-32](), [src/client/ClientOptimizer.ts:100-209]()\n\n### Event Flow Diagram\n\n```mermaid\ngraph TB\n    START[\"ClientOptimizer.getData()\"]\n    CALC_TOTAL[\"totalSources = rangeTrain.length * source.length\"]\n    INIT_COUNT[\"processedSources = 0\"]\n    \n    RANGE_LOOP[\"For each rangeTrain\"]\n    SOURCE_LOOP[\"For each source\"]\n    \n    EMIT_START[\"progressOptimizerEmitter.next()<br/>progress: processedSources/totalSources\"]\n    FETCH[\"Fetch and process source\"]\n    INCREMENT[\"processedSources++\"]\n    \n    DONE[\"All processing complete\"]\n    EMIT_FINAL[\"progressOptimizerEmitter.next()<br/>progress: 1.0\"]\n    \n    START --> CALC_TOTAL\n    CALC_TOTAL --> INIT_COUNT\n    INIT_COUNT --> RANGE_LOOP\n    \n    RANGE_LOOP --> SOURCE_LOOP\n    SOURCE_LOOP --> EMIT_START\n    EMIT_START --> FETCH\n    FETCH --> INCREMENT\n    INCREMENT --> SOURCE_LOOP\n    \n    SOURCE_LOOP --> RANGE_LOOP\n    RANGE_LOOP --> DONE\n    DONE --> EMIT_FINAL\n```\n\n**Progress Event Flow: Tracking Source Processing**\n\nSources: [src/client/ClientOptimizer.ts:99-209]()\n\n---\n\n## Demo Application Example\n\nThe demo application at `demo/optimization` demonstrates real-world optimizer usage with pre-computed technical indicators.\n\n### Configuration\n\n```javascript\n// Training ranges (7 days)\nconst TRAIN_RANGE = [\n  {\n    note: \"24 ноября 2025\",\n    startDate: new Date(\"2025-11-24T00:00:00Z\"),\n    endDate: new Date(\"2025-11-24T23:59:59Z\"),\n  },\n  // ... 6 more training days\n];\n\n// Testing range (1 day)\nconst TEST_RANGE = {\n  note: \"1 декабря 2025\",\n  startDate: new Date(\"2025-12-01T00:00:00Z\"),\n  endDate: new Date(\"2025-12-01T23:59:59Z\"),\n};\n\n// Data sources (4 timeframes)\nconst SOURCE_LIST = [\n  {\n    name: \"long-term-range\",\n    fetch: async ({ symbol, startDate, endDate, limit, offset }) => {\n      const url = new URL(`${process.env.CCXT_DUMPER_URL}/view/long-term-range`);\n      url.searchParams.set(\"symbol\", symbol);\n      url.searchParams.set(\"startDate\", startDate.getTime());\n      url.searchParams.set(\"endDate\", endDate.getTime());\n      url.searchParams.set(\"limit\", limit || 1000);\n      url.searchParams.set(\"offset\", offset || 0);\n      const { rows: data } = await fetchApi(url);\n      return data;\n    },\n    user: (symbol, data) => \n      str.newline(\n        `# 1-Hour Candles Trading Analysis for ${symbol}\\n\\n`,\n        arrayToMarkdownTable(data),\n        // ... metadata about indicators\n      ),\n    assistant: () => \"Исторические данные 1-часовых свечей получены\",\n  },\n  // ... 3 more sources (30m, 15m, 1m)\n];\n```\n\nSources: [demo/optimization/src/index.mjs:19-350]()\n\n### Integration with CCXT Dumper\n\nThe demo relies on `CCXT_DUMPER_URL` environment variable pointing to a pre-computation service:\n\n```\nCCXT_DUMPER_URL=http://localhost:3000\nOLLAMA_API_KEY=your_api_key\n```\n\nThe dumper service provides endpoints for each timeframe:\n- `/view/long-term-range` - 1-hour candles with indicators\n- `/view/swing-term-range` - 30-minute candles with indicators\n- `/view/short-term-range` - 15-minute candles with indicators\n- `/view/micro-term-range` - 1-minute candles with indicators\n\nEach endpoint returns JSON with paginated technical indicators (RSI, MACD, Bollinger Bands, etc.)\n\nSources: [demo/optimization/.env.example:1-3](), [demo/optimization/src/index.mjs:66-350]()\n\n### Prompt Generation\n\nThe demo uses Ollama API to generate strategy recommendations:\n\n```javascript\ngetPrompt: async (symbol, messages) => {\n  const ollama = new Ollama({\n    host: \"https://ollama.com\",\n    headers: {\n      Authorization: `Bearer ${process.env.OLLAMA_API_KEY}`,\n    },\n  });\n\n  const response = await ollama.chat({\n    model: \"deepseek-v3.1:671b\",\n    messages: [\n      {\n        role: \"system\",\n        content: [\n          \"В ответ напиши торговую стратегию где нет ничего лишнего,\",\n          \"только отчёт готовый для копипасты целиком\",\n          \"\",\n          \"**ВАЖНО**: Не здоровайся, не говори что делаешь - только отчёт!\"\n        ].join(\"\\n\"),\n      },\n      ...messages,\n      {\n        role: \"user\",\n        content: [\n          `На каких условиях мне купить ${symbol}?`,\n          \"Дай анализ рынка на основе поддержки/сопротивления, точек входа в LONG/SHORT позиции.\",\n          \"Какой RR ставить для позиций?\",\n          // ...\n        ].join(\"\\n\")\n      }\n    ]\n  });\n\n  return response.message.content.trim()\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(/`/g, '\\\\`')\n    .replace(/\\$/g, '\\\\$')\n    .replace(/\"/g, '\\\\\"');\n}\n```\n\nThe prompt asks the LLM to:\n1. Analyze multi-timeframe data\n2. Identify support/resistance levels\n3. Determine LONG/SHORT entry points\n4. Calculate risk/reward ratios\n5. Provide strategic recommendations\n\nSources: [demo/optimization/src/index.mjs:350-450]()\n\n### Execution\n\n```bash\ncd demo/optimization\nnpm install\nnpm start\n```\n\nThis:\n1. Registers optimizer with `addOptimizer()`\n2. Calls `Optimizer.dump(\"BTC/USDT\", \"btc-optimizer\")`\n3. Generates file: `./btc-optimizer_BTC/USDT.mjs`\n4. Logs progress to console\n\nSources: [demo/optimization/package.json]()\n\n---\n\n## Key Implementation Details\n\n### Security: String Escaping\n\nAll template methods escape user input to prevent code injection:\n\n```typescript\n// Escape special characters for safe string interpolation\nconst escapedStrategyName = String(strategyName)\n  .replace(/\\\\/g, '\\\\\\\\')\n  .replace(/\"/g, '\\\\\"');\n\nconst escapedPrompt = String(plainPrompt)\n  .replace(/\\\\/g, '\\\\\\\\')\n  .replace(/`/g, '\\\\`')\n  .replace(/\\$/g, '\\\\$');\n```\n\nThis prevents malicious input in:\n- Optimizer names\n- Strategy names\n- Exchange names\n- Frame names\n- Strategy prompts\n- User messages\n\nSources: [src/lib/services/template/OptimizerTemplateService.ts:136-192]()\n\n### Memory Efficiency: Generator Pattern\n\nWhile optimizer doesn't use generators (returns complete code), it processes data incrementally:\n- Fetches sources one at a time\n- Builds conversation incrementally\n- Emits progress events during processing\n- Doesn't load all training data into memory simultaneously\n\nSources: [src/client/ClientOptimizer.ts:99-214]()\n\n### Memoization: Client Caching\n\n`OptimizerConnectionService.getOptimizer()` is memoized by `optimizerName`:\n\n```typescript\npublic getOptimizer = memoize(\n  ([optimizerName]) => `${optimizerName}`,\n  (optimizerName: OptimizerName) => {\n    // ... create ClientOptimizer instance\n  }\n);\n```\n\nThis ensures:\n- One `ClientOptimizer` instance per optimizer\n- Template merging happens once\n- Repeated calls reuse same instance\n- Memory efficient for multiple operations on same optimizer\n\nSources: [src/lib/services/connection/OptimizerConnectionService.ts:59-113]()\n\n### File System: Atomic Writes\n\nThe `dump()` method uses standard Node.js file system operations:\n\n```typescript\nconst dir = join(process.cwd(), path);\nawait mkdir(dir, { recursive: true });\n\nconst filename = `${self.params.optimizerName}_${symbol}.mjs`;\nconst filepath = join(dir, filename);\n\nawait writeFile(filepath, report, \"utf-8\");\n```\n\nWhile not truly atomic, it:\n- Creates directories recursively\n- Writes complete file in single operation\n- Uses UTF-8 encoding for cross-platform compatibility\n- Logs errors for debugging\n\nSources: [src/client/ClientOptimizer.ts:360-384]()\n\n---\n\n## Related Documentation\n\n- For executing the generated code, see [Walker Mode](#5.3)\n- For backtest execution mechanics, see [Backtest Mode](#5.1)\n- For strategy definition patterns, see [Defining Strategies](#4.1)\n- For data fetching and VWAP calculation, see [Exchange Configuration](#6.1)\n- For event system usage, see [Event-Driven Architecture](#2.3)\n\nSources: All referenced documentation pages"
                    },
                    {
                        "page_plan": {
                            "id": "6",
                            "title": "Data and Exchanges"
                        },
                        "content": "# Data and Exchanges\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/config/params.ts](src/config/params.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/function/setup.ts](src/function/setup.ts)\n- [src/helpers/toProfitLossDto.ts](src/helpers/toProfitLossDto.ts)\n- [src/index.ts](src/index.ts)\n- [src/interfaces/Heatmap.interface.ts](src/interfaces/Heatmap.interface.ts)\n- [src/lib/services/validation/ConfigValidationService.ts](src/lib/services/validation/ConfigValidationService.ts)\n- [test/config/setup.mjs](test/config/setup.mjs)\n- [test/e2e/config.test.mjs](test/e2e/config.test.mjs)\n- [test/e2e/defend.test.mjs](test/e2e/defend.test.mjs)\n- [test/e2e/risk.test.mjs](test/e2e/risk.test.mjs)\n- [test/e2e/sanitize.test.mjs](test/e2e/sanitize.test.mjs)\n- [test/index.mjs](test/index.mjs)\n- [test/mock/getMockCandles.mjs](test/mock/getMockCandles.mjs)\n- [test/spec/config.test.mjs](test/spec/config.test.mjs)\n- [test/spec/heat.test.mjs](test/spec/heat.test.mjs)\n- [test/spec/list.test.mjs](test/spec/list.test.mjs)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\nThis page documents how the backtest-kit framework integrates with external data sources, fetches historical market data, calculates price metrics like VWAP, and manages timeframes for backtesting. It covers the Exchange system (data source abstraction), Frame system (timeframe generation), and the candle data structures used throughout the framework.\n\n**Scope**: This page focuses on data acquisition and time management. For strategy execution logic, see [Strategy System](#4). For execution mode details (how Backtest/Live modes consume this data), see [Execution Modes (Detailed)](#5).\n\n---\n\n## Exchange System Architecture\n\nThe Exchange system provides an abstraction layer for fetching historical candle data from any source (CCXT, custom APIs, databases). The framework uses a three-tier architecture for exchange operations:\n\n```mermaid\ngraph TB\n    subgraph \"User Registration API\"\n        ADD_EXCH[\"addExchange()<br/>(src/function/add.ts)\"]\n    end\n    \n    subgraph \"Schema Storage\"\n        EXCH_SCHEMA[\"ExchangeSchemaService<br/>ToolRegistry pattern<br/>stores IExchangeSchema\"]\n    end\n    \n    subgraph \"Validation Layer\"\n        EXCH_VAL[\"ExchangeValidationService<br/>validates schema structure<br/>memoized checks\"]\n    end\n    \n    subgraph \"Connection Factory\"\n        EXCH_CONN[\"ExchangeConnectionService<br/>memoized by exchangeName<br/>creates ClientExchange\"]\n    end\n    \n    subgraph \"Client Layer\"\n        CLIENT_EXCH[\"ClientExchange<br/>implements IExchange<br/>getCandles, getNextCandles<br/>getAveragePrice (VWAP)\"]\n    end\n    \n    subgraph \"Core Logic\"\n        EXCH_CORE[\"ExchangeCoreService<br/>orchestrates operations<br/>delegates to ClientExchange\"]\n    end\n    \n    subgraph \"Data Source\"\n        USER_IMPL[\"User-provided getCandles<br/>CCXT, REST API, Database\"]\n    end\n    \n    ADD_EXCH -->|\"registers\"| EXCH_SCHEMA\n    EXCH_SCHEMA -->|\"reads\"| EXCH_VAL\n    EXCH_VAL -->|\"validates\"| EXCH_SCHEMA\n    EXCH_SCHEMA -->|\"provides schema\"| EXCH_CONN\n    EXCH_CONN -->|\"instantiates with IExchangeParams\"| CLIENT_EXCH\n    EXCH_CORE -->|\"calls methods\"| CLIENT_EXCH\n    CLIENT_EXCH -->|\"invokes user callback\"| USER_IMPL\n    \n    style CLIENT_EXCH fill:#e1f5ff,stroke:#333,stroke-width:3px\n    style EXCH_SCHEMA fill:#fff4e1,stroke:#333,stroke-width:2px\n```\n\n**Key Components**:\n\n| Component | File Path | Responsibility |\n|-----------|-----------|----------------|\n| `IExchangeSchema` | [types.d.ts:327-363]() | Schema interface for exchange registration |\n| `ExchangeSchemaService` | [src/lib/services/schema/ExchangeSchemaService.ts]() | ToolRegistry for storing exchange schemas |\n| `ExchangeValidationService` | [src/lib/services/validation/ExchangeValidationService.ts]() | Validates exchange schema structure |\n| `ExchangeConnectionService` | [src/lib/services/connection/ExchangeConnectionService.ts]() | Memoized factory for `ClientExchange` instances |\n| `ClientExchange` | [src/lib/client/ClientExchange.ts]() | Business logic for candle fetching and VWAP |\n| `ExchangeCoreService` | [src/lib/services/core/ExchangeCoreService.ts]() | High-level orchestration of exchange operations |\n\n**Sources**: [types.d.ts:327-363](), [src/index.ts:1-195](), Diagram 1 from high-level architecture\n\n---\n\n## Exchange Configuration\n\n### IExchangeSchema Structure\n\nExchanges are registered via `addExchange()` with a schema defining four required callbacks:\n\n```mermaid\ngraph LR\n    SCHEMA[\"IExchangeSchema\"]\n    \n    GET_CANDLES[\"getCandles()<br/>fetch historical OHLCV<br/>returns Promise&lt;ICandleData[]&gt;\"]\n    FORMAT_PRICE[\"formatPrice()<br/>exchange precision rules<br/>returns Promise&lt;string&gt;\"]\n    FORMAT_QTY[\"formatQuantity()<br/>exchange precision rules<br/>returns Promise&lt;string&gt;\"]\n    CALLBACKS[\"callbacks.onCandleData<br/>(optional)<br/>event emitted after fetch\"]\n    \n    SCHEMA -->|\"required\"| GET_CANDLES\n    SCHEMA -->|\"required\"| FORMAT_PRICE\n    SCHEMA -->|\"required\"| FORMAT_QTY\n    SCHEMA -->|\"optional\"| CALLBACKS\n    \n    style SCHEMA fill:#fff4e1,stroke:#333,stroke-width:2px\n```\n\n**Schema Definition** ([types.d.ts:327-363]()):\n\n```typescript\ninterface IExchangeSchema {\n    exchangeName: ExchangeName;  // Unique identifier\n    note?: string;               // Documentation\n    \n    // Fetch candles from data source\n    getCandles: (\n        symbol: string,\n        interval: CandleInterval,  // \"1m\" | \"3m\" | \"5m\" | ... | \"8h\"\n        since: Date,\n        limit: number\n    ) => Promise<ICandleData[]>;\n    \n    // Format values per exchange precision\n    formatQuantity: (symbol: string, quantity: number) => Promise<string>;\n    formatPrice: (symbol: string, price: number) => Promise<string>;\n    \n    // Optional lifecycle callback\n    callbacks?: Partial<IExchangeCallbacks>;\n}\n```\n\n### Registration Example\n\n```typescript\nimport ccxt from 'ccxt';\nimport { addExchange } from 'backtest-kit';\n\naddExchange({\n    exchangeName: 'binance',\n    note: 'CCXT-based Binance integration',\n    \n    getCandles: async (symbol, interval, since, limit) => {\n        const exchange = new ccxt.binance();\n        const ohlcv = await exchange.fetchOHLCV(\n            symbol,\n            interval,\n            since.getTime(),\n            limit\n        );\n        \n        return ohlcv.map(([timestamp, open, high, low, close, volume]) => ({\n            timestamp, open, high, low, close, volume\n        }));\n    },\n    \n    formatPrice: async (symbol, price) => {\n        const exchange = new ccxt.binance();\n        await exchange.loadMarkets();\n        return exchange.priceToPrecision(symbol, price);\n    },\n    \n    formatQuantity: async (symbol, quantity) => {\n        const exchange = new ccxt.binance();\n        await exchange.loadMarkets();\n        return exchange.amountToPrecision(symbol, quantity);\n    },\n    \n    callbacks: {\n        onCandleData: (symbol, interval, since, limit, data) => {\n            console.log(`Fetched ${data.length} candles for ${symbol}`);\n        }\n    }\n});\n```\n\n### Validation Rules\n\n`ExchangeValidationService` enforces:\n- `exchangeName` must be non-empty string\n- `getCandles` must be a function\n- `formatPrice` must be a function\n- `formatQuantity` must be a function\n- Exchange name must not already exist (checked during registration)\n\n**Sources**: [types.d.ts:327-363](), [src/function/add.ts](), [test/spec/exchange.test.mjs](), [README.md:60-75]()\n\n---\n\n## Candle Data and VWAP\n\n### ICandleData Structure\n\nThe framework uses a standard OHLCV candle structure:\n\n```typescript\ninterface ICandleData {\n    timestamp: number;  // Unix timestamp in milliseconds\n    open: number;       // Opening price\n    high: number;       // Highest price\n    low: number;        // Lowest price\n    close: number;      // Closing price\n    volume: number;     // Trading volume\n}\n```\n\n**Sources**: [types.d.ts:295-308]()\n\n### VWAP Calculation\n\n`ClientExchange.getAveragePrice()` calculates Volume-Weighted Average Price (VWAP) using the last N 1-minute candles, where N is configured via `CC_AVG_PRICE_CANDLES_COUNT` (default: 5).\n\n```mermaid\ngraph TD\n    START[\"getAveragePrice(symbol)\"]\n    \n    FETCH[\"fetch last N 1m candles<br/>getCandles(symbol, '1m', limit=N)\"]\n    \n    VALIDATE[\"VALIDATE_NO_INCOMPLETE_CANDLES_FN<br/>check for price anomalies<br/>threshold: referencePrice / 1000\"]\n    \n    CALC_TYPICAL[\"for each candle:<br/>typicalPrice = (high + low + close) / 3\"]\n    \n    CALC_VWAP[\"VWAP = Σ(typicalPrice × volume) / Σ(volume)\"]\n    \n    RETRY[\"retry logic<br/>CC_GET_CANDLES_RETRY_COUNT<br/>delay: CC_GET_CANDLES_RETRY_DELAY_MS\"]\n    \n    START --> FETCH\n    FETCH --> VALIDATE\n    VALIDATE -->|\"pass\"| CALC_TYPICAL\n    VALIDATE -->|\"fail\"| RETRY\n    RETRY --> FETCH\n    CALC_TYPICAL --> CALC_VWAP\n    \n    style VALIDATE fill:#ffe1e1,stroke:#333,stroke-width:2px\n    style CALC_VWAP fill:#e1f5ff,stroke:#333,stroke-width:2px\n```\n\n**Implementation Details**:\n\n1. **Fetching**: Calls `getCandles(symbol, \"1m\", limit)` where limit = `CC_AVG_PRICE_CANDLES_COUNT`\n2. **Anomaly Detection**: Validates candles using `VALIDATE_NO_INCOMPLETE_CANDLES_FN` to detect incomplete candles from exchange APIs (e.g., Binance returning prices near $0 for incomplete candles)\n3. **Typical Price**: For each candle, calculates `(high + low + close) / 3`\n4. **VWAP**: `Σ(typicalPrice × volume) / Σ(volume)`\n5. **Retry Logic**: On failure, retries up to `CC_GET_CANDLES_RETRY_COUNT` times with `CC_GET_CANDLES_RETRY_DELAY_MS` delay\n\n**Configuration Parameters** ([src/config/params.ts:1-122]()):\n\n| Parameter | Default | Description |\n|-----------|---------|-------------|\n| `CC_AVG_PRICE_CANDLES_COUNT` | 5 | Number of 1m candles for VWAP |\n| `CC_GET_CANDLES_RETRY_COUNT` | 3 | Max retries for failed fetches |\n| `CC_GET_CANDLES_RETRY_DELAY_MS` | 5000 | Delay between retries (ms) |\n| `CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR` | 1000 | Anomaly detection threshold |\n| `CC_GET_CANDLES_MIN_CANDLES_FOR_MEDIAN` | 5 | Min candles for median vs average |\n\n### Price Anomaly Detection\n\n`VALIDATE_NO_INCOMPLETE_CANDLES_FN` protects against incomplete candles from exchange APIs:\n\n**Algorithm** ([src/lib/client/ClientExchange.ts]()):\n1. Extract all price points (OHLC) from candles\n2. Calculate reference price:\n   - If `candles.length >= CC_GET_CANDLES_MIN_CANDLES_FOR_MEDIAN`: use median\n   - Else: use simple average\n3. For each price, check: `price < referencePrice / CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR`\n4. If anomaly detected, throw error\n\n**Example**: BTC at $50,000 median → threshold $50. Catches incomplete candles with prices like $0.01-$1.\n\n**Sources**: [types.d.ts:14-106](), [src/lib/client/ClientExchange.ts](), [test/e2e/sanitize.test.mjs:666-784](), [src/config/params.ts:76-104]()\n\n---\n\n## ClientExchange Methods\n\n`ClientExchange` implements the `IExchange` interface with four primary methods:\n\n```mermaid\ngraph TB\n    IEXCHANGE[\"IExchange interface\"]\n    \n    GET_CANDLES[\"getCandles(symbol, interval, limit)<br/>fetch historical candles<br/>backwards from ExecutionContext.when\"]\n    \n    GET_NEXT[\"getNextCandles(symbol, interval, limit)<br/>fetch future candles<br/>forward from ExecutionContext.when<br/>(backtest mode only)\"]\n    \n    GET_AVG[\"getAveragePrice(symbol)<br/>calculate VWAP<br/>last CC_AVG_PRICE_CANDLES_COUNT candles\"]\n    \n    FORMAT_PRICE[\"formatPrice(symbol, price)<br/>delegate to schema callback\"]\n    \n    FORMAT_QTY[\"formatQuantity(symbol, quantity)<br/>delegate to schema callback\"]\n    \n    IEXCHANGE -->|\"implements\"| GET_CANDLES\n    IEXCHANGE -->|\"implements\"| GET_NEXT\n    IEXCHANGE -->|\"implements\"| GET_AVG\n    IEXCHANGE -->|\"implements\"| FORMAT_PRICE\n    IEXCHANGE -->|\"implements\"| FORMAT_QTY\n    \n    style GET_AVG fill:#e1f5ff,stroke:#333,stroke-width:2px\n```\n\n### getCandles vs getNextCandles\n\n| Method | Direction | Use Case | Context |\n|--------|-----------|----------|---------|\n| `getCandles` | Backwards from `when` | Indicator calculation, VWAP | Backtest + Live |\n| `getNextCandles` | Forward from `when` | Fast candle processing | Backtest only |\n\n**Implementation** ([src/lib/client/ClientExchange.ts]()):\n- Both methods call the user-provided `IExchangeSchema.getCandles` callback\n- `getCandles`: `since = when - (limit * interval)`\n- `getNextCandles`: `since = when`\n- `ExecutionContext.when` is injected via `ExecutionContextService` (see [System Architecture](#3))\n\n**Sources**: [types.d.ts:368-413](), [src/lib/client/ClientExchange.ts]()\n\n---\n\n## Timeframes and Frames\n\nThe Frame system generates timestamp arrays for backtest iteration. Each frame defines a date range and interval for generating tick timestamps.\n\n```mermaid\ngraph TB\n    subgraph \"User Registration\"\n        ADD_FRAME[\"addFrame()<br/>(src/function/add.ts)\"]\n    end\n    \n    subgraph \"Schema Storage\"\n        FRAME_SCHEMA[\"FrameSchemaService<br/>stores IFrameSchema\"]\n    end\n    \n    subgraph \"Validation\"\n        FRAME_VAL[\"FrameValidationService<br/>validates date range<br/>interval validation\"]\n    end\n    \n    subgraph \"Connection Factory\"\n        FRAME_CONN[\"FrameConnectionService<br/>memoized by frameName<br/>creates ClientFrame\"]\n    end\n    \n    subgraph \"Client Layer\"\n        CLIENT_FRAME[\"ClientFrame<br/>implements IFrame<br/>getTimeframe()\"]\n    end\n    \n    subgraph \"Core Logic\"\n        FRAME_CORE[\"FrameCoreService<br/>orchestrates timeframe<br/>generation\"]\n    end\n    \n    subgraph \"Backtest Execution\"\n        BACKTEST_LOGIC[\"BacktestLogicPrivateService<br/>iterates timestamps<br/>for strategy.tick()\"]\n    end\n    \n    ADD_FRAME --> FRAME_SCHEMA\n    FRAME_SCHEMA --> FRAME_VAL\n    FRAME_VAL --> FRAME_SCHEMA\n    FRAME_SCHEMA --> FRAME_CONN\n    FRAME_CONN --> CLIENT_FRAME\n    FRAME_CORE --> CLIENT_FRAME\n    CLIENT_FRAME -->|\"generates Date[]\"| BACKTEST_LOGIC\n    \n    style CLIENT_FRAME fill:#e1f5ff,stroke:#333,stroke-width:3px\n```\n\n### IFrameSchema Structure\n\n```typescript\ninterface IFrameSchema {\n    frameName: FrameName;       // Unique identifier\n    note?: string;              // Documentation\n    interval: FrameInterval;    // Timestamp granularity\n    startDate: Date;            // Backtest start (inclusive)\n    endDate: Date;              // Backtest end (inclusive)\n    callbacks?: Partial<IFrameCallbacks>;  // onTimeframe event\n}\n\ntype FrameInterval = \n    | \"1m\" | \"3m\" | \"5m\" | \"15m\" | \"30m\"      // Minutes\n    | \"1h\" | \"2h\" | \"4h\" | \"6h\" | \"8h\" | \"12h\" // Hours\n    | \"1d\" | \"3d\";                             // Days\n```\n\n**Sources**: [types.d.ts:420-502]()\n\n### Timeframe Generation Algorithm\n\n`ClientFrame.getTimeframe()` generates an array of `Date` objects:\n\n**Implementation** ([src/lib/client/ClientFrame.ts]()):\n```typescript\n1. Parse interval to milliseconds (e.g., \"1m\" → 60000ms)\n2. current = startDate\n3. timestamps = []\n4. while (current <= endDate):\n       timestamps.push(new Date(current))\n       current += interval_ms\n5. return timestamps\n```\n\n**Example**: `interval=\"1m\"`, `startDate=\"2024-01-01T00:00:00Z\"`, `endDate=\"2024-01-01T01:00:00Z\"`\n- Generates 61 timestamps: 00:00, 00:01, 00:02, ..., 01:00\n\n### Frame Registration Example\n\n```typescript\nimport { addFrame } from 'backtest-kit';\n\naddFrame({\n    frameName: '30d-backtest',\n    note: 'January 2024 full month',\n    interval: '1m',\n    startDate: new Date('2024-01-01T00:00:00Z'),\n    endDate: new Date('2024-01-31T23:59:59Z'),\n    callbacks: {\n        onTimeframe: (timeframe, startDate, endDate, interval) => {\n            console.log(`Generated ${timeframe.length} timestamps`);\n            console.log(`Range: ${startDate} to ${endDate}`);\n            console.log(`Interval: ${interval}`);\n        }\n    }\n});\n```\n\n### Validation Rules\n\n`FrameValidationService` enforces:\n- `frameName` must be non-empty string\n- `interval` must be valid `FrameInterval` type\n- `startDate` must be valid Date\n- `endDate` must be valid Date\n- `endDate` must be greater than `startDate`\n\n**Sources**: [types.d.ts:420-502](), [src/lib/client/ClientFrame.ts](), [test/spec/exchange.test.mjs]()\n\n---\n\n## Exchange and Frame Integration Flow\n\nThe following diagram shows how Exchange and Frame components integrate during backtest execution:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant BacktestLogic as BacktestLogicPrivateService\n    participant FrameCore as FrameCoreService\n    participant ClientFrame\n    participant StrategyCore as StrategyCoreService\n    participant ExchCore as ExchangeCoreService\n    participant ClientExch as ClientExchange\n    participant UserGetCandles as User getCandles\n    \n    User->>BacktestLogic: Backtest.run(symbol, {strategyName, exchangeName, frameName})\n    \n    BacktestLogic->>FrameCore: getTimeframe(symbol, frameName)\n    FrameCore->>ClientFrame: getTimeframe()\n    ClientFrame-->>FrameCore: Date[] (timestamps)\n    FrameCore-->>BacktestLogic: Date[] timeframes\n    \n    loop for each timestamp in timeframes\n        BacktestLogic->>StrategyCore: tick(symbol, timestamp)\n        StrategyCore->>ExchCore: getAveragePrice(symbol)\n        ExchCore->>ClientExch: getAveragePrice(symbol)\n        ClientExch->>UserGetCandles: getCandles(symbol, \"1m\", 5)\n        UserGetCandles-->>ClientExch: ICandleData[]\n        ClientExch-->>ExchCore: VWAP price\n        ExchCore-->>StrategyCore: price\n        StrategyCore-->>BacktestLogic: IStrategyTickResult\n    end\n    \n    BacktestLogic-->>User: generator yields results\n```\n\n**Execution Context Injection**:\n- `BacktestLogicPrivateService` sets `ExecutionContextService.when = timestamp` before each `tick()` call\n- `ClientExchange.getCandles()` reads `ExecutionContext.when` to calculate `since` parameter\n- This ensures all operations are scoped to the current backtest timestamp\n\n**Sources**: [src/lib/services/logic/private/BacktestLogicPrivateService.ts](), [src/lib/services/core/ExchangeCoreService.ts](), [src/lib/services/core/FrameCoreService.ts]()\n\n---\n\n## Exchange Data Flow and Caching\n\n```mermaid\ngraph TB\n    subgraph \"Public API\"\n        GET_CANDLES_FN[\"getCandles(symbol, interval, limit)<br/>(src/function/exchange.ts)\"]\n        GET_AVG_FN[\"getAveragePrice(symbol)<br/>(src/function/exchange.ts)\"]\n    end\n    \n    subgraph \"Service Layer\"\n        EXCH_CORE[\"ExchangeCoreService<br/>orchestrates calls\"]\n    end\n    \n    subgraph \"Connection Layer\"\n        EXCH_CONN[\"ExchangeConnectionService<br/>Map&lt;exchangeName, ClientExchange&gt;<br/>memoized instances\"]\n    end\n    \n    subgraph \"Client Layer\"\n        CLIENT_EXCH[\"ClientExchange<br/>business logic<br/>anomaly detection<br/>VWAP calculation\"]\n    end\n    \n    subgraph \"Schema Storage\"\n        SCHEMA[\"ExchangeSchemaService<br/>IExchangeSchema registry\"]\n    end\n    \n    subgraph \"User Implementation\"\n        USER_IMPL[\"User getCandles callback<br/>CCXT, API, Database\"]\n    end\n    \n    GET_CANDLES_FN --> EXCH_CORE\n    GET_AVG_FN --> EXCH_CORE\n    EXCH_CORE --> EXCH_CONN\n    EXCH_CONN -->|\"cache miss: instantiate\"| CLIENT_EXCH\n    EXCH_CONN -->|\"cache hit: reuse\"| CLIENT_EXCH\n    CLIENT_EXCH -->|\"reads schema\"| SCHEMA\n    CLIENT_EXCH -->|\"invokes\"| USER_IMPL\n    \n    style EXCH_CONN fill:#fff4e1,stroke:#333,stroke-width:2px\n    style CLIENT_EXCH fill:#e1f5ff,stroke:#333,stroke-width:3px\n```\n\n**Memoization Strategy** ([src/lib/services/connection/ExchangeConnectionService.ts]()):\n- `ClientExchange` instances are cached by `exchangeName`\n- Cache key: `exchangeName` (string)\n- Cache invalidation: None (instances live for application lifetime)\n- Benefit: Avoids repeated schema lookups and instance creation\n\n**Sources**: [src/function/exchange.ts](), [src/lib/services/connection/ExchangeConnectionService.ts](), [src/lib/services/core/ExchangeCoreService.ts]()\n\n---\n\n## Configuration Parameters Summary\n\nAll exchange and candle-related parameters are configurable via `setConfig()`:\n\n| Parameter | Default | Range | Description |\n|-----------|---------|-------|-------------|\n| `CC_AVG_PRICE_CANDLES_COUNT` | 5 | Integer > 0 | VWAP candle count (1m interval) |\n| `CC_GET_CANDLES_RETRY_COUNT` | 3 | Integer ≥ 0 | Max retries on fetch failure |\n| `CC_GET_CANDLES_RETRY_DELAY_MS` | 5000 | Integer > 0 | Delay between retries (ms) |\n| `CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR` | 1000 | Number > 0 | Anomaly detection divisor |\n| `CC_GET_CANDLES_MIN_CANDLES_FOR_MEDIAN` | 5 | Integer > 0 | Threshold for median vs average |\n\n**Usage**:\n```typescript\nimport { setConfig } from 'backtest-kit';\n\nsetConfig({\n    CC_AVG_PRICE_CANDLES_COUNT: 10,  // Use 10 candles for VWAP\n    CC_GET_CANDLES_RETRY_COUNT: 5,   // More retries for unstable APIs\n});\n```\n\n**Sources**: [src/config/params.ts:1-122](), [types.d.ts:5-239](), [test/e2e/config.test.mjs]()\n\n---\n\n## Error Handling and Retry Logic\n\nExchange operations implement robust error handling:\n\n**Retry Mechanism** ([src/lib/client/ClientExchange.ts]()):\n1. Wrap `getCandles()` call in try-catch\n2. On error, log via `LoggerService`\n3. Wait `CC_GET_CANDLES_RETRY_DELAY_MS` milliseconds\n4. Retry up to `CC_GET_CANDLES_RETRY_COUNT` times\n5. If all retries exhausted, propagate error to caller\n\n**Error Scenarios**:\n- **Network Timeout**: Retried automatically\n- **Rate Limit**: User should implement exponential backoff in `getCandles` callback\n- **Invalid Symbol**: Not retried (validation error)\n- **Anomalous Prices**: Throws error after validation, triggers retry\n\n**Test Coverage**: [test/e2e/sanitize.test.mjs:666-784]() demonstrates incomplete candle detection and rejection\n\n**Sources**: [src/lib/client/ClientExchange.ts](), [src/config/params.ts:66-104]()\n\n---\n\n## Testing Examples\n\n### Mock Exchange for Testing\n\n```typescript\nimport { addExchange } from 'backtest-kit';\n\naddExchange({\n    exchangeName: 'mock-exchange',\n    getCandles: async (symbol, interval, since, limit) => {\n        const candles = [];\n        const intervalMs = 60000; // 1 minute\n        \n        for (let i = 0; i < limit; i++) {\n            const timestamp = since.getTime() + i * intervalMs;\n            candles.push({\n                timestamp,\n                open: 42000 + i * 100,\n                high: 42100 + i * 100,\n                low: 41900 + i * 100,\n                close: 42000 + i * 100,\n                volume: 100,\n            });\n        }\n        \n        return candles;\n    },\n    formatPrice: async (symbol, price) => price.toFixed(8),\n    formatQuantity: async (symbol, quantity) => quantity.toFixed(8),\n});\n```\n\n### Anomaly Detection Test\n\nFrom [test/e2e/sanitize.test.mjs:666-784]():\n- Mock exchange returns incomplete candle with `open: 0.1` (anomaly)\n- Normal candles have `open: 42000`\n- `VALIDATE_NO_INCOMPLETE_CANDLES_FN` detects 0.1 < 42000 / 1000 = 42\n- Error emitted via `errorEmitter`\n- Test verifies error message contains \"anomalously low price\"\n\n**Sources**: [test/mock/getMockCandles.mjs:1-42](), [test/e2e/sanitize.test.mjs:666-784](), [test/spec/exchange.test.mjs]()"
                    },
                    {
                        "page_plan": {
                            "id": "6.1",
                            "title": "Exchange Configuration"
                        },
                        "content": "# Exchange Configuration\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/add.ts](src/function/add.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/function/list.ts](src/function/list.ts)\n- [src/index.ts](src/index.ts)\n- [src/interfaces/Heatmap.interface.ts](src/interfaces/Heatmap.interface.ts)\n- [src/lib/core/provide.ts](src/lib/core/provide.ts)\n- [src/lib/core/types.ts](src/lib/core/types.ts)\n- [src/lib/index.ts](src/lib/index.ts)\n- [test/e2e/defend.test.mjs](test/e2e/defend.test.mjs)\n- [test/e2e/risk.test.mjs](test/e2e/risk.test.mjs)\n- [test/index.mjs](test/index.mjs)\n- [test/mock/getMockCandles.mjs](test/mock/getMockCandles.mjs)\n- [test/spec/heat.test.mjs](test/spec/heat.test.mjs)\n- [test/spec/list.test.mjs](test/spec/list.test.mjs)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis document covers the exchange configuration system, which provides market data access for backtest and live trading execution. An exchange defines how to fetch historical candle data (OHLCV), format prices and quantities according to exchange precision rules, and calculate volume-weighted average prices (VWAP) for signal generation.\n\nFor information about strategy configuration that consumes exchange data, see [Defining Strategies](#4.1). For timeframe configuration that controls backtest periods, see [Timeframes and Frames](#6.3).\n\n**Sources**: [types.d.ts:309-418](), [README.md:60-75]()\n\n---\n\n## Exchange Schema Structure\n\nAn exchange is registered via `addExchange()` with an `IExchangeSchema` object that defines:\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `exchangeName` | `ExchangeName` (string) | Yes | Unique identifier for the exchange |\n| `note` | `string` | No | Optional developer documentation |\n| `getCandles` | Function | Yes | Fetches historical OHLCV candle data |\n| `formatPrice` | Function | Yes | Formats prices to exchange precision |\n| `formatQuantity` | Function | Yes | Formats quantities to exchange precision |\n| `callbacks` | `Partial<IExchangeCallbacks>` | No | Optional lifecycle event handlers |\n\nThe `getCandles` function signature:\n```typescript\n(symbol: string, interval: CandleInterval, since: Date, limit: number) => Promise<ICandleData[]>\n```\n\n**Sources**: [types.d.ts:327-363](), [src/function/add.ts:66-100]()\n\n---\n\n## Candle Data Structure\n\n### CandleInterval Types\n\nSupported intervals for candle fetching:\n\n```typescript\ntype CandleInterval = \"1m\" | \"3m\" | \"5m\" | \"15m\" | \"30m\" | \"1h\" | \"2h\" | \"4h\" | \"6h\" | \"8h\"\n```\n\n**Sources**: [types.d.ts:290-291]()\n\n### ICandleData Format\n\nEach candle contains six data points:\n\n```typescript\ninterface ICandleData {\n  timestamp: number;  // Unix timestamp in milliseconds when candle opened\n  open: number;       // Opening price at candle start\n  high: number;       // Highest price during candle period\n  low: number;        // Lowest price during candle period\n  close: number;      // Closing price at candle end\n  volume: number;     // Trading volume during candle period\n}\n```\n\n**Sources**: [types.d.ts:292-308]()\n\n---\n\n## Registration Flow\n\nThe following diagram shows how an exchange schema flows through validation and registration layers before becoming available for use:\n\n```mermaid\ngraph TB\n    USER[\"User Code\"]\n    ADD[\"addExchange()\"]\n    VAL[\"ExchangeValidationService\"]\n    SCHEMA[\"ExchangeSchemaService\"]\n    CONN[\"ExchangeConnectionService\"]\n    CLIENT[\"ClientExchange\"]\n    CORE[\"ExchangeCoreService\"]\n    \n    USER -->|\"IExchangeSchema\"| ADD\n    ADD -->|\"Validate\"| VAL\n    VAL -->|\"Check exchangeName exists\"| VAL\n    VAL -->|\"Verify getCandles is function\"| VAL\n    VAL -->|\"Verify formatPrice/Quantity\"| VAL\n    ADD -->|\"Register\"| SCHEMA\n    SCHEMA -->|\"Store schema\"| SCHEMA\n    \n    CORE -->|\"Request by exchangeName\"| CONN\n    CONN -->|\"Lookup schema\"| SCHEMA\n    CONN -->|\"Create memoized\"| CLIENT\n    CLIENT -->|\"IExchangeParams\"| CLIENT\n    \n    style ADD fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style VAL fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style SCHEMA fill:#f9f9f9,stroke:#333,stroke-width:2px\n```\n\n**Diagram: Exchange Registration and Instantiation Flow**\n\nThe registration process:\n\n1. **Validation** - [ExchangeValidationService:128]() checks schema structure using memoized validators\n2. **Storage** - [ExchangeSchemaService:21]() stores schema in registry using ToolRegistry pattern\n3. **Connection** - [ExchangeConnectionService:18]() creates memoized [ClientExchange:14]() instances keyed by `exchangeName`\n4. **Usage** - [ExchangeCoreService:24]() delegates to ClientExchange methods\n\n**Sources**: [src/function/add.ts:101-113](), [src/lib/services/validation/ExchangeValidationService.ts](), [src/lib/services/schema/ExchangeSchemaService.ts](), [src/lib/services/connection/ExchangeConnectionService.ts]()\n\n---\n\n## Exchange Implementation Layers\n\n### IExchange Interface\n\nThe `IExchange` interface defines methods available to strategies:\n\n| Method | Purpose | Usage Context |\n|--------|---------|---------------|\n| `getCandles(symbol, interval, limit)` | Fetch historical candles **backwards** from execution context time | Backtest and live mode for indicators |\n| `getNextCandles(symbol, interval, limit)` | Fetch future candles **forward** from execution context time | Backtest mode only for fast processing |\n| `formatPrice(symbol, price)` | Format price to exchange precision | Signal validation, reporting |\n| `formatQuantity(symbol, quantity)` | Format quantity to exchange precision | Position sizing, reporting |\n| `getAveragePrice(symbol)` | Calculate VWAP from last N candles | Signal generation, execution price |\n\n**Sources**: [types.d.ts:365-413]()\n\n### ClientExchange Implementation\n\n[ClientExchange:14]() wraps the user-provided schema with retry logic, anomaly detection, and context awareness:\n\n```mermaid\ngraph LR\n    STRATEGY[\"ClientStrategy.tick()\"]\n    CLIENT[\"ClientExchange\"]\n    USER[\"User getCandles()\"]\n    RETRY[\"Retry Logic\"]\n    ANOMALY[\"Anomaly Detection\"]\n    CONTEXT[\"ExecutionContextService\"]\n    \n    STRATEGY -->|\"getCandles()\"| CLIENT\n    CLIENT -->|\"Read when\"| CONTEXT\n    CLIENT -->|\"Calculate since\"| CLIENT\n    CLIENT -->|\"Try/catch\"| RETRY\n    RETRY -->|\"Call with params\"| USER\n    USER -->|\"ICandleData[]\"| RETRY\n    RETRY -->|\"Validate prices\"| ANOMALY\n    ANOMALY -->|\"Filter incomplete candles\"| ANOMALY\n    ANOMALY -->|\"Return valid candles\"| STRATEGY\n    \n    style CLIENT fill:#f9f9f9,stroke:#333,stroke-width:2px\n```\n\n**Diagram: ClientExchange Internal Flow**\n\n**Sources**: [src/lib/client/ClientExchange.ts]()\n\n---\n\n## VWAP Calculation\n\nThe `getAveragePrice()` method calculates Volume-Weighted Average Price using the last `CC_AVG_PRICE_CANDLES_COUNT` (default: 5) 1-minute candles:\n\n**Formula**:\n```\nVWAP = Σ(Typical Price × Volume) / Σ(Volume)\nwhere Typical Price = (High + Low + Close) / 3\n```\n\nThis provides realistic execution prices by accounting for volume distribution across the price range.\n\n**Sources**: [types.d.ts:404-412](), [types.d.ts:12-15]()\n\n---\n\n## Retry Logic and Anomaly Detection\n\n### Global Configuration Parameters\n\nExchange data fetching is protected by configurable retry and validation settings:\n\n| Parameter | Default | Purpose |\n|-----------|---------|---------|\n| `CC_GET_CANDLES_RETRY_COUNT` | 3 | Number of retry attempts on failure |\n| `CC_GET_CANDLES_RETRY_DELAY_MS` | 5000 | Delay between retries (milliseconds) |\n| `CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR` | 1000 | Detects incomplete candles with near-zero prices |\n| `CC_GET_CANDLES_MIN_CANDLES_FOR_MEDIAN` | 5 | Minimum candles required for median-based anomaly detection |\n\n**Sources**: [types.d.ts:70-106]()\n\n### Anomaly Detection Logic\n\nIncomplete candles from exchange APIs (e.g., Binance returning $0.01 for BTC) are filtered using:\n\n1. **Median calculation** - Compute median price from all OHLC values\n2. **Threshold check** - Reject candles where `price < (median / threshold_factor)`\n3. **Fallback** - Use simple average if candle count < minimum\n\nExample: BTC at $50,000 median → threshold $50 → catches $0.01-1 anomalies\n\n**Sources**: [types.d.ts:80-106]()\n\n---\n\n## Service Architecture\n\nThe following diagram maps exchange-related services to their responsibilities:\n\n```mermaid\ngraph TB\n    subgraph \"Schema Layer\"\n        ESCHEMA[\"ExchangeSchemaService\"]\n    end\n    \n    subgraph \"Validation Layer\"\n        EVAL[\"ExchangeValidationService\"]\n    end\n    \n    subgraph \"Connection Layer\"\n        ECONN[\"ExchangeConnectionService\"]\n    end\n    \n    subgraph \"Core Layer\"\n        ECORE[\"ExchangeCoreService\"]\n    end\n    \n    subgraph \"Client Layer\"\n        ECLIENT[\"ClientExchange\"]\n    end\n    \n    subgraph \"Context Services\"\n        EXEC[\"ExecutionContextService\"]\n        METHOD[\"MethodContextService\"]\n    end\n    \n    EVAL -->|\"Validates schema\"| ESCHEMA\n    ECONN -->|\"Reads schema\"| ESCHEMA\n    ECONN -->|\"Creates\"| ECLIENT\n    ECORE -->|\"Gets instance\"| ECONN\n    ECORE -->|\"Delegates to\"| ECLIENT\n    ECLIENT -->|\"Reads context\"| EXEC\n    METHOD -->|\"Provides exchangeName\"| ECONN\n    \n    style ESCHEMA fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style EVAL fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style ECONN fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style ECORE fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style ECLIENT fill:#f9f9f9,stroke:#333,stroke-width:2px\n```\n\n**Diagram: Exchange Service Dependency Graph**\n\n| Service | Type | Responsibility |\n|---------|------|----------------|\n| ExchangeSchemaService | Schema | Stores registered exchange configurations using ToolRegistry pattern |\n| ExchangeValidationService | Validation | Validates IExchangeSchema structure with memoized checks |\n| ExchangeConnectionService | Connection | Creates memoized ClientExchange instances keyed by `exchangeName` |\n| ExchangeCoreService | Core | Provides high-level API wrapping ClientExchange methods |\n| ClientExchange | Client | Implements IExchange interface with retry/anomaly logic |\n\n**Sources**: [src/lib/index.ts:97-117](), [src/lib/core/types.ts:20-34]()\n\n---\n\n## Context Injection\n\nExchange operations are context-aware through dependency injection:\n\n### ExecutionContextService\n\nProvides implicit context propagation:\n\n```typescript\ninterface IExecutionContext {\n  symbol: string;    // Trading pair (e.g., \"BTCUSDT\")\n  when: Date;        // Current timestamp for operation\n  backtest: boolean; // True if backtest mode, false if live mode\n}\n```\n\nThe `when` field determines:\n- **getCandles()** - Fetches candles ending at `when` (looking backward)\n- **getNextCandles()** - Fetches candles starting after `when` (looking forward, backtest only)\n\n**Sources**: [types.d.ts:242-254](), [types.d.ts:274-285]()\n\n### MethodContextService\n\nRoutes exchange lookup by name:\n\n```typescript\ninterface IMethodContext {\n  exchangeName: ExchangeName;  // Name of exchange schema to use\n  strategyName: StrategyName;  // (also used for strategy routing)\n  frameName: FrameName;        // (also used for frame routing)\n}\n```\n\n**Sources**: [types.d.ts:505-517](), [types.d.ts:537-544]()\n\n---\n\n## Usage Patterns\n\n### Basic CCXT Integration\n\nStandard pattern for integrating CCXT exchanges:\n\n```typescript\nimport ccxt from 'ccxt';\nimport { addExchange } from 'backtest-kit';\n\naddExchange({\n  exchangeName: 'binance',\n  getCandles: async (symbol, interval, since, limit) => {\n    const exchange = new ccxt.binance();\n    const ohlcv = await exchange.fetchOHLCV(symbol, interval, since.getTime(), limit);\n    return ohlcv.map(([timestamp, open, high, low, close, volume]) => ({\n      timestamp,\n      open,\n      high,\n      low,\n      close,\n      volume\n    }));\n  },\n  formatPrice: async (symbol, price) => {\n    const exchange = new ccxt.binance();\n    await exchange.loadMarkets();\n    const market = exchange.market(symbol);\n    return exchange.priceToPrecision(symbol, price);\n  },\n  formatQuantity: async (symbol, quantity) => {\n    const exchange = new ccxt.binance();\n    await exchange.loadMarkets();\n    return exchange.amountToPrecision(symbol, quantity);\n  }\n});\n```\n\n**Sources**: [README.md:60-75](), [types.d.ts:327-363]()\n\n### Custom Data Source\n\nPattern for database or file-based data:\n\n```typescript\nimport { addExchange } from 'backtest-kit';\n\naddExchange({\n  exchangeName: 'custom-db',\n  getCandles: async (symbol, interval, since, limit) => {\n    // Query database for candles\n    const candles = await db.candles.find({\n      symbol,\n      interval,\n      timestamp: { $gte: since.getTime() }\n    })\n    .sort({ timestamp: 1 })\n    .limit(limit);\n    \n    return candles.map(c => ({\n      timestamp: c.timestamp,\n      open: c.open,\n      high: c.high,\n      low: c.low,\n      close: c.close,\n      volume: c.volume\n    }));\n  },\n  formatPrice: async (symbol, price) => price.toFixed(8),\n  formatQuantity: async (symbol, quantity) => quantity.toFixed(8)\n});\n```\n\n**Sources**: [src/function/add.ts:66-100]()\n\n### Lifecycle Callbacks\n\nOptional `onCandleData` callback for monitoring:\n\n```typescript\naddExchange({\n  exchangeName: 'binance',\n  getCandles: async (symbol, interval, since, limit) => { /* ... */ },\n  formatPrice: async (symbol, price) => price.toFixed(8),\n  formatQuantity: async (symbol, quantity) => quantity.toFixed(8),\n  callbacks: {\n    onCandleData: (symbol, interval, since, limit, data) => {\n      console.log(`Fetched ${data.length} ${interval} candles for ${symbol}`);\n      console.log(`Time range: ${since.toISOString()} (limit: ${limit})`);\n    }\n  }\n});\n```\n\n**Sources**: [types.d.ts:320-325]()\n\n---\n\n## Public API Functions\n\n### Registration\n\n```typescript\nfunction addExchange(exchangeSchema: IExchangeSchema): void\n```\n\nRegisters an exchange schema after validation. Throws error if `exchangeName` already exists or schema is invalid.\n\n**Sources**: [src/function/add.ts:101-113]()\n\n### Listing\n\n```typescript\nasync function listExchanges(): Promise<IExchangeSchema[]>\n```\n\nReturns all registered exchange schemas. Useful for debugging or building dynamic UIs.\n\n**Sources**: [src/function/list.ts:43-46]()\n\n### Runtime Access\n\n```typescript\nfunction getCandles(symbol: string, interval: CandleInterval, limit: number): Promise<ICandleData[]>\nfunction getAveragePrice(symbol: string): Promise<number>\nfunction formatPrice(symbol: string, price: number): Promise<string>\nfunction formatQuantity(symbol: string, quantity: number): Promise<string>\n```\n\nThese functions access the exchange configured in the current `MethodContextService` context. Called from within strategy `getSignal()` callbacks.\n\n**Sources**: [src/function/exchange.ts]()\n\n---\n\n## Validation Rules\n\nThe `ExchangeValidationService` enforces the following rules at registration:\n\n| Rule | Check | Error Message |\n|------|-------|---------------|\n| Unique name | `exchangeName` not already registered | \"Exchange already exists: {name}\" |\n| Name type | `exchangeName` is string | \"exchangeName must be a string\" |\n| getCandles | Function exists | \"getCandles must be a function\" |\n| formatPrice | Function exists | \"formatPrice must be a function\" |\n| formatQuantity | Function exists | \"formatQuantity must be a function\" |\n| Callbacks | If provided, must be object | \"callbacks must be an object\" |\n\n**Sources**: [src/lib/services/validation/ExchangeValidationService.ts]()\n\n---\n\n## Testing Examples\n\n### Mock Exchange for Tests\n\n```typescript\nimport { addExchange } from 'backtest-kit';\n\naddExchange({\n  exchangeName: 'binance-mock-test',\n  getCandles: async (symbol, interval, since, limit) => {\n    const candles = [];\n    const intervalMs = 60000; // 1 minute\n    \n    for (let i = 0; i < limit; i++) {\n      const timestamp = since.getTime() + i * intervalMs;\n      const basePrice = 42000 + i * 100;\n      \n      candles.push({\n        timestamp,\n        open: basePrice + 150.5,\n        high: basePrice + 380.2,\n        low: basePrice + 100.0,\n        close: basePrice + 250.8,\n        volume: 100 + i * 10\n      });\n    }\n    \n    return candles;\n  },\n  formatPrice: async (symbol, price) => price.toFixed(8),\n  formatQuantity: async (symbol, quantity) => quantity.toFixed(8)\n});\n```\n\n**Sources**: [test/mock/getMockCandles.mjs:1-42](), [test/spec/heat.test.mjs:13-28]()\n\n---\n\n## Error Handling\n\n### Retry Mechanism\n\nClientExchange automatically retries failed `getCandles()` calls:\n\n1. Initial attempt\n2. If error thrown, wait `CC_GET_CANDLES_RETRY_DELAY_MS` (default: 5000ms)\n3. Retry up to `CC_GET_CANDLES_RETRY_COUNT` (default: 3) times\n4. If all retries exhausted, propagate error to caller\n\n**Sources**: [types.d.ts:70-78]()\n\n### Anomaly Filtering\n\nInvalid candles are silently filtered (not errors) if:\n- Price is below `median / CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR`\n- Occurs when exchange APIs return incomplete data (e.g., $0.01 for BTC)\n\n**Sources**: [types.d.ts:80-106]()\n\n---\n\n## Integration with Other Systems\n\n### Strategy Execution\n\nStrategies call exchange methods during signal generation:\n\n```typescript\naddStrategy({\n  strategyName: 'my-strategy',\n  interval: '5m',\n  getSignal: async (symbol) => {\n    // Get historical data for indicators\n    const candles = await getCandles(symbol, '1h', 24);\n    \n    // Get current execution price\n    const currentPrice = await getAveragePrice(symbol);\n    \n    // Calculate indicators and generate signal\n    // ...\n  }\n});\n```\n\n**Sources**: [README.md:107-137]()\n\n### Backtest Fast Processing\n\nDuring backtest, `getNextCandles()` enables skip-to-close optimization:\n\n1. Signal opens at time T\n2. Fetch future candles from T to TP/SL/timeout\n3. Skip intermediate ticks, jump directly to close event\n4. Process only meaningful price points\n\n**Sources**: [types.d.ts:379-386]()\n\n### Live Trading\n\nIn live mode:\n- `getCandles()` fetches recent historical data\n- `getNextCandles()` throws error (not applicable to live mode)\n- `getAveragePrice()` provides real-time VWAP for execution\n\n**Sources**: [types.d.ts:369-377]()"
                    },
                    {
                        "page_plan": {
                            "id": "6.2",
                            "title": "Candle Data and VWAP"
                        },
                        "content": "# Candle Data and VWAP\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/config/params.ts](src/config/params.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/function/setup.ts](src/function/setup.ts)\n- [src/helpers/toProfitLossDto.ts](src/helpers/toProfitLossDto.ts)\n- [src/index.ts](src/index.ts)\n- [src/interfaces/Heatmap.interface.ts](src/interfaces/Heatmap.interface.ts)\n- [src/lib/services/validation/ConfigValidationService.ts](src/lib/services/validation/ConfigValidationService.ts)\n- [test/config/setup.mjs](test/config/setup.mjs)\n- [test/e2e/config.test.mjs](test/e2e/config.test.mjs)\n- [test/e2e/defend.test.mjs](test/e2e/defend.test.mjs)\n- [test/e2e/risk.test.mjs](test/e2e/risk.test.mjs)\n- [test/e2e/sanitize.test.mjs](test/e2e/sanitize.test.mjs)\n- [test/index.mjs](test/index.mjs)\n- [test/mock/getMockCandles.mjs](test/mock/getMockCandles.mjs)\n- [test/spec/config.test.mjs](test/spec/config.test.mjs)\n- [test/spec/heat.test.mjs](test/spec/heat.test.mjs)\n- [test/spec/list.test.mjs](test/spec/list.test.mjs)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\nThis page documents the candlestick data structure (`ICandleData`), Volume-Weighted Average Price (VWAP) calculation for realistic trade execution pricing, and data quality mechanisms including anomaly detection and retry logic for handling incomplete or failed candle fetches.\n\nFor exchange configuration and data source integration, see [Exchange Configuration](#6.1). For timeframe generation and backtest iteration, see [Timeframes and Frames](#6.3).\n\n---\n\n## Candle Data Structure\n\nAll market data in the framework is represented using the `ICandleData` interface, which contains standard OHLCV (Open-High-Low-Close-Volume) candlestick fields:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `timestamp` | `number` | Unix timestamp in milliseconds when candle opened |\n| `open` | `number` | Opening price at candle start |\n| `high` | `number` | Highest price during candle period |\n| `low` | `number` | Lowest price during candle period |\n| `close` | `number` | Closing price at candle end |\n| `volume` | `number` | Trading volume during candle period |\n\nThis structure is used consistently across:\n- Exchange `getCandles()` implementations (historical data)\n- Backtest fast-forward processing via `getNextCandles()`\n- VWAP calculation for realistic entry/exit pricing\n\n**Sources:** [types.d.ts:287-308]()\n\n---\n\n## VWAP Calculation\n\n### Purpose and Formula\n\nVWAP (Volume-Weighted Average Price) provides realistic execution pricing by weighting candle prices by their trading volume. This prevents unrealistic backtest results from using simple average or close prices.\n\n**Formula:**\n```\nTypical Price = (High + Low + Close) / 3\nVWAP = Σ(Typical Price × Volume) / Σ(Volume)\n```\n\nThe calculation uses the last N candles (configured via `CC_AVG_PRICE_CANDLES_COUNT`) to smooth short-term volatility while remaining responsive to price movements.\n\n### Configuration Parameters\n\n```typescript\nCC_AVG_PRICE_CANDLES_COUNT: 5  // Default: 5 1-minute candles\n```\n\nThis parameter controls:\n- Number of recent candles to include in VWAP calculation\n- Sensitivity to price changes (lower = more responsive, higher = more stable)\n- Minimum data requirement for calculation\n\n**Typical Usage:**\n- `5 candles`: Standard for 1-minute intervals (last 5 minutes)\n- `10+ candles`: Smoother VWAP for higher timeframes or volatile assets\n- `3 candles`: More responsive for fast-moving markets (minimum recommended)\n\n**Sources:** [types.d.ts:14-15](), [src/config/params.ts:8-11]()\n\n---\n\n## VWAP Calculation Flow\n\n```mermaid\ngraph TB\n    subgraph \"Strategy Execution Context\"\n        STRAT[\"ClientStrategy.tick()\"]\n        GET_SIGNAL[\"getSignal callback\"]\n        GET_AVG[\"getAveragePrice()<br/>(public API)\"]\n    end\n    \n    subgraph \"Exchange Core Service\"\n        EXCH_CORE[\"ExchangeCoreService\"]\n        GET_CANDLES[\"getCandles(symbol, '1m', limit)\"]\n        CALC_VWAP[\"Calculate VWAP<br/>Σ(TP × Vol) / Σ(Vol)\"]\n    end\n    \n    subgraph \"Exchange Connection\"\n        CLIENT_EXCH[\"ClientExchange\"]\n        USER_IMPL[\"User getCandles<br/>implementation\"]\n    end\n    \n    subgraph \"Data Quality Layer\"\n        RETRY[\"Retry Logic<br/>CC_GET_CANDLES_RETRY_COUNT\"]\n        ANOMALY[\"Anomaly Detection<br/>VALIDATE_NO_INCOMPLETE_CANDLES_FN\"]\n        MEDIAN[\"Calculate reference price<br/>median or average\"]\n    end\n    \n    STRAT --> GET_SIGNAL\n    GET_SIGNAL --> GET_AVG\n    GET_AVG --> EXCH_CORE\n    \n    EXCH_CORE --> GET_CANDLES\n    GET_CANDLES --> CLIENT_EXCH\n    CLIENT_EXCH --> USER_IMPL\n    \n    USER_IMPL --> RETRY\n    RETRY --> ANOMALY\n    ANOMALY --> MEDIAN\n    \n    MEDIAN --> CALC_VWAP\n    CALC_VWAP --> GET_AVG\n    \n    style GET_AVG fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style CALC_VWAP fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style ANOMALY fill:#ffe6e6,stroke:#333,stroke-width:2px\n```\n\n**Sources:** [types.d.ts:367-413]()\n\n---\n\n## Anomaly Detection for Incomplete Candles\n\n### Problem Statement\n\nExchange APIs (particularly Binance) occasionally return incomplete candles with anomalously low prices:\n\n| Normal Candle | Incomplete Candle | Issue |\n|---------------|-------------------|-------|\n| `open: 42000` | `open: 0.1` | 420,000× lower (factor violation) |\n| `volume: 100` | `volume: 0` | Zero volume indicator |\n| `close: 42050` | `close: 0.12` | Far below market price |\n\nThese anomalies cause:\n- False signal generation (apparent 99.9% price drops)\n- Incorrect VWAP calculations\n- Misleading backtest results\n\n### Detection Algorithm\n\nThe framework implements two-stage anomaly detection:\n\n**Stage 1: Calculate Reference Price**\n\n```typescript\n// If sufficient candles, use median (robust to outliers)\nif (candles.length >= CC_GET_CANDLES_MIN_CANDLES_FOR_MEDIAN) {\n  referencePrice = median([all OHLC prices])\n} else {\n  // For small datasets, use average (more stable)\n  referencePrice = average([all OHLC prices])\n}\n```\n\n**Stage 2: Validate Against Threshold**\n\n```typescript\nthreshold = referencePrice / CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR\n\nfor each price in candle {\n  if (price < threshold) {\n    throw Error(\"Anomalously low price detected\")\n  }\n}\n```\n\n### Configuration Parameters\n\n| Parameter | Default | Purpose |\n|-----------|---------|---------|\n| `CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR` | `1000` | Maximum allowed deviation factor |\n| `CC_GET_CANDLES_MIN_CANDLES_FOR_MEDIAN` | `5` | Minimum candles for median calculation |\n\n**Example:** BTC at $50,000 median\n- Threshold: $50,000 / 1,000 = $50\n- Catches incomplete candles with prices $0.01-$1 (typical incomplete values)\n- Allows legitimate price ranges ($45,000-$55,000)\n\n### Rationale for Factor 1000\n\n```\nFactor   | BTC Threshold | Catches Anomalies? | False Positives?\n---------|---------------|-------------------|------------------\n100      | $500          | ✓ Yes            | ✗ Too permissive\n1,000    | $50           | ✓ Yes            | ✓ Optimal\n10,000   | $5            | ✓ Yes            | ✗ Too strict (altcoins)\n```\n\n**Sources:** [types.d.ts:80-106](), [src/config/params.ts:76-104](), [test/e2e/sanitize.test.mjs:666-784]()\n\n---\n\n## Anomaly Detection Flow Diagram\n\n```mermaid\ngraph TB\n    START[\"getCandles returns<br/>ICandleData[]\"]\n    \n    CHECK_COUNT{\"candles.length >= 5?<br/>(CC_MIN_CANDLES)\"}\n    \n    USE_MEDIAN[\"Calculate median<br/>from all OHLC prices<br/>(robust to outliers)\"]\n    USE_AVG[\"Calculate average<br/>from all OHLC prices<br/>(stable for n<20)\"]\n    \n    CALC_THRESH[\"threshold = referencePrice /<br/>CC_ANOMALY_THRESHOLD_FACTOR<br/>(default: 1000)\"]\n    \n    ITER[\"Iterate each candle<br/>and OHLC price\"]\n    \n    CHECK_PRICE{\"price < threshold?\"}\n    \n    THROW[\"Throw Error<br/>'VALIDATE_NO_INCOMPLETE_CANDLES_FN<br/>found anomalously low price'\"]\n    \n    RETRY{\"Retry count<br/>< CC_RETRY_COUNT?\"}\n    \n    DELAY[\"sleep(CC_RETRY_DELAY_MS)<br/>(default: 5000ms)\"]\n    \n    SUCCESS[\"Return validated<br/>candles to VWAP<br/>calculation\"]\n    \n    FAIL[\"Emit to errorEmitter<br/>Strategy execution stops\"]\n    \n    START --> CHECK_COUNT\n    CHECK_COUNT -->|Yes| USE_MEDIAN\n    CHECK_COUNT -->|No| USE_AVG\n    \n    USE_MEDIAN --> CALC_THRESH\n    USE_AVG --> CALC_THRESH\n    \n    CALC_THRESH --> ITER\n    ITER --> CHECK_PRICE\n    \n    CHECK_PRICE -->|No| SUCCESS\n    CHECK_PRICE -->|Yes| THROW\n    \n    THROW --> RETRY\n    RETRY -->|Yes| DELAY\n    DELAY --> START\n    \n    RETRY -->|No| FAIL\n    \n    style THROW fill:#ffe6e6,stroke:#333,stroke-width:2px\n    style SUCCESS fill:#e6ffe6,stroke:#333,stroke-width:2px\n    style FAIL fill:#ffcccc,stroke:#333,stroke-width:2px\n```\n\n**Sources:** [types.d.ts:80-106](), [test/e2e/sanitize.test.mjs:666-784]()\n\n---\n\n## Retry Logic for Failed Requests\n\n### Configuration\n\n```typescript\nCC_GET_CANDLES_RETRY_COUNT: 3       // Number of retry attempts\nCC_GET_CANDLES_RETRY_DELAY_MS: 5000 // Delay between retries (5 seconds)\n```\n\n### Retry Scenarios\n\nThe framework automatically retries `getCandles()` calls on:\n\n1. **Network failures** (connection timeout, DNS errors)\n2. **Exchange API errors** (rate limits, temporary unavailability)\n3. **Anomaly detection failures** (incomplete candles rejected)\n\n### Retry Strategy\n\n```mermaid\ngraph LR\n    ATTEMPT_1[\"Attempt 1<br/>Immediate\"]\n    DELAY_1[\"Wait 5s\"]\n    ATTEMPT_2[\"Attempt 2\"]\n    DELAY_2[\"Wait 5s\"]\n    ATTEMPT_3[\"Attempt 3\"]\n    DELAY_3[\"Wait 5s\"]\n    ATTEMPT_4[\"Attempt 4<br/>(Final)\"]\n    \n    SUCCESS[\"Success<br/>Return candles\"]\n    FAILURE[\"Emit errorEmitter<br/>Stop execution\"]\n    \n    ATTEMPT_1 -->|Fail| DELAY_1\n    DELAY_1 --> ATTEMPT_2\n    ATTEMPT_2 -->|Fail| DELAY_2\n    DELAY_2 --> ATTEMPT_3\n    ATTEMPT_3 -->|Fail| DELAY_3\n    DELAY_3 --> ATTEMPT_4\n    \n    ATTEMPT_1 -->|Success| SUCCESS\n    ATTEMPT_2 -->|Success| SUCCESS\n    ATTEMPT_3 -->|Success| SUCCESS\n    ATTEMPT_4 -->|Success| SUCCESS\n    ATTEMPT_4 -->|Fail| FAILURE\n    \n    style SUCCESS fill:#e6ffe6,stroke:#333,stroke-width:2px\n    style FAILURE fill:#ffcccc,stroke:#333,stroke-width:2px\n```\n\n**Total Time Budget:** `3 retries × 5 seconds = 15 seconds` (plus request time)\n\n**Sources:** [types.d.ts:69-78](), [src/config/params.ts:66-74]()\n\n---\n\n## Integration with Strategy Execution\n\n### Entry Price Determination\n\nWhen strategies generate signals, the entry price (`priceOpen`) is determined based on signal type:\n\n| Signal Type | Entry Price | Source |\n|-------------|-------------|--------|\n| **Immediate** (no `priceOpen`) | Current VWAP | `getAveragePrice()` |\n| **Scheduled** (with `priceOpen`) | User-specified | Signal DTO |\n\n### VWAP Usage in Backtest\n\n```mermaid\ngraph TB\n    subgraph \"Backtest Timeframe Iteration\"\n        ITER[\"ClientStrategy.tick()<br/>when = timeframe[i]\"]\n        CHECK_SIGNAL[\"Check interval throttle<br/>(e.g., every 5m)\"]\n        GEN_SIGNAL[\"getSignal callback\"]\n    end\n    \n    subgraph \"Signal Creation Path\"\n        IMMEDIATE{\"priceOpen<br/>specified?\"}\n        USE_VWAP[\"priceOpen = getAveragePrice()<br/>(VWAP from last 5 candles)\"]\n        USE_CUSTOM[\"priceOpen = signal.priceOpen<br/>(scheduled for future entry)\"]\n        CREATE[\"Create ISignalRow<br/>with priceOpen set\"]\n    end\n    \n    subgraph \"Signal Monitoring Path\"\n        ACTIVE[\"Active signal monitoring\"]\n        CHECK_TP[\"Check if VWAP >= priceTakeProfit\"]\n        CHECK_SL[\"Check if VWAP <= priceStopLoss\"]\n        CLOSE[\"Close signal<br/>priceClose = VWAP\"]\n    end\n    \n    ITER --> CHECK_SIGNAL\n    CHECK_SIGNAL --> GEN_SIGNAL\n    GEN_SIGNAL --> IMMEDIATE\n    \n    IMMEDIATE -->|No| USE_VWAP\n    IMMEDIATE -->|Yes| USE_CUSTOM\n    \n    USE_VWAP --> CREATE\n    USE_CUSTOM --> CREATE\n    \n    CREATE --> ACTIVE\n    ACTIVE --> CHECK_TP\n    ACTIVE --> CHECK_SL\n    \n    CHECK_TP -->|Yes| CLOSE\n    CHECK_SL -->|Yes| CLOSE\n    \n    style USE_VWAP fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style CLOSE fill:#f9f9f9,stroke:#333,stroke-width:2px\n```\n\n**Key Points:**\n- VWAP provides realistic execution prices (not optimistic high/low)\n- Slippage and fees are applied on top of VWAP in PnL calculation\n- Backtest uses `getNextCandles()` to simulate future price action for TP/SL checks\n\n**Sources:** [types.d.ts:367-413]()\n\n---\n\n## Usage Examples\n\n### Accessing VWAP in Strategy\n\n```typescript\nimport { getAveragePrice } from 'backtest-kit';\n\naddStrategy({\n  strategyName: 'vwap-based-strategy',\n  interval: '5m',\n  getSignal: async (symbol) => {\n    // Get current VWAP (last 5 candles by default)\n    const currentPrice = await getAveragePrice(symbol);\n    \n    // Optional: Get custom candle count via getCandles\n    const candles = await getCandles(symbol, '1m', 10);\n    \n    return {\n      position: 'long',\n      priceTakeProfit: currentPrice * 1.02,  // 2% above VWAP\n      priceStopLoss: currentPrice * 0.98,    // 2% below VWAP\n      minuteEstimatedTime: 60\n    };\n  }\n});\n```\n\n### Configuring VWAP Calculation\n\n```typescript\nimport { setConfig } from 'backtest-kit';\n\n// Use 10 candles for smoother VWAP (less noise)\nsetConfig({\n  CC_AVG_PRICE_CANDLES_COUNT: 10\n});\n\n// Increase retry tolerance for unreliable exchange API\nsetConfig({\n  CC_GET_CANDLES_RETRY_COUNT: 5,\n  CC_GET_CANDLES_RETRY_DELAY_MS: 3000  // 3 seconds between retries\n});\n```\n\n### Handling Anomaly Detection\n\n```typescript\nimport { listenError } from 'backtest-kit';\n\n// Monitor anomaly detection failures\nlistenError((error) => {\n  if (error.message.includes('VALIDATE_NO_INCOMPLETE_CANDLES_FN')) {\n    console.error('Incomplete candle detected and rejected:', error);\n    // Alert monitoring system, log for debugging\n  }\n});\n```\n\n**Sources:** [types.d.ts:14-15](), [src/config/params.ts:8-11](), [test/e2e/sanitize.test.mjs:666-784]()\n\n---\n\n## Configuration Summary\n\n| Parameter | Default | Valid Range | Impact |\n|-----------|---------|-------------|--------|\n| `CC_AVG_PRICE_CANDLES_COUNT` | `5` | 1-50 | Number of candles for VWAP calculation |\n| `CC_GET_CANDLES_RETRY_COUNT` | `3` | 0-10 | Number of retry attempts on failure |\n| `CC_GET_CANDLES_RETRY_DELAY_MS` | `5000` | 1000-30000 | Milliseconds between retries |\n| `CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR` | `1000` | 100-10000 | Maximum price deviation factor |\n| `CC_GET_CANDLES_MIN_CANDLES_FOR_MEDIAN` | `5` | 3-20 | Minimum candles to use median vs average |\n\n**Trade-offs:**\n- **Higher `CC_AVG_PRICE_CANDLES_COUNT`**: Smoother VWAP, less responsive to sudden moves\n- **Higher `CC_GET_CANDLES_RETRY_COUNT`**: More resilient to temporary failures, slower execution on persistent errors\n- **Lower `CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR`**: Stricter anomaly detection, may reject valid low-cap altcoin prices\n\n**Sources:** [src/config/params.ts:8-104](), [types.d.ts:14-15, 69-106]()"
                    },
                    {
                        "page_plan": {
                            "id": "6.3",
                            "title": "Timeframes and Frames"
                        },
                        "content": "# Timeframes and Frames\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/add.ts](src/function/add.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/function/list.ts](src/function/list.ts)\n- [src/index.ts](src/index.ts)\n- [src/lib/core/provide.ts](src/lib/core/provide.ts)\n- [src/lib/core/types.ts](src/lib/core/types.ts)\n- [src/lib/index.ts](src/lib/index.ts)\n- [src/lib/services/logic/private/BacktestLogicPrivateService.ts](src/lib/services/logic/private/BacktestLogicPrivateService.ts)\n- [src/lib/services/logic/private/LiveLogicPrivateService.ts](src/lib/services/logic/private/LiveLogicPrivateService.ts)\n- [src/lib/services/logic/private/WalkerLogicPrivateService.ts](src/lib/services/logic/private/WalkerLogicPrivateService.ts)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis page documents the frame system, which defines backtest periods and generates timeframe arrays for historical simulation. Frames specify date ranges and intervals for backtest execution, producing sequential timestamps that drive strategy tick evaluation.\n\nFor exchange data fetching and candle retrieval, see [Exchange Configuration](#6.1). For candle data structures and VWAP calculation, see [Candle Data and VWAP](#6.2). For overall backtest execution flow, see [Backtest Mode](#5.1).\n\n---\n\n## Frame Configuration Schema\n\nFrames are registered via `addFrame()` using the `IFrameSchema` interface, which defines the backtest period and timestamp generation parameters.\n\n### IFrameSchema Structure\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `frameName` | `FrameName` (string) | Unique identifier for the frame |\n| `note` | `string` (optional) | Developer note for documentation |\n| `interval` | `FrameInterval` | Timestamp spacing interval (e.g., \"1m\", \"1h\", \"1d\") |\n| `startDate` | `Date` | Start of backtest period (inclusive) |\n| `endDate` | `Date` | End of backtest period (inclusive) |\n| `callbacks` | `Partial<IFrameCallbacks>` (optional) | Lifecycle event handlers |\n\n### Frame Intervals\n\nThe `FrameInterval` type defines the granularity of timestamps in the generated timeframe array. Each timestamp represents a tick moment when `ClientStrategy.tick()` is called during backtest execution.\n\n| Interval | Description | Typical Use Case |\n|----------|-------------|------------------|\n| `\"1m\"` | 1 minute | High-frequency strategies, precise entry timing |\n| `\"3m\"` | 3 minutes | Reduced tick count while maintaining granularity |\n| `\"5m\"` | 5 minutes | Intraday strategies with moderate frequency |\n| `\"15m\"` | 15 minutes | Standard intraday timeframe |\n| `\"30m\"` | 30 minutes | Swing trading, reduced computational overhead |\n| `\"1h\"` | 1 hour | Hourly strategy evaluation |\n| `\"2h\"` | 2 hours | Multi-hour analysis |\n| `\"4h\"` | 4 hours | Standard 4-hour trading timeframe |\n| `\"6h\"` | 6 hours | Quarter-day analysis |\n| `\"8h\"` | 8 hours | Third-day analysis |\n| `\"12h\"` | 12 hours | Half-day analysis |\n| `\"1d\"` | 1 day | Daily strategy evaluation |\n| `\"3d\"` | 3 days | Multi-day swing trading |\n\n**Sources:** [types.d.ts:427](), [types.d.ts:470-483]()\n\n---\n\n## Frame Callbacks\n\nThe `IFrameCallbacks` interface provides lifecycle hooks for frame events.\n\n### onTimeframe Callback\n\nCalled after timeframe array generation, providing access to the generated timestamps and configuration parameters.\n\n**Signature:**\n```typescript\nonTimeframe: (\n  timeframe: Date[],\n  startDate: Date,\n  endDate: Date,\n  interval: FrameInterval\n) => void\n```\n\n**Parameters:**\n- `timeframe`: Array of Date objects representing tick timestamps\n- `startDate`: Start of the backtest period\n- `endDate`: End of the backtest period  \n- `interval`: Interval used for generation\n\n**Use Cases:**\n- Logging timeframe size for debugging\n- Validating generated timestamps\n- Performance monitoring\n- Custom reporting\n\n**Sources:** [types.d.ts:438-450]()\n\n---\n\n## Frame Registration and Discovery\n\n### Registration via addFrame\n\nFrames are registered using the `addFrame()` function, which validates and stores the frame schema in `FrameSchemaService`.\n\n**Example:**\n```typescript\naddFrame({\n  frameName: \"1d-backtest\",\n  note: \"One day test period\",\n  interval: \"1m\",\n  startDate: new Date(\"2024-01-01T00:00:00Z\"),\n  endDate: new Date(\"2024-01-02T00:00:00Z\"),\n  callbacks: {\n    onTimeframe: (timeframe, startDate, endDate, interval) => {\n      console.log(`Generated ${timeframe.length} timestamps from ${startDate.toISOString()} to ${endDate.toISOString()} at ${interval} intervals`);\n    }\n  }\n});\n```\n\n### Registration Flow\n\n```mermaid\ngraph TB\n    USER[\"User Code<br/>addFrame call\"]\n    ADD[\"addFrame()<br/>src/function/add.ts\"]\n    LOGGER[\"LoggerService<br/>Log registration\"]\n    VALIDATION[\"FrameValidationService<br/>Validate schema\"]\n    SCHEMA[\"FrameSchemaService<br/>Store schema\"]\n    REGISTRY[\"Internal Registry<br/>Map&lt;frameName, IFrameSchema&gt;\"]\n    \n    USER -->|\"IFrameSchema\"| ADD\n    ADD --> LOGGER\n    ADD --> VALIDATION\n    VALIDATION -->|\"Check fields\"| VALIDATION\n    VALIDATION -->|\"Validate dates\"| VALIDATION\n    VALIDATION -->|\"Validate interval\"| VALIDATION\n    ADD --> SCHEMA\n    SCHEMA -->|\"register(frameName, schema)\"| REGISTRY\n    \n    style USER fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style REGISTRY fill:#e1f5ff,stroke:#333,stroke-width:2px\n```\n\n**Sources:** [src/function/add.ts:145-151](), [src/lib/index.ts:24](), [src/lib/index.ts:44]()\n\n### Discovery via listFrames\n\nAll registered frames can be retrieved using `listFrames()`, which returns an array of `IFrameSchema` objects.\n\n**Example:**\n```typescript\nconst frames = await listFrames();\nfor (const frame of frames) {\n  console.log(`Frame: ${frame.frameName}, Interval: ${frame.interval}`);\n  console.log(`Period: ${frame.startDate.toISOString()} to ${frame.endDate.toISOString()}`);\n}\n```\n\n**Sources:** [src/function/list.ts:108-111]()\n\n---\n\n## Timeframe Generation\n\n### getTimeframe Method\n\nThe `IFrame.getTimeframe()` method generates an array of Date objects spaced according to the configured interval. This array drives backtest execution by defining every moment when `ClientStrategy.tick()` is called.\n\n**Signature:**\n```typescript\ngetTimeframe: (symbol: string, frameName: FrameName) => Promise<Date[]>\n```\n\n**Parameters:**\n- `symbol`: Trading pair symbol (unused in implementation, present for API consistency)\n- `frameName`: Frame identifier to retrieve from registry\n\n**Returns:** Promise resolving to array of Date objects representing tick timestamps\n\n### Timeframe Generation Architecture\n\n```mermaid\ngraph TB\n    BACKTEST[\"BacktestLogicPrivateService.run()\"]\n    FRAME_CORE[\"FrameCoreService<br/>getTimeframe()\"]\n    FRAME_CONN[\"FrameConnectionService<br/>Memoized ClientFrame\"]\n    CLIENT_FRAME[\"ClientFrame<br/>implements IFrame\"]\n    SCHEMA_SERVICE[\"FrameSchemaService<br/>Retrieve schema\"]\n    GENERATOR[\"Timeframe Generator<br/>Date iteration logic\"]\n    TIMEFRAME[\"Date[] Timeframe Array<br/>[timestamp1, timestamp2, ...]\"]\n    CALLBACK[\"onTimeframe Callback<br/>Optional notification\"]\n    \n    BACKTEST -->|\"await getTimeframe(symbol, frameName)\"| FRAME_CORE\n    FRAME_CORE -->|\"Get memoized instance\"| FRAME_CONN\n    FRAME_CONN -->|\"Key: frameName\"| FRAME_CONN\n    FRAME_CONN -->|\"new ClientFrame(params)\"| CLIENT_FRAME\n    CLIENT_FRAME -->|\"Retrieve schema\"| SCHEMA_SERVICE\n    CLIENT_FRAME -->|\"Generate timestamps\"| GENERATOR\n    GENERATOR -->|\"startDate + interval * i\"| GENERATOR\n    GENERATOR -->|\"while timestamp <= endDate\"| GENERATOR\n    GENERATOR --> TIMEFRAME\n    CLIENT_FRAME -->|\"Invoke callback\"| CALLBACK\n    CLIENT_FRAME --> TIMEFRAME\n    FRAME_CORE --> TIMEFRAME\n    BACKTEST -->|\"Iterate through timeframes\"| BACKTEST\n    \n    style TIMEFRAME fill:#e1f5ff,stroke:#333,stroke-width:2px\n    style BACKTEST fill:#fff4e1,stroke:#333,stroke-width:2px\n```\n\n**Sources:** [types.d.ts:488-497](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:69-73]()\n\n### Generation Algorithm\n\nThe timeframe generation follows this logic:\n\n1. Retrieve `IFrameSchema` from `FrameSchemaService` by `frameName`\n2. Initialize array with `startDate`\n3. Increment timestamp by interval duration\n4. Append to array while timestamp <= `endDate`\n5. Invoke `onTimeframe` callback if configured\n6. Return Date array\n\n**Example Output:**\n```typescript\n// Frame: interval=\"1m\", startDate=2024-01-01T00:00:00Z, endDate=2024-01-01T00:05:00Z\n// Generated timeframe:\n[\n  new Date(\"2024-01-01T00:00:00Z\"), // timestamp 0\n  new Date(\"2024-01-01T00:01:00Z\"), // timestamp 1\n  new Date(\"2024-01-01T00:02:00Z\"), // timestamp 2\n  new Date(\"2024-01-01T00:03:00Z\"), // timestamp 3\n  new Date(\"2024-01-01T00:04:00Z\"), // timestamp 4\n  new Date(\"2024-01-01T00:05:00Z\"), // timestamp 5\n]\n// Total: 6 timestamps (5 minutes + 1 for inclusive endDate)\n```\n\n**Sources:** [types.d.ts:488-497](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:69-73]()\n\n---\n\n## Frame Service Architecture\n\nThe frame system uses a layered service architecture with dependency injection for loose coupling and memoization for performance optimization.\n\n### Service Layer Diagram\n\n```mermaid\ngraph TB\n    subgraph \"Public API Layer\"\n        ADD_FRAME[\"addFrame()<br/>Function\"]\n        LIST_FRAMES[\"listFrames()<br/>Function\"]\n    end\n    \n    subgraph \"Validation Layer\"\n        FRAME_VAL[\"FrameValidationService<br/>addFrame() validation<br/>list() retrieval\"]\n    end\n    \n    subgraph \"Schema Layer\"\n        FRAME_SCHEMA[\"FrameSchemaService<br/>register(frameName, schema)<br/>get(frameName)\"]\n        REGISTRY[\"Registry Storage<br/>Map&lt;FrameName, IFrameSchema&gt;\"]\n    end\n    \n    subgraph \"Connection Layer\"\n        FRAME_CONN[\"FrameConnectionService<br/>Memoized factory<br/>getFrame(frameName)\"]\n        MEMO_CACHE[\"Memoization Cache<br/>Map&lt;FrameName, ClientFrame&gt;\"]\n    end\n    \n    subgraph \"Core Layer\"\n        FRAME_CORE[\"FrameCoreService<br/>getTimeframe(symbol, frameName)\"]\n    end\n    \n    subgraph \"Client Layer\"\n        CLIENT_FRAME[\"ClientFrame<br/>implements IFrame<br/>getTimeframe() implementation\"]\n    end\n    \n    subgraph \"Logic Layer\"\n        BACKTEST_LOGIC[\"BacktestLogicPrivateService<br/>Consumes timeframes\"]\n    end\n    \n    ADD_FRAME --> FRAME_VAL\n    LIST_FRAMES --> FRAME_VAL\n    FRAME_VAL --> FRAME_SCHEMA\n    FRAME_SCHEMA --> REGISTRY\n    \n    BACKTEST_LOGIC --> FRAME_CORE\n    FRAME_CORE --> FRAME_CONN\n    FRAME_CONN --> MEMO_CACHE\n    FRAME_CONN --> CLIENT_FRAME\n    CLIENT_FRAME --> FRAME_SCHEMA\n    CLIENT_FRAME --> REGISTRY\n    \n    style REGISTRY fill:#e1f5ff,stroke:#333,stroke-width:2px\n    style MEMO_CACHE fill:#e1f5ff,stroke:#333,stroke-width:2px\n    style CLIENT_FRAME fill:#fff4e1,stroke:#333,stroke-width:2px\n```\n\n**Sources:** [src/lib/index.ts:24](), [src/lib/index.ts:44](), [src/lib/index.ts:81](), [src/lib/index.ts:116]()\n\n### Service Responsibilities\n\n| Service | File Reference | Responsibility |\n|---------|----------------|----------------|\n| `FrameValidationService` | [src/lib/index.ts:44]() | Validates frame schema structure on registration, provides list() method |\n| `FrameSchemaService` | [src/lib/index.ts:24]() | Stores frame schemas in registry, provides get(frameName) retrieval |\n| `FrameConnectionService` | [src/lib/index.ts:81]() | Creates and memoizes ClientFrame instances, key: frameName |\n| `FrameCoreService` | [src/lib/index.ts:116]() | Provides getTimeframe() method, delegates to connection service |\n| `ClientFrame` | [types.d.ts:432-435]() | Implements IFrame interface, generates timeframe arrays |\n\n**Sources:** [src/lib/index.ts:24](), [src/lib/index.ts:44](), [src/lib/index.ts:81](), [src/lib/index.ts:116]()\n\n---\n\n## Frame Usage in Backtest Execution\n\nFrames drive the backtest execution loop by providing an ordered sequence of timestamps for strategy evaluation.\n\n### Backtest Iteration Flow\n\n```mermaid\ngraph TB\n    START[\"BacktestLogicPrivateService.run(symbol)\"]\n    GET_FRAME[\"frameCoreService.getTimeframe(symbol, frameName)\"]\n    TIMEFRAMES[\"timeframes: Date[]<br/>Array of timestamps\"]\n    INIT_LOOP[\"Initialize loop:<br/>i = 0\"]\n    LOOP_CHECK{\"i < timeframes.length?\"}\n    GET_WHEN[\"when = timeframes[i]\"]\n    PROGRESS[\"Emit progressBacktestEmitter<br/>{processedFrames: i, totalFrames, progress}\"]\n    TICK[\"strategyCoreService.tick(symbol, when, true)\"]\n    RESULT{\"result.action?\"}\n    IDLE[\"Action: idle<br/>Continue to next frame\"]\n    OPENED[\"Action: opened<br/>Fetch candles<br/>Call backtest()\"]\n    SCHEDULED[\"Action: scheduled<br/>Fetch candles<br/>Call backtest()\"]\n    BACKTEST[\"backtest(symbol, candles, when)\"]\n    CLOSE_TS[\"backtestResult.closeTimestamp\"]\n    SKIP[\"Skip frames:<br/>while timeframes[i] < closeTimestamp\"]\n    YIELD[\"yield backtestResult\"]\n    INCREMENT[\"i++\"]\n    END[\"Backtest complete\"]\n    \n    START --> GET_FRAME\n    GET_FRAME --> TIMEFRAMES\n    TIMEFRAMES --> INIT_LOOP\n    INIT_LOOP --> LOOP_CHECK\n    LOOP_CHECK -->|\"Yes\"| GET_WHEN\n    LOOP_CHECK -->|\"No\"| END\n    GET_WHEN --> PROGRESS\n    PROGRESS --> TICK\n    TICK --> RESULT\n    RESULT -->|\"idle\"| IDLE\n    RESULT -->|\"opened\"| OPENED\n    RESULT -->|\"scheduled\"| SCHEDULED\n    IDLE --> INCREMENT\n    OPENED --> BACKTEST\n    SCHEDULED --> BACKTEST\n    BACKTEST --> CLOSE_TS\n    CLOSE_TS --> SKIP\n    SKIP --> YIELD\n    YIELD --> LOOP_CHECK\n    INCREMENT --> LOOP_CHECK\n    \n    style TIMEFRAMES fill:#e1f5ff,stroke:#333,stroke-width:2px\n    style YIELD fill:#fff4e1,stroke:#333,stroke-width:2px\n```\n\n**Sources:** [src/lib/services/logic/private/BacktestLogicPrivateService.ts:62-477]()\n\n### Key Implementation Details\n\n1. **Frame Retrieval** ([src/lib/services/logic/private/BacktestLogicPrivateService.ts:69-73]()):\n   - `BacktestLogicPrivateService` calls `frameCoreService.getTimeframe(symbol, frameName)`\n   - Returns `Date[]` array of timestamps\n   - Stored in `timeframes` variable for iteration\n\n2. **Sequential Iteration** ([src/lib/services/logic/private/BacktestLogicPrivateService.ts:78-449]()):\n   - Loop: `while (i < timeframes.length)`\n   - Each iteration: `when = timeframes[i]`\n   - `when` passed to `strategyCoreService.tick(symbol, when, true)`\n\n3. **Progress Tracking** ([src/lib/services/logic/private/BacktestLogicPrivateService.ts:84-92]()):\n   - Emits `progressBacktestEmitter` with processed/total frame counts\n   - Progress calculation: `i / totalFrames`\n\n4. **Frame Skipping Optimization** ([src/lib/services/logic/private/BacktestLogicPrivateService.ts:273-279](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:403-409]()):\n   - When signal opens, `backtest()` processes all candles until close\n   - After signal closes, skip timeframes until `closeTimestamp`\n   - Optimization: avoids redundant tick calls while position is active\n\n**Sources:** [src/lib/services/logic/private/BacktestLogicPrivateService.ts:62-477]()\n\n---\n\n## Frame Context Propagation\n\nFrames are propagated through the execution context via `MethodContextService`, which uses dependency injection scoping to provide implicit context without explicit parameter passing.\n\n### Context Flow Architecture\n\n```mermaid\ngraph TB\n    BACKTEST_CMD[\"BacktestCommandService<br/>Entry point\"]\n    BACKTEST_PUB[\"BacktestLogicPublicService<br/>Context wrapper\"]\n    METHOD_CTX[\"MethodContextService<br/>runAsyncIterator()\"]\n    CONTEXT[\"IMethodContext<br/>{exchangeName, strategyName, frameName}\"]\n    BACKTEST_PRIV[\"BacktestLogicPrivateService<br/>run() generator\"]\n    FRAME_CORE[\"FrameCoreService<br/>getTimeframe()\"]\n    GET_CONTEXT[\"methodContextService.context.frameName\"]\n    \n    BACKTEST_CMD -->|\"validate inputs\"| BACKTEST_PUB\n    BACKTEST_PUB -->|\"setup context\"| METHOD_CTX\n    METHOD_CTX -->|\"inject context\"| CONTEXT\n    METHOD_CTX -->|\"run generator\"| BACKTEST_PRIV\n    BACKTEST_PRIV -->|\"read frameName\"| GET_CONTEXT\n    GET_CONTEXT -->|\"frameName string\"| FRAME_CORE\n    FRAME_CORE -->|\"getTimeframe(symbol, frameName)\"| FRAME_CORE\n    \n    style CONTEXT fill:#e1f5ff,stroke:#333,stroke-width:2px\n    style GET_CONTEXT fill:#fff4e1,stroke:#333,stroke-width:2px\n```\n\n**Sources:** [types.d.ts:510-517](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:44-46](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:69-73]()\n\n### Context Structure\n\nThe `IMethodContext` interface provides routing information for service lookups:\n\n```typescript\ninterface IMethodContext {\n  exchangeName: ExchangeName;\n  strategyName: StrategyName;\n  frameName: FrameName;  // Used for frame retrieval\n}\n```\n\n**Usage in BacktestLogicPrivateService:**\n- Injected: [src/lib/services/logic/private/BacktestLogicPrivateService.ts:44-46]()\n- Read: [src/lib/services/logic/private/BacktestLogicPrivateService.ts:71]()\n- Passed to: `frameCoreService.getTimeframe(symbol, this.methodContextService.context.frameName)`\n\n**Sources:** [types.d.ts:510-517](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:44-46](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:69-73]()\n\n---\n\n## Complete Frame Lifecycle Example\n\nThis example demonstrates the complete lifecycle from frame registration to backtest execution.\n\n```typescript\n// 1. Register frame\naddFrame({\n  frameName: \"jan-2024-test\",\n  interval: \"5m\",\n  startDate: new Date(\"2024-01-01T00:00:00Z\"),\n  endDate: new Date(\"2024-01-01T12:00:00Z\"),  // 12 hours\n  callbacks: {\n    onTimeframe: (timeframe, startDate, endDate, interval) => {\n      console.log(`Frame generated: ${timeframe.length} timestamps`);\n      console.log(`Period: ${startDate.toISOString()} to ${endDate.toISOString()}`);\n      console.log(`Interval: ${interval}`);\n      // Output: Frame generated: 145 timestamps (12 hours * 12 per hour + 1)\n    }\n  }\n});\n\n// 2. Register other required components\naddExchange({ /* exchange config */ });\naddStrategy({ /* strategy config */ });\n\n// 3. Run backtest\nfor await (const result of Backtest.run(\"BTCUSDT\", {\n  strategyName: \"my-strategy\",\n  exchangeName: \"binance\",\n  frameName: \"jan-2024-test\"  // References registered frame\n})) {\n  if (result.action === \"closed\") {\n    console.log(`Signal closed at ${new Date(result.closeTimestamp).toISOString()}`);\n  }\n}\n\n// Internal execution flow:\n// 1. BacktestLogicPrivateService.run() called\n// 2. frameCoreService.getTimeframe(\"BTCUSDT\", \"jan-2024-test\")\n// 3. FrameConnectionService retrieves/creates ClientFrame\n// 4. ClientFrame generates 145 timestamps (5-minute intervals for 12 hours)\n// 5. Loop iterates: i=0 to i=144\n// 6. Each iteration: strategyCoreService.tick() called with timeframes[i]\n// 7. When signal opens: backtest() processes candles, skips to close\n// 8. Process continues until i >= 145\n```\n\n**Sources:** [src/function/add.ts:145-151](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:62-477]()"
                    },
                    {
                        "page_plan": {
                            "id": "7",
                            "title": "Configuration System"
                        },
                        "content": "# Configuration System\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/config/params.ts](src/config/params.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/function/setup.ts](src/function/setup.ts)\n- [src/helpers/toProfitLossDto.ts](src/helpers/toProfitLossDto.ts)\n- [src/index.ts](src/index.ts)\n- [src/interfaces/Heatmap.interface.ts](src/interfaces/Heatmap.interface.ts)\n- [src/lib/services/validation/ConfigValidationService.ts](src/lib/services/validation/ConfigValidationService.ts)\n- [test/config/setup.mjs](test/config/setup.mjs)\n- [test/e2e/config.test.mjs](test/e2e/config.test.mjs)\n- [test/e2e/defend.test.mjs](test/e2e/defend.test.mjs)\n- [test/e2e/risk.test.mjs](test/e2e/risk.test.mjs)\n- [test/e2e/sanitize.test.mjs](test/e2e/sanitize.test.mjs)\n- [test/index.mjs](test/index.mjs)\n- [test/mock/getMockCandles.mjs](test/mock/getMockCandles.mjs)\n- [test/spec/config.test.mjs](test/spec/config.test.mjs)\n- [test/spec/heat.test.mjs](test/spec/heat.test.mjs)\n- [test/spec/list.test.mjs](test/spec/list.test.mjs)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\nThe Configuration System provides centralized management of global parameters that control framework behavior, economic constraints, and safety limits. It enforces economic viability validation to prevent unprofitable trading configurations and provides runtime configuration updates with automatic rollback on validation failure.\n\nFor strategy-specific configuration, see [Defining Strategies](#4.1). For risk management configuration, see [Risk Management](#4.3). For exchange and frame configuration, see [Exchange Configuration](#6.1) and [Timeframes and Frames](#6.3).\n\n---\n\n## Architecture Overview\n\nThe configuration system consists of a global configuration object, validation service, and API functions that ensure type safety and economic viability.\n\n```mermaid\ngraph TB\n    subgraph \"Configuration Storage\"\n        GLOBAL_CONFIG[\"GLOBAL_CONFIG<br/>(src/config/params.ts)\"]\n        DEFAULT_CONFIG[\"DEFAULT_CONFIG<br/>(Frozen Reference)\"]\n    end\n    \n    subgraph \"Public API - src/function/setup.ts\"\n        setConfig[\"setConfig(config, _unsafe?)\"]\n        getConfig[\"getConfig()\"]\n        getDefaultConfig[\"getDefaultConfig()\"]\n    end\n    \n    subgraph \"Validation Layer\"\n        ConfigValidationService[\"ConfigValidationService<br/>(Economic Viability Checks)\"]\n    end\n    \n    subgraph \"Consumers\"\n        toProfitLossDto[\"toProfitLossDto<br/>(PnL Calculation)\"]\n        ClientExchange[\"ClientExchange<br/>(VWAP, Retry Logic)\"]\n        ClientStrategy[\"ClientStrategy<br/>(Signal Validation)\"]\n        SignalValidation[\"Signal Validation Functions<br/>(TP/SL Distance Checks)\"]\n        ScheduleValidation[\"Schedule Validation<br/>(Timeout Logic)\"]\n        MarkdownServices[\"Markdown Services<br/>(Report Formatting)\"]\n    end\n    \n    setConfig -->|\"validates before apply\"| ConfigValidationService\n    ConfigValidationService -->|\"reads\"| GLOBAL_CONFIG\n    ConfigValidationService -->|\"throws on failure\"| setConfig\n    setConfig -->|\"modifies on success\"| GLOBAL_CONFIG\n    setConfig -->|\"rollback on error\"| GLOBAL_CONFIG\n    \n    getConfig -->|\"returns copy\"| GLOBAL_CONFIG\n    getDefaultConfig -->|\"returns frozen copy\"| DEFAULT_CONFIG\n    \n    GLOBAL_CONFIG -->|\"CC_PERCENT_SLIPPAGE<br/>CC_PERCENT_FEE\"| toProfitLossDto\n    GLOBAL_CONFIG -->|\"CC_AVG_PRICE_CANDLES_COUNT<br/>CC_GET_CANDLES_RETRY_COUNT<br/>CC_GET_CANDLES_RETRY_DELAY_MS\"| ClientExchange\n    GLOBAL_CONFIG -->|\"CC_MAX_SIGNAL_GENERATION_SECONDS<br/>CC_MAX_SIGNAL_LIFETIME_MINUTES\"| ClientStrategy\n    GLOBAL_CONFIG -->|\"CC_MIN_TAKEPROFIT_DISTANCE_PERCENT<br/>CC_MIN_STOPLOSS_DISTANCE_PERCENT<br/>CC_MAX_STOPLOSS_DISTANCE_PERCENT\"| SignalValidation\n    GLOBAL_CONFIG -->|\"CC_SCHEDULE_AWAIT_MINUTES\"| ScheduleValidation\n    GLOBAL_CONFIG -->|\"CC_REPORT_SHOW_SIGNAL_NOTE\"| MarkdownServices\n```\n\n**Sources**: [src/config/params.ts:1-122](), [src/function/setup.ts:1-89](), [src/lib/services/validation/ConfigValidationService.ts:1-166]()\n\n---\n\n## Global Configuration Parameters\n\nThe `GLOBAL_CONFIG` object contains 14 parameters organized into four categories:\n\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| **Economic Parameters** |\n| `CC_PERCENT_SLIPPAGE` | `number` | `0.1` | Slippage percentage per transaction (applied twice: entry + exit) |\n| `CC_PERCENT_FEE` | `number` | `0.1` | Fee percentage per transaction (applied twice: entry + exit) |\n| `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT` | `number` | `0.5` | Minimum TP distance from priceOpen (must cover slippage + fees) |\n| `CC_MIN_STOPLOSS_DISTANCE_PERCENT` | `number` | `0.5` | Minimum SL distance from priceOpen (prevents instant stops) |\n| `CC_MAX_STOPLOSS_DISTANCE_PERCENT` | `number` | `20.0` | Maximum SL distance from priceOpen (caps risk per signal) |\n| **Time-Based Parameters** |\n| `CC_SCHEDULE_AWAIT_MINUTES` | `number` | `120` | Time to wait for scheduled signal activation before cancellation |\n| `CC_MAX_SIGNAL_LIFETIME_MINUTES` | `number` | `1440` | Maximum signal lifetime (prevents eternal positions) |\n| `CC_MAX_SIGNAL_GENERATION_SECONDS` | `number` | `180` | Maximum time allowed for signal generation (prevents hangs) |\n| **Data Fetching Parameters** |\n| `CC_AVG_PRICE_CANDLES_COUNT` | `number` | `5` | Number of candles for VWAP calculation |\n| `CC_GET_CANDLES_RETRY_COUNT` | `number` | `3` | Number of retries for failed candle fetches |\n| `CC_GET_CANDLES_RETRY_DELAY_MS` | `number` | `5000` | Delay between retry attempts (milliseconds) |\n| `CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR` | `number` | `1000` | Maximum deviation factor for anomaly detection (catches incomplete candles) |\n| `CC_GET_CANDLES_MIN_CANDLES_FOR_MEDIAN` | `number` | `5` | Minimum candles required for median calculation (use average below this) |\n| **Reporting Parameters** |\n| `CC_REPORT_SHOW_SIGNAL_NOTE` | `boolean` | `false` | Controls visibility of signal notes in markdown reports |\n\n**Sources**: [types.d.ts:5-115](), [src/config/params.ts:1-122]()\n\n---\n\n## Economic Parameters and Cost Model\n\nThe framework uses a realistic cost model that applies slippage and fees to both entry and exit prices. The economic parameters ensure that signals are profitable when TakeProfit is hit.\n\n```mermaid\ngraph LR\n    subgraph \"Cost Calculation\"\n        Entry[\"Entry Price\"]\n        Exit[\"Exit Price\"]\n        \n        Entry -->|\"+CC_PERCENT_SLIPPAGE (LONG)<br/>-CC_PERCENT_SLIPPAGE (SHORT)\"| EntryWithSlippage[\"Entry with Slippage\"]\n        Exit -->|\"-CC_PERCENT_SLIPPAGE (LONG)<br/>+CC_PERCENT_SLIPPAGE (SHORT)\"| ExitWithSlippage[\"Exit with Slippage\"]\n        \n        EntryWithSlippage -->|\"-CC_PERCENT_FEE\"| EntryWithFees[\"Entry after Fees\"]\n        ExitWithSlippage -->|\"-CC_PERCENT_FEE\"| ExitWithFees[\"Exit after Fees\"]\n        \n        EntryWithFees --> PnL[\"PnL Calculation\"]\n        ExitWithFees --> PnL\n        \n        PnL --> TotalCost[\"Total Cost = Slippage×2 + Fees×2\"]\n    end\n    \n    subgraph \"Minimum TP Distance Validation\"\n        TotalCost --> MinTP[\"CC_MIN_TAKEPROFIT_DISTANCE_PERCENT<br/>Must be ≥ Total Cost\"]\n        MinTP --> Validation[\"ConfigValidationService<br/>Ensures Profitable Trades\"]\n    end\n```\n\n### Cost Breakdown Example\n\nFor default configuration (`CC_PERCENT_SLIPPAGE = 0.1%`, `CC_PERCENT_FEE = 0.1%`):\n\n- **Slippage Effect**: 0.1% × 2 = 0.2% (entry + exit)\n- **Total Fees**: 0.1% × 2 = 0.2% (entry + exit)\n- **Total Cost**: 0.4%\n- **Minimum TP Distance**: 0.5% (default, covers costs + 0.1% profit buffer)\n\nThis ensures that when TakeProfit is hit, the signal yields at least 0.1% net profit after all costs.\n\n**Sources**: [src/helpers/toProfitLossDto.ts:1-82](), [src/lib/services/validation/ConfigValidationService.ts:69-88](), [types.d.ts:12-40]()\n\n---\n\n## Economic Viability Validation\n\nThe `ConfigValidationService` enforces constraints that prevent mathematically unprofitable configurations. Validation occurs automatically when `setConfig()` is called (unless `_unsafe` flag is set).\n\n### Validation Rules\n\n```mermaid\ngraph TB\n    subgraph \"Validation Checks\"\n        Check1[\"Slippage ≥ 0<br/>(CC_PERCENT_SLIPPAGE)\"]\n        Check2[\"Fees ≥ 0<br/>(CC_PERCENT_FEE)\"]\n        Check3[\"Min TP Distance > 0<br/>(CC_MIN_TAKEPROFIT_DISTANCE_PERCENT)\"]\n        Check4[\"Min TP ≥ (Slippage×2 + Fees×2)<br/>(Economic Viability)\"]\n        Check5[\"Min SL > 0<br/>(CC_MIN_STOPLOSS_DISTANCE_PERCENT)\"]\n        Check6[\"Max SL > 0<br/>(CC_MAX_STOPLOSS_DISTANCE_PERCENT)\"]\n        Check7[\"Min SL < Max SL<br/>(Range Consistency)\"]\n        Check8[\"Schedule Timeout > 0<br/>(CC_SCHEDULE_AWAIT_MINUTES)\"]\n        Check9[\"Signal Lifetime > 0<br/>(CC_MAX_SIGNAL_LIFETIME_MINUTES)\"]\n        Check10[\"Generation Timeout > 0<br/>(CC_MAX_SIGNAL_GENERATION_SECONDS)\"]\n        Check11[\"Candle Count > 0<br/>(CC_AVG_PRICE_CANDLES_COUNT)\"]\n        Check12[\"Retry Count ≥ 0<br/>(CC_GET_CANDLES_RETRY_COUNT)\"]\n        Check13[\"Retry Delay > 0<br/>(CC_GET_CANDLES_RETRY_DELAY_MS)\"]\n        Check14[\"Anomaly Threshold > 0<br/>(CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR)\"]\n        Check15[\"Min Candles for Median > 0<br/>(CC_GET_CANDLES_MIN_CANDLES_FOR_MEDIAN)\"]\n    end\n    \n    subgraph \"Critical Validation\"\n        Check4 -->|\"MOST IMPORTANT\"| EconomicViability[\"Ensures all TP signals<br/>are profitable after costs\"]\n    end\n    \n    AllChecks[\"All 15 Checks\"] --> Pass[\"Pass: Apply Config\"]\n    AllChecks --> Fail[\"Fail: Throw Error<br/>Rollback to Previous Config\"]\n```\n\n### Key Validation: Economic Viability\n\nThe most critical validation ensures `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT` covers all trading costs:\n\n```typescript\n// From ConfigValidationService\nconst slippageEffect = GLOBAL_CONFIG.CC_PERCENT_SLIPPAGE * 2; // Entry + exit\nconst feesTotal = GLOBAL_CONFIG.CC_PERCENT_FEE * 2; // Entry + exit\nconst minRequiredTpDistance = slippageEffect + feesTotal;\n\nif (GLOBAL_CONFIG.CC_MIN_TAKEPROFIT_DISTANCE_PERCENT < minRequiredTpDistance) {\n  throw new Error(\n    `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT (${GLOBAL_CONFIG.CC_MIN_TAKEPROFIT_DISTANCE_PERCENT}%) ` +\n    `is too low to cover trading costs.\\n` +\n    `Required minimum: ${minRequiredTpDistance.toFixed(2)}%\\n` +\n    `All TakeProfit signals will be unprofitable with current settings!`\n  );\n}\n```\n\n**Example Error Output**:\n\n```\nGLOBAL_CONFIG validation failed:\n  CC_MIN_TAKEPROFIT_DISTANCE_PERCENT (0.3%) is too low to cover trading costs.\n  Required minimum: 0.40%\n  Breakdown:\n    - Slippage effect: 0.20% (0.1% × 2 transactions)\n    - Fees: 0.20% (0.1% × 2 transactions)\n  All TakeProfit signals will be unprofitable with current settings!\n```\n\n**Sources**: [src/lib/services/validation/ConfigValidationService.ts:55-163]()\n\n---\n\n## Configuration API\n\nThe framework provides three functions for configuration management:\n\n### `setConfig(config, _unsafe?)`\n\nUpdates global configuration with validation. On validation failure, automatically rolls back to previous configuration.\n\n**Parameters**:\n- `config`: `Partial<GlobalConfig>` - Parameters to update (only specified fields are changed)\n- `_unsafe`: `boolean` - Skip validation (used in test environments)\n\n**Behavior**:\n1. Saves current configuration for rollback\n2. Applies partial update to `GLOBAL_CONFIG`\n3. Runs `ConfigValidationService.validate()` (unless `_unsafe` is true)\n4. On error: restores previous configuration and re-throws error\n5. On success: new configuration is active\n\n**Example**:\n\n```typescript\nimport { setConfig } from 'backtest-kit';\n\n// Update slippage and fees\nsetConfig({\n  CC_PERCENT_SLIPPAGE: 0.15,  // Increase slippage to 0.15%\n  CC_PERCENT_FEE: 0.12,       // Increase fees to 0.12%\n});\n\n// Validation will fail if TP distance is too low\ntry {\n  setConfig({\n    CC_MIN_TAKEPROFIT_DISTANCE_PERCENT: 0.2,  // Too low for new costs\n  });\n} catch (error) {\n  console.error('Config rejected:', error.message);\n  // GLOBAL_CONFIG remains unchanged\n}\n```\n\n**Sources**: [src/function/setup.ts:23-52]()\n\n### `getConfig()`\n\nReturns a shallow copy of the current configuration. Use this to inspect current settings without modifying them.\n\n**Returns**: `GlobalConfig` - Copy of current configuration\n\n**Example**:\n\n```typescript\nimport { getConfig } from 'backtest-kit';\n\nconst currentConfig = getConfig();\nconsole.log('Current slippage:', currentConfig.CC_PERCENT_SLIPPAGE);\nconsole.log('Current fee:', currentConfig.CC_PERCENT_FEE);\n\n// Modifying the returned object does NOT affect GLOBAL_CONFIG\ncurrentConfig.CC_PERCENT_SLIPPAGE = 999; // No effect on actual config\n```\n\n**Sources**: [src/function/setup.ts:54-70]()\n\n### `getDefaultConfig()`\n\nReturns a frozen reference to the default configuration. Use this to see all available parameters and their default values.\n\n**Returns**: `Readonly<GlobalConfig>` - Frozen reference to defaults\n\n**Example**:\n\n```typescript\nimport { getDefaultConfig } from 'backtest-kit';\n\nconst defaults = getDefaultConfig();\nconsole.log('Default slippage:', defaults.CC_PERCENT_SLIPPAGE); // 0.1\nconsole.log('Default fee:', defaults.CC_PERCENT_FEE); // 0.1\n\n// Cannot modify (frozen object)\ndefaults.CC_PERCENT_SLIPPAGE = 999; // TypeError in strict mode\n```\n\n**Sources**: [src/function/setup.ts:72-88](), [src/config/params.ts:116-122]()\n\n---\n\n## Validation Rule Reference\n\nComplete list of validation rules enforced by `ConfigValidationService`:\n\n### Percentage Parameters\n\n| Parameter | Rule | Rationale |\n|-----------|------|-----------|\n| `CC_PERCENT_SLIPPAGE` | Must be ≥ 0 | Negative slippage is meaningless |\n| `CC_PERCENT_FEE` | Must be ≥ 0 | Negative fees are impossible |\n| `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT` | Must be > 0 | Zero TP distance is invalid |\n| `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT` | Must be ≥ (slippage×2 + fees×2) | **Critical**: Ensures profitable trades |\n| `CC_MIN_STOPLOSS_DISTANCE_PERCENT` | Must be > 0 | Zero SL distance causes instant stops |\n| `CC_MAX_STOPLOSS_DISTANCE_PERCENT` | Must be > 0 | Caps maximum risk per signal |\n| `CC_MIN_STOPLOSS_DISTANCE_PERCENT` | Must be < `CC_MAX_STOPLOSS_DISTANCE_PERCENT` | Range consistency |\n\n### Integer Parameters\n\n| Parameter | Rule | Rationale |\n|-----------|------|-----------|\n| `CC_SCHEDULE_AWAIT_MINUTES` | Must be positive integer | Prevents eternal scheduled signals |\n| `CC_MAX_SIGNAL_LIFETIME_MINUTES` | Must be positive integer | Prevents eternal open positions |\n| `CC_MAX_SIGNAL_GENERATION_SECONDS` | Must be positive integer | Prevents hanging signal generation |\n| `CC_AVG_PRICE_CANDLES_COUNT` | Must be positive integer | VWAP requires at least 1 candle |\n| `CC_GET_CANDLES_RETRY_COUNT` | Must be non-negative integer | 0 retries = no retry, ≥1 = retry N times |\n| `CC_GET_CANDLES_RETRY_DELAY_MS` | Must be positive integer | Retry delay must be positive |\n| `CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR` | Must be positive number | Anomaly detection requires threshold |\n| `CC_GET_CANDLES_MIN_CANDLES_FOR_MEDIAN` | Must be positive integer | Median calculation requires data points |\n\n### Boolean Parameters\n\n| Parameter | Rule | Rationale |\n|-----------|------|-----------|\n| `CC_REPORT_SHOW_SIGNAL_NOTE` | Must be boolean | Controls report formatting |\n\n**Sources**: [src/lib/services/validation/ConfigValidationService.ts:55-163]()\n\n---\n\n## Integration with Signal Validation\n\nConfiguration parameters are used throughout signal validation to enforce economic constraints and safety limits.\n\n```mermaid\ngraph TB\n    subgraph \"Signal Generation Flow\"\n        GetSignal[\"Strategy.getSignal()\"]\n        SignalDto[\"ISignalDto<br/>(User-defined signal)\"]\n    end\n    \n    subgraph \"Signal Validation Functions\"\n        V1[\"VALIDATE_SIGNAL_PRICE_POSITIVE_FN<br/>(Prices must be > 0)\"]\n        V2[\"VALIDATE_SIGNAL_PRICE_FINITE_FN<br/>(No NaN/Infinity)\"]\n        V3[\"VALIDATE_MIN_TAKEPROFIT_FN<br/>(TP distance ≥ CC_MIN_TAKEPROFIT_DISTANCE_PERCENT)\"]\n        V4[\"VALIDATE_MIN_STOPLOSS_FN<br/>(SL distance ≥ CC_MIN_STOPLOSS_DISTANCE_PERCENT)\"]\n        V5[\"VALIDATE_MAX_STOPLOSS_FN<br/>(SL distance ≤ CC_MAX_STOPLOSS_DISTANCE_PERCENT)\"]\n        V6[\"VALIDATE_MIN_ESTIMATED_TIME_FN<br/>(minuteEstimatedTime ≤ CC_MAX_SIGNAL_LIFETIME_MINUTES)\"]\n        V7[\"VALIDATE_SIGNAL_DIRECTION_FN<br/>(TP/SL correct for position direction)\"]\n    end\n    \n    subgraph \"Configuration Parameters Used\"\n        Config[\"GLOBAL_CONFIG\"]\n    end\n    \n    GetSignal --> SignalDto\n    SignalDto --> V1\n    V1 --> V2\n    V2 --> V3\n    V3 --> V4\n    V4 --> V5\n    V5 --> V6\n    V6 --> V7\n    \n    Config -->|\"CC_MIN_TAKEPROFIT_DISTANCE_PERCENT\"| V3\n    Config -->|\"CC_MIN_STOPLOSS_DISTANCE_PERCENT\"| V4\n    Config -->|\"CC_MAX_STOPLOSS_DISTANCE_PERCENT\"| V5\n    Config -->|\"CC_MAX_SIGNAL_LIFETIME_MINUTES\"| V6\n    \n    V7 --> Accept[\"Accept Signal\"]\n    V1 --> Reject[\"Reject Signal<br/>(Validation Error)\"]\n    V2 --> Reject\n    V3 --> Reject\n    V4 --> Reject\n    V5 --> Reject\n    V6 --> Reject\n```\n\n**Example Validation Errors**:\n\n```typescript\n// TP distance too close (below CC_MIN_TAKEPROFIT_DISTANCE_PERCENT)\n{\n  position: \"long\",\n  priceOpen: 50000,\n  priceTakeProfit: 50200,  // Only 0.4% profit\n  priceStopLoss: 49000,\n  minuteEstimatedTime: 60\n}\n// Error: \"TP distance (0.40%) is below minimum (0.50%)\"\n\n// SL distance too large (above CC_MAX_STOPLOSS_DISTANCE_PERCENT)\n{\n  position: \"long\",\n  priceOpen: 50000,\n  priceTakeProfit: 55000,\n  priceStopLoss: 30000,  // 40% risk - exceeds 20% max\n  minuteEstimatedTime: 60\n}\n// Error: \"SL distance (40.00%) exceeds maximum (20.00%)\"\n\n// Signal lifetime too long (above CC_MAX_SIGNAL_LIFETIME_MINUTES)\n{\n  position: \"long\",\n  priceOpen: 50000,\n  priceTakeProfit: 55000,\n  priceStopLoss: 45000,\n  minuteEstimatedTime: 50000  // >34 days (exceeds 1440 min default)\n}\n// Error: \"Signal lifetime (50000 min) exceeds maximum (1440 min)\"\n```\n\n**Sources**: [src/lib/services/validation/SignalValidationService.ts]() (inferred from test files), [test/e2e/sanitize.test.mjs:1-887]()\n\n---\n\n## Integration with VWAP Calculation\n\nThe `CC_AVG_PRICE_CANDLES_COUNT` parameter controls how many recent 1-minute candles are used for VWAP (Volume-Weighted Average Price) calculation.\n\n```mermaid\ngraph LR\n    subgraph \"ClientExchange.getAveragePrice\"\n        Fetch[\"Fetch Last N Candles<br/>(1m interval)\"]\n        N[\"N = CC_AVG_PRICE_CANDLES_COUNT<br/>(default: 5)\"]\n        Calculate[\"Calculate VWAP<br/>Σ(Typical Price × Volume) / Σ(Volume)\"]\n        TypicalPrice[\"Typical Price = (High + Low + Close) / 3\"]\n    end\n    \n    N --> Fetch\n    Fetch --> TypicalPrice\n    TypicalPrice --> Calculate\n    Calculate --> VWAP[\"Return VWAP<br/>(Current Market Price)\"]\n```\n\n**Formula**:\n\n```\nVWAP = Σ(Typical Price × Volume) / Σ(Volume)\n\nwhere Typical Price = (High + Low + Close) / 3\n```\n\n**Example with default `CC_AVG_PRICE_CANDLES_COUNT = 5`**:\n\n| Candle | High | Low | Close | Volume | Typical Price | Weighted |\n|--------|------|-----|-------|--------|---------------|----------|\n| 1 | 50100 | 49900 | 50000 | 100 | 50000 | 5000000 |\n| 2 | 50200 | 50000 | 50100 | 120 | 50100 | 6012000 |\n| 3 | 50300 | 50100 | 50200 | 110 | 50200 | 5522000 |\n| 4 | 50400 | 50200 | 50300 | 130 | 50300 | 6539000 |\n| 5 | 50500 | 50300 | 50400 | 140 | 50400 | 7056000 |\n| **Total** | | | | **600** | | **30129000** |\n\nVWAP = 30129000 / 600 = **50215**\n\n**Sources**: [src/client/ClientExchange.ts]() (inferred), [types.d.ts:404-412](), [src/config/params.ts:7-11]()\n\n---\n\n## Integration with Retry Logic\n\nData fetching parameters control retry behavior and anomaly detection when fetching candles from exchanges.\n\n```mermaid\ngraph TB\n    subgraph \"ClientExchange.getCandles with Retry\"\n        Start[\"getCandles(symbol, interval, limit)\"]\n        Attempt[\"Attempt Fetch\"]\n        Success[\"Return Candles\"]\n        Failure[\"Fetch Failed\"]\n        Retry[\"Retry Count < CC_GET_CANDLES_RETRY_COUNT?\"]\n        Delay[\"Sleep(CC_GET_CANDLES_RETRY_DELAY_MS)\"]\n        ThrowError[\"Throw Error\"]\n    end\n    \n    subgraph \"Anomaly Detection\"\n        CheckAnomaly[\"Check for Anomalous Prices\"]\n        CalculateReference[\"Calculate Reference Price<br/>(Median or Average)\"]\n        CheckThreshold[\"Any price < Reference / CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR?\"]\n        UseMedian[\"Use Median<br/>(if candles ≥ CC_GET_CANDLES_MIN_CANDLES_FOR_MEDIAN)\"]\n        UseAverage[\"Use Average<br/>(if candles < CC_GET_CANDLES_MIN_CANDLES_FOR_MEDIAN)\"]\n    end\n    \n    Start --> Attempt\n    Attempt --> Success\n    Attempt --> Failure\n    Failure --> Retry\n    Retry -->|\"Yes\"| Delay\n    Delay --> Attempt\n    Retry -->|\"No\"| ThrowError\n    \n    Success --> CheckAnomaly\n    CheckAnomaly --> CalculateReference\n    CalculateReference --> UseMedian\n    CalculateReference --> UseAverage\n    UseMedian --> CheckThreshold\n    UseAverage --> CheckThreshold\n    CheckThreshold -->|\"Anomaly Found\"| ThrowError\n    CheckThreshold -->|\"All OK\"| Return[\"Return Valid Candles\"]\n```\n\n**Default Retry Configuration**:\n- `CC_GET_CANDLES_RETRY_COUNT = 3`: Retry up to 3 times on failure\n- `CC_GET_CANDLES_RETRY_DELAY_MS = 5000`: Wait 5 seconds between retries\n\n**Anomaly Detection Example**:\n\n```typescript\n// Candles fetched: BTC at ~$50,000\nconst candles = [\n  { open: 50000, high: 50100, low: 49900, close: 50000, volume: 100 },\n  { open: 50100, high: 50200, low: 50000, close: 50100, volume: 110 },\n  { open: 0.01, high: 0.02, low: 0.01, close: 0.01, volume: 0 }, // ANOMALY!\n  { open: 50200, high: 50300, low: 50100, close: 50200, volume: 120 },\n  { open: 50300, high: 50400, low: 50200, close: 50300, volume: 130 },\n];\n\n// Reference price (median): ~50000\n// Anomaly threshold: 50000 / 1000 = 50\n// Candle 3 has price 0.01 < 50 → REJECTED\n// Error: \"VALIDATE_NO_INCOMPLETE_CANDLES_FN detected anomalously low price\"\n```\n\nThis protects against incomplete candles from Binance API that sometimes have near-zero prices.\n\n**Sources**: [src/config/params.ts:65-104](), [test/e2e/sanitize.test.mjs:666-784](), [types.d.ts:70-106]()\n\n---\n\n## Test Configuration\n\nFor test environments, the `_unsafe` parameter allows skipping validation:\n\n```typescript\nimport { setConfig } from 'backtest-kit';\n\n// Test setup: disable validations for old test compatibility\nsetConfig({\n  CC_MIN_TAKEPROFIT_DISTANCE_PERCENT: 0,  // Normally invalid\n  CC_MIN_STOPLOSS_DISTANCE_PERCENT: 0,\n  CC_MAX_STOPLOSS_DISTANCE_PERCENT: 100,\n  CC_MAX_SIGNAL_LIFETIME_MINUTES: 999999,\n}, true);  // _unsafe = true, skip validation\n```\n\n**Warning**: Never use `_unsafe = true` in production. It bypasses all safety checks including economic viability validation.\n\n**Sources**: [test/config/setup.mjs:89-102](), [src/function/setup.ts:39-43]()\n\n---\n\n## Configuration in Practice\n\n### Example: Conservative Trading Configuration\n\n```typescript\nimport { setConfig } from 'backtest-kit';\n\n// Conservative settings: higher costs, stricter limits\nsetConfig({\n  // Economic constraints\n  CC_PERCENT_SLIPPAGE: 0.15,              // 0.15% slippage\n  CC_PERCENT_FEE: 0.12,                   // 0.12% fees\n  CC_MIN_TAKEPROFIT_DISTANCE_PERCENT: 1.0, // 1% minimum profit (well above 0.54% costs)\n  CC_MIN_STOPLOSS_DISTANCE_PERCENT: 0.8,  // 0.8% minimum SL distance\n  CC_MAX_STOPLOSS_DISTANCE_PERCENT: 10.0, // 10% maximum risk per signal\n  \n  // Time constraints\n  CC_SCHEDULE_AWAIT_MINUTES: 60,          // 1 hour max for limit orders\n  CC_MAX_SIGNAL_LIFETIME_MINUTES: 720,    // 12 hours max per signal\n  \n  // Data quality\n  CC_AVG_PRICE_CANDLES_COUNT: 10,         // Use 10 candles for VWAP (more stable)\n  CC_GET_CANDLES_RETRY_COUNT: 5,          // 5 retries (more resilient)\n});\n```\n\n### Example: Aggressive Trading Configuration\n\n```typescript\nimport { setConfig } from 'backtest-kit';\n\n// Aggressive settings: lower costs, looser limits\nsetConfig({\n  // Economic constraints\n  CC_PERCENT_SLIPPAGE: 0.05,              // 0.05% slippage\n  CC_PERCENT_FEE: 0.05,                   // 0.05% fees\n  CC_MIN_TAKEPROFIT_DISTANCE_PERCENT: 0.25, // 0.25% minimum profit (just above 0.2% costs)\n  CC_MIN_STOPLOSS_DISTANCE_PERCENT: 0.3,  // 0.3% minimum SL distance\n  CC_MAX_STOPLOSS_DISTANCE_PERCENT: 30.0, // 30% maximum risk per signal\n  \n  // Time constraints\n  CC_SCHEDULE_AWAIT_MINUTES: 240,         // 4 hours max for limit orders\n  CC_MAX_SIGNAL_LIFETIME_MINUTES: 2880,   // 48 hours max per signal\n  \n  // Data quality\n  CC_AVG_PRICE_CANDLES_COUNT: 3,          // Use 3 candles for VWAP (faster response)\n  CC_GET_CANDLES_RETRY_COUNT: 2,          // 2 retries (fail faster)\n});\n```\n\n**Sources**: [test/e2e/config.test.mjs:1-224](), [test/spec/config.test.mjs:1-335]()\n\n---\n\n## Summary\n\nThe Configuration System provides:\n\n1. **Centralized Management**: Single `GLOBAL_CONFIG` object for all framework parameters\n2. **Economic Viability**: Automatic validation ensures profitable trading configurations\n3. **Type Safety**: TypeScript types prevent invalid parameter values\n4. **Rollback Protection**: Failed configuration updates do not corrupt the system\n5. **Runtime Updates**: Configuration can be changed at any time with `setConfig()`\n6. **Default Values**: Sensible defaults for production use (0.1% slippage, 0.1% fees, 0.5% min TP)\n\n**Key Design Principles**:\n- **Fail-Fast**: Validation errors prevent system execution with invalid configuration\n- **Rollback Safety**: On validation failure, previous configuration is restored\n- **Economic Correctness**: Mathematical validation ensures profitable trades\n- **Test Flexibility**: `_unsafe` flag allows test environments to bypass validation\n\n**Sources**: [src/config/params.ts:1-122](), [src/function/setup.ts:1-89](), [src/lib/services/validation/ConfigValidationService.ts:1-166]()"
                    },
                    {
                        "page_plan": {
                            "id": "7.1",
                            "title": "Global Configuration Parameters"
                        },
                        "content": "# Global Configuration Parameters\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/config/params.ts](src/config/params.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/function/setup.ts](src/function/setup.ts)\n- [src/helpers/toProfitLossDto.ts](src/helpers/toProfitLossDto.ts)\n- [src/index.ts](src/index.ts)\n- [src/lib/services/validation/ConfigValidationService.ts](src/lib/services/validation/ConfigValidationService.ts)\n- [test/config/setup.mjs](test/config/setup.mjs)\n- [test/e2e/config.test.mjs](test/e2e/config.test.mjs)\n- [test/e2e/sanitize.test.mjs](test/e2e/sanitize.test.mjs)\n- [test/spec/config.test.mjs](test/spec/config.test.mjs)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\n## Overview and Scope\n\nThis page documents all global configuration parameters in `GLOBAL_CONFIG`, which control system-wide behavior for backtesting, live trading, data fetching, and economic calculations. These parameters affect signal validation, cost modeling, timeout enforcement, and report generation across all execution modes.\n\nFor details on how these parameters are validated for economic viability, see [Economic Viability and Validation](#7.2). For the configuration API (`setConfig`, `getConfig`), see [Configuration API](#7.3).\n\n**Sources**: [src/config/params.ts:1-122](), [types.d.ts:5-239]()\n\n---\n\n## Parameter Categories Overview\n\nThe 14 global configuration parameters are organized into five functional categories:\n\n```mermaid\ngraph TB\n    GLOBAL[\"GLOBAL_CONFIG Object<br/>(src/config/params.ts)\"]\n    \n    subgraph \"Economic Parameters (4)\"\n        SLIP[\"CC_PERCENT_SLIPPAGE<br/>Default: 0.1%\"]\n        FEE[\"CC_PERCENT_FEE<br/>Default: 0.1%\"]\n        TP[\"CC_MIN_TAKEPROFIT_DISTANCE_PERCENT<br/>Default: 0.5%\"]\n        SL_MIN[\"CC_MIN_STOPLOSS_DISTANCE_PERCENT<br/>Default: 0.5%\"]\n        SL_MAX[\"CC_MAX_STOPLOSS_DISTANCE_PERCENT<br/>Default: 20%\"]\n    end\n    \n    subgraph \"Signal Lifecycle (3)\"\n        SCHED[\"CC_SCHEDULE_AWAIT_MINUTES<br/>Default: 120\"]\n        LIFE[\"CC_MAX_SIGNAL_LIFETIME_MINUTES<br/>Default: 1440\"]\n        GEN[\"CC_MAX_SIGNAL_GENERATION_SECONDS<br/>Default: 180\"]\n    end\n    \n    subgraph \"Data Fetching (4)\"\n        AVG[\"CC_AVG_PRICE_CANDLES_COUNT<br/>Default: 5\"]\n        RETRY[\"CC_GET_CANDLES_RETRY_COUNT<br/>Default: 3\"]\n        DELAY[\"CC_GET_CANDLES_RETRY_DELAY_MS<br/>Default: 5000\"]\n        ANOM[\"CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR<br/>Default: 1000\"]\n        MED[\"CC_GET_CANDLES_MIN_CANDLES_FOR_MEDIAN<br/>Default: 5\"]\n    end\n    \n    subgraph \"Reporting (1)\"\n        NOTE[\"CC_REPORT_SHOW_SIGNAL_NOTE<br/>Default: false\"]\n    end\n    \n    GLOBAL --> SLIP\n    GLOBAL --> FEE\n    GLOBAL --> TP\n    GLOBAL --> SL_MIN\n    GLOBAL --> SL_MAX\n    GLOBAL --> SCHED\n    GLOBAL --> LIFE\n    GLOBAL --> GEN\n    GLOBAL --> AVG\n    GLOBAL --> RETRY\n    GLOBAL --> DELAY\n    GLOBAL --> ANOM\n    GLOBAL --> MED\n    GLOBAL --> NOTE\n```\n\n**Sources**: [src/config/params.ts:1-122](), [types.d.ts:5-239]()\n\n---\n\n## Economic Parameters\n\nEconomic parameters control transaction cost modeling and profitability constraints. These are the most critical parameters as they determine whether strategies can be profitable.\n\n### Cost Modeling: Slippage and Fees\n\n#### CC_PERCENT_SLIPPAGE\n\n**Default**: `0.1` (0.1% per transaction)  \n**Type**: `number` (non-negative)  \n**Purpose**: Simulates market impact and order book depth by worsening execution prices.\n\nApplied twice per round-trip trade:\n- **Entry**: Long positions buy at higher price (+0.1%), short positions sell at lower price (-0.1%)\n- **Exit**: Long positions sell at lower price (-0.1%), short positions buy at higher price (+0.1%)\n\nTotal slippage effect: **0.2%** (2 × 0.1%)\n\n**Sources**: [types.d.ts:17-22](), [src/config/params.ts:18](), [src/helpers/toProfitLossDto.ts:39-50]()\n\n#### CC_PERCENT_FEE\n\n**Default**: `0.1` (0.1% per transaction)  \n**Type**: `number` (non-negative)  \n**Purpose**: Transaction fee charged by exchange or broker.\n\nApplied twice per round-trip trade:\n- Entry transaction: 0.1% fee\n- Exit transaction: 0.1% fee\n\nTotal fee cost: **0.2%** (2 × 0.1%)\n\n**Sources**: [types.d.ts:24-28](), [src/config/params.ts:24](), [src/helpers/toProfitLossDto.ts:53]()\n\n### Cost Breakdown Diagram\n\n```mermaid\ngraph LR\n    subgraph \"Round-Trip Trade Cost Structure\"\n        ENTRY[\"Entry Transaction\"]\n        EXIT[\"Exit Transaction\"]\n        \n        ENTRY_SLIP[\"Slippage: 0.1%\"]\n        ENTRY_FEE[\"Fee: 0.1%\"]\n        EXIT_SLIP[\"Slippage: 0.1%\"]\n        EXIT_FEE[\"Fee: 0.1%\"]\n        \n        TOTAL_SLIP[\"Total Slippage: 0.2%\"]\n        TOTAL_FEE[\"Total Fees: 0.2%\"]\n        TOTAL_COST[\"Total Cost: 0.4%\"]\n        \n        ENTRY --> ENTRY_SLIP\n        ENTRY --> ENTRY_FEE\n        EXIT --> EXIT_SLIP\n        EXIT --> EXIT_FEE\n        \n        ENTRY_SLIP --> TOTAL_SLIP\n        EXIT_SLIP --> TOTAL_SLIP\n        ENTRY_FEE --> TOTAL_FEE\n        EXIT_FEE --> TOTAL_FEE\n        \n        TOTAL_SLIP --> TOTAL_COST\n        TOTAL_FEE --> TOTAL_COST\n    end\n```\n\n**Sources**: [src/helpers/toProfitLossDto.ts:1-82](), [src/lib/services/validation/ConfigValidationService.ts:69-72]()\n\n### Profitability Constraints\n\n#### CC_MIN_TAKEPROFIT_DISTANCE_PERCENT\n\n**Default**: `0.5` (0.5%)  \n**Type**: `number` (positive)  \n**Purpose**: Minimum distance from `priceOpen` to `priceTakeProfit` to ensure profitable trades.\n\n**Critical Constraint**: Must be **greater than** total trading costs (slippage + fees) to guarantee profit when TP is hit.\n\n**Calculation**:\n```\nTotal Costs = (slippage × 2) + (fees × 2)\n            = (0.1% × 2) + (0.1% × 2)\n            = 0.2% + 0.2%\n            = 0.4%\n\nMinimum Required TP Distance = 0.4% + buffer\nDefault: 0.5% (covers 0.4% costs + 0.1% profit margin)\n```\n\n**Validation**: If `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT < (CC_PERCENT_SLIPPAGE × 2 + CC_PERCENT_FEE × 2)`, all TP signals will be unprofitable (see [Economic Viability and Validation](#7.2)).\n\n**Sources**: [types.d.ts:30-41](), [src/config/params.ts:37](), [src/lib/services/validation/ConfigValidationService.ts:69-88]()\n\n#### CC_MIN_STOPLOSS_DISTANCE_PERCENT\n\n**Default**: `0.5` (0.5%)  \n**Type**: `number` (positive)  \n**Purpose**: Minimum distance from `priceOpen` to `priceStopLoss` to prevent signals from being immediately stopped out by normal price volatility.\n\nPrevents \"instant stop loss\" scenarios where minor price fluctuations trigger SL before the strategy has a chance to develop.\n\n**Sources**: [types.d.ts:43-47](), [src/config/params.ts:43](), [src/lib/services/validation/ConfigValidationService.ts:91-95]()\n\n#### CC_MAX_STOPLOSS_DISTANCE_PERCENT\n\n**Default**: `20` (20%)  \n**Type**: `number` (positive)  \n**Purpose**: Maximum distance from `priceOpen` to `priceStopLoss` to prevent catastrophic losses.\n\nCaps risk per signal to 20% of position value. Prevents single signals from causing devastating portfolio damage.\n\n**Constraint**: Must be **greater than** `CC_MIN_STOPLOSS_DISTANCE_PERCENT`.\n\n**Sources**: [types.d.ts:49-53](), [src/config/params.ts:49](), [src/lib/services/validation/ConfigValidationService.ts:98-114]()\n\n---\n\n## Signal Lifecycle Parameters\n\nSignal lifecycle parameters control timeouts and maximum durations for various signal states.\n\n### Parameter Summary Table\n\n| Parameter | Default | Type | Purpose |\n|-----------|---------|------|---------|\n| `CC_SCHEDULE_AWAIT_MINUTES` | 120 | `number` (positive integer) | Scheduled signal activation timeout |\n| `CC_MAX_SIGNAL_LIFETIME_MINUTES` | 1440 | `number` (positive integer) | Maximum signal duration (opened state) |\n| `CC_MAX_SIGNAL_GENERATION_SECONDS` | 180 | `number` (positive integer) | `getSignal` execution timeout |\n\n**Sources**: [src/config/params.ts:6-64](), [types.d.ts:7-68]()\n\n### CC_SCHEDULE_AWAIT_MINUTES\n\n**Default**: `120` (2 hours)  \n**Type**: `number` (positive integer, minutes)  \n**Purpose**: Maximum time to wait for a scheduled signal to activate (price to reach `priceOpen`).\n\nIf a scheduled signal does not activate within this timeout, it is automatically cancelled to prevent indefinite blocking of risk limits.\n\n**Related Signals**: Scheduled signals (those with explicit `priceOpen` set in `getSignal` return value).\n\n**Sources**: [types.d.ts:7-10](), [src/config/params.ts:6](), [test/e2e/config.test.mjs:18-82]()\n\n### CC_MAX_SIGNAL_LIFETIME_MINUTES\n\n**Default**: `1440` (1 day = 24 hours)  \n**Type**: `number` (positive integer, minutes)  \n**Purpose**: Maximum duration a signal can remain in the \"opened\" state before being force-closed with reason `\"time_expired\"`.\n\nPrevents \"eternal signals\" that block risk limits for weeks/months without reaching TP or SL.\n\n**Sources**: [types.d.ts:55-59](), [src/config/params.ts:55](), [test/e2e/sanitize.test.mjs:241-339]()\n\n### CC_MAX_SIGNAL_GENERATION_SECONDS\n\n**Default**: `180` (3 minutes)  \n**Type**: `number` (positive integer, seconds)  \n**Purpose**: Maximum execution time allowed for the `getSignal` callback in strategy schemas.\n\nPrevents long-running or stuck signal generation routines from blocking execution or consuming resources indefinitely. If generation exceeds this threshold, the attempt is aborted and logged.\n\n**Sources**: [types.d.ts:61-68](), [src/config/params.ts:64]()\n\n### Lifecycle State Diagram with Timeouts\n\n```mermaid\nstateDiagram-v2\n    [*] --> Idle\n    \n    Idle --> Scheduled: \"getSignal returns ISignalDto<br/>with priceOpen set\"\n    Idle --> Opened: \"getSignal returns ISignalDto<br/>without priceOpen\"\n    \n    Scheduled --> Opened: \"Price reaches priceOpen\"\n    Scheduled --> Cancelled: \"CC_SCHEDULE_AWAIT_MINUTES<br/>timeout (default: 120 min)\"\n    \n    Opened --> Closed: \"Price hits TP/SL or<br/>CC_MAX_SIGNAL_LIFETIME_MINUTES<br/>timeout (default: 1440 min)\"\n    \n    Cancelled --> [*]\n    Closed --> [*]\n    \n    note right of Idle\n        getSignal callback has\n        CC_MAX_SIGNAL_GENERATION_SECONDS\n        timeout (default: 180 sec)\n    end note\n```\n\n**Sources**: [types.d.ts:7-68](), [src/config/params.ts:6-64]()\n\n---\n\n## Data Fetching and Reliability Parameters\n\nThese parameters control VWAP calculation, retry logic for failed `getCandles` calls, and anomaly detection for incomplete candle data.\n\n### VWAP Calculation\n\n#### CC_AVG_PRICE_CANDLES_COUNT\n\n**Default**: `5` (5 candles)  \n**Type**: `number` (positive integer)  \n**Purpose**: Number of 1-minute candles to use for Volume-Weighted Average Price (VWAP) calculation.\n\nDefault of 5 means VWAP is calculated from the last 5 minutes of 1m candle data.\n\n**Formula**:\n```\nVWAP = Σ(Typical Price × Volume) / Σ(Volume)\nwhere Typical Price = (High + Low + Close) / 3\n```\n\n**Used By**: `ClientExchange.getAveragePrice()` method, which is called by strategies to get current market price.\n\n**Sources**: [types.d.ts:12-15](), [src/config/params.ts:11](), [test/e2e/config.test.mjs:84-154]()\n\n### Retry Logic\n\n#### CC_GET_CANDLES_RETRY_COUNT\n\n**Default**: `3` (3 retries)  \n**Type**: `number` (non-negative integer)  \n**Purpose**: Number of retry attempts for `getCandles` function when API calls fail.\n\nTotal attempts = 1 initial + 3 retries = 4 attempts maximum.\n\n**Sources**: [types.d.ts:70-73](), [src/config/params.ts:69]()\n\n#### CC_GET_CANDLES_RETRY_DELAY_MS\n\n**Default**: `5000` (5 seconds)  \n**Type**: `number` (non-negative integer, milliseconds)  \n**Purpose**: Delay between retry attempts for `getCandles` function.\n\nProvides backoff time to avoid overwhelming failing APIs or to wait for transient network issues to resolve.\n\n**Sources**: [types.d.ts:75-78](), [src/config/params.ts:74]()\n\n### Anomaly Detection\n\n#### CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR\n\n**Default**: `1000` (factor of 1000)  \n**Type**: `number` (positive integer)  \n**Purpose**: Maximum allowed deviation factor for detecting incomplete/anomalous candles from exchange APIs.\n\n**Detection Logic**: Price is rejected if it's more than `factor` times lower than reference price (median/average).\n\n**Reasoning**:\n- Incomplete candles from Binance API typically have prices near $0.01-$1\n- Normal BTC price: $20,000-$100,000\n- Factor 1000: Catches prices below $20-$100 when median is $20,000-$100,000\n- Factor 100 would be too permissive ($200 allowed when median is $20,000)\n- Factor 10000 might be too strict for low-cap altcoins\n\n**Example**: BTC at $50,000 median → threshold $50 → catches $0.01-$1 anomalies.\n\n**Sources**: [types.d.ts:80-92](), [src/config/params.ts:89](), [test/e2e/sanitize.test.mjs:666-784]()\n\n#### CC_GET_CANDLES_MIN_CANDLES_FOR_MEDIAN\n\n**Default**: `5` (5 candles)  \n**Type**: `number` (positive integer)  \n**Purpose**: Minimum number of candles required for reliable median calculation in anomaly detection.\n\n**Statistical Reasoning**:\n- Each candle provides 4 price points (OHLC)\n- 5 candles = 20 price points, sufficient for robust median\n- Below 5 candles, single anomaly can heavily skew median\n- Rule of thumb: minimum 7-10 data points for median stability\n- Average is more stable than median for small datasets (n < 20)\n\n**Behavior**: If fewer than this threshold, use simple average instead of median for reference price calculation.\n\n**Sources**: [types.d.ts:94-106](), [src/config/params.ts:104]()\n\n### Data Fetching Flow Diagram\n\n```mermaid\ngraph TB\n    START[\"ClientExchange.getCandles call\"]\n    \n    FETCH[\"Execute IExchangeSchema.getCandles\"]\n    RETRY_CHECK{\"Retry count < CC_GET_CANDLES_RETRY_COUNT\"}\n    DELAY[\"Wait CC_GET_CANDLES_RETRY_DELAY_MS\"]\n    ERROR[\"Throw Error\"]\n    \n    VALIDATE[\"Validate candle data\"]\n    COUNT_CHECK{\"candles.length >= CC_GET_CANDLES_MIN_CANDLES_FOR_MEDIAN\"}\n    USE_MEDIAN[\"Calculate reference price using MEDIAN\"]\n    USE_AVG[\"Calculate reference price using AVERAGE\"]\n    \n    ANOM_CHECK{\"Any price < reference / CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR\"}\n    REJECT[\"Reject anomalous candles\"]\n    ACCEPT[\"Accept valid candles\"]\n    \n    VWAP[\"Calculate VWAP from CC_AVG_PRICE_CANDLES_COUNT candles\"]\n    RETURN[\"Return candle data / VWAP\"]\n    \n    START --> FETCH\n    FETCH -->|Success| VALIDATE\n    FETCH -->|Failure| RETRY_CHECK\n    RETRY_CHECK -->|Yes| DELAY\n    DELAY --> FETCH\n    RETRY_CHECK -->|No| ERROR\n    \n    VALIDATE --> COUNT_CHECK\n    COUNT_CHECK -->|Yes| USE_MEDIAN\n    COUNT_CHECK -->|No| USE_AVG\n    USE_MEDIAN --> ANOM_CHECK\n    USE_AVG --> ANOM_CHECK\n    \n    ANOM_CHECK -->|Yes| REJECT\n    ANOM_CHECK -->|No| ACCEPT\n    ACCEPT --> VWAP\n    VWAP --> RETURN\n```\n\n**Sources**: [types.d.ts:70-106](), [src/config/params.ts:69-104]()\n\n---\n\n## Reporting Parameters\n\n### CC_REPORT_SHOW_SIGNAL_NOTE\n\n**Default**: `false`  \n**Type**: `boolean`  \n**Purpose**: Controls visibility of the \"Note\" column in markdown report tables.\n\nWhen `true`, the \"Note\" column (populated from `ISignalDto.note` field) is displayed in all markdown reports:\n- `BacktestMarkdownService` reports\n- `LiveMarkdownService` reports\n- `ScheduleMarkdownService` reports\n- `RiskMarkdownService` reports\n- Other markdown report tables\n\nWhen `false` (default), notes are hidden to reduce table width and improve readability.\n\n**Sources**: [types.d.ts:108-115](), [src/config/params.ts:113]()\n\n---\n\n## Complete Parameter Reference Table\n\n| Parameter | Default | Type | Constraints | Purpose |\n|-----------|---------|------|-------------|---------|\n| `CC_SCHEDULE_AWAIT_MINUTES` | `120` | `number` | Positive integer | Scheduled signal activation timeout (minutes) |\n| `CC_AVG_PRICE_CANDLES_COUNT` | `5` | `number` | Positive integer | Number of candles for VWAP calculation |\n| `CC_PERCENT_SLIPPAGE` | `0.1` | `number` | Non-negative | Slippage per transaction (%) |\n| `CC_PERCENT_FEE` | `0.1` | `number` | Non-negative | Fee per transaction (%) |\n| `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT` | `0.5` | `number` | Positive, must cover costs | Minimum TP distance from priceOpen (%) |\n| `CC_MIN_STOPLOSS_DISTANCE_PERCENT` | `0.5` | `number` | Positive, < MAX_SL | Minimum SL distance from priceOpen (%) |\n| `CC_MAX_STOPLOSS_DISTANCE_PERCENT` | `20` | `number` | Positive, > MIN_SL | Maximum SL distance from priceOpen (%) |\n| `CC_MAX_SIGNAL_LIFETIME_MINUTES` | `1440` | `number` | Positive integer | Maximum signal duration (minutes) |\n| `CC_MAX_SIGNAL_GENERATION_SECONDS` | `180` | `number` | Positive integer | getSignal timeout (seconds) |\n| `CC_GET_CANDLES_RETRY_COUNT` | `3` | `number` | Non-negative integer | Number of retries for getCandles |\n| `CC_GET_CANDLES_RETRY_DELAY_MS` | `5000` | `number` | Non-negative integer | Delay between retries (milliseconds) |\n| `CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR` | `1000` | `number` | Positive integer | Anomaly detection factor |\n| `CC_GET_CANDLES_MIN_CANDLES_FOR_MEDIAN` | `5` | `number` | Positive integer | Min candles for median calculation |\n| `CC_REPORT_SHOW_SIGNAL_NOTE` | `false` | `boolean` | N/A | Show note column in reports |\n\n**Sources**: [src/config/params.ts:1-122](), [types.d.ts:5-239]()\n\n---\n\n## Parameter Relationships and Dependencies\n\nSome parameters have mathematical relationships and dependencies that are enforced by validation:\n\n```mermaid\ngraph TB\n    subgraph \"Economic Viability Constraint\"\n        SLIP[\"CC_PERCENT_SLIPPAGE<br/>Default: 0.1%\"]\n        FEE[\"CC_PERCENT_FEE<br/>Default: 0.1%\"]\n        TP[\"CC_MIN_TAKEPROFIT_DISTANCE_PERCENT<br/>Default: 0.5%\"]\n        \n        COST[\"Total Round-Trip Cost<br/>= (SLIP × 2) + (FEE × 2)<br/>= 0.2% + 0.2% = 0.4%\"]\n        \n        CONSTRAINT[\"CONSTRAINT:<br/>TP must be > Total Cost<br/>(0.5% > 0.4% ✓)\"]\n        \n        SLIP --> COST\n        FEE --> COST\n        COST --> CONSTRAINT\n        TP --> CONSTRAINT\n    end\n    \n    subgraph \"StopLoss Range Constraint\"\n        SL_MIN[\"CC_MIN_STOPLOSS_DISTANCE_PERCENT<br/>Default: 0.5%\"]\n        SL_MAX[\"CC_MAX_STOPLOSS_DISTANCE_PERCENT<br/>Default: 20%\"]\n        \n        SL_CONSTRAINT[\"CONSTRAINT:<br/>MIN_SL < MAX_SL<br/>(0.5% < 20% ✓)\"]\n        \n        SL_MIN --> SL_CONSTRAINT\n        SL_MAX --> SL_CONSTRAINT\n    end\n    \n    subgraph \"Anomaly Detection Logic\"\n        MEDIAN_MIN[\"CC_GET_CANDLES_MIN_CANDLES_FOR_MEDIAN<br/>Default: 5\"]\n        ANOM_FACTOR[\"CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR<br/>Default: 1000\"]\n        \n        CANDLE_COUNT{\"Candle count >= MEDIAN_MIN?\"}\n        USE_MEDIAN[\"Use MEDIAN for reference\"]\n        USE_AVG[\"Use AVERAGE for reference\"]\n        \n        DETECT[\"Detect anomaly:<br/>price < reference / ANOM_FACTOR\"]\n        \n        MEDIAN_MIN --> CANDLE_COUNT\n        CANDLE_COUNT -->|Yes| USE_MEDIAN\n        CANDLE_COUNT -->|No| USE_AVG\n        USE_MEDIAN --> DETECT\n        USE_AVG --> DETECT\n        ANOM_FACTOR --> DETECT\n    end\n```\n\n**Sources**: [src/lib/services/validation/ConfigValidationService.ts:55-175](), [src/config/params.ts:1-122]()\n\n---\n\n## Type Definition and Access\n\nThe `GlobalConfig` type is defined as `typeof GLOBAL_CONFIG`, providing type safety for configuration access:\n\n```typescript\n// Type definition\nexport type GlobalConfig = typeof GLOBAL_CONFIG;\n\n// Access via global object\nimport { GLOBAL_CONFIG } from \"./config/params\";\nconsole.log(GLOBAL_CONFIG.CC_SCHEDULE_AWAIT_MINUTES); // 120\n\n// Access via API functions (see page 7.3)\nimport { getConfig } from \"./function/setup\";\nconst config = getConfig(); // Returns shallow copy\nconsole.log(config.CC_SCHEDULE_AWAIT_MINUTES); // 120\n```\n\n**Type Location**: [src/config/params.ts:121](), [types.d.ts:119]()\n\n**Default Configuration**: `DEFAULT_CONFIG` is a frozen copy of initial `GLOBAL_CONFIG` values, providing reference to original defaults even after configuration changes.\n\n**Sources**: [src/config/params.ts:116-122](), [types.d.ts:119-239](), [src/function/setup.ts:1-89]()\n\n---\n\n## Validation Overview\n\nAll configuration parameters are validated when `setConfig()` is called (unless `_unsafe` flag is set). Validation ensures:\n\n1. **Type constraints**: Integer parameters are integers, positive values are positive\n2. **Economic viability**: `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT` covers all costs\n3. **Range constraints**: MIN < MAX relationships (e.g., StopLoss distances)\n4. **Sanity checks**: Timeouts, retry counts, and thresholds are reasonable\n\nIf validation fails, `setConfig()` reverts to previous configuration and throws an error with detailed breakdown of all validation failures.\n\n**Validator Class**: `ConfigValidationService` at [src/lib/services/validation/ConfigValidationService.ts:1-179]()\n\nFor detailed validation rules and economic viability calculations, see [Economic Viability and Validation](#7.2).\n\nFor configuration API usage (setting/getting config), see [Configuration API](#7.3).\n\n**Sources**: [src/lib/services/validation/ConfigValidationService.ts:1-179](), [src/function/setup.ts:39-52](), [test/spec/config.test.mjs:1-438]()"
                    },
                    {
                        "page_plan": {
                            "id": "7.2",
                            "title": "Economic Viability and Validation"
                        },
                        "content": "# Economic Viability and Validation\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [src/config/params.ts](src/config/params.ts)\n- [src/function/setup.ts](src/function/setup.ts)\n- [src/helpers/toProfitLossDto.ts](src/helpers/toProfitLossDto.ts)\n- [src/interfaces/Heatmap.interface.ts](src/interfaces/Heatmap.interface.ts)\n- [src/lib/services/validation/ConfigValidationService.ts](src/lib/services/validation/ConfigValidationService.ts)\n- [test/config/setup.mjs](test/config/setup.mjs)\n- [test/e2e/config.test.mjs](test/e2e/config.test.mjs)\n- [test/e2e/defend.test.mjs](test/e2e/defend.test.mjs)\n- [test/e2e/risk.test.mjs](test/e2e/risk.test.mjs)\n- [test/e2e/sanitize.test.mjs](test/e2e/sanitize.test.mjs)\n- [test/index.mjs](test/index.mjs)\n- [test/mock/getMockCandles.mjs](test/mock/getMockCandles.mjs)\n- [test/spec/config.test.mjs](test/spec/config.test.mjs)\n- [test/spec/heat.test.mjs](test/spec/heat.test.mjs)\n- [test/spec/list.test.mjs](test/spec/list.test.mjs)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis document explains the framework's configuration validation system that ensures trading strategies are economically viable before execution. It covers the cost model (slippage and fees), minimum profit requirements, the `ConfigValidationService` implementation, and validation rules that prevent unprofitable or dangerous configurations.\n\nFor signal-level risk validation, see [Risk Management](#4.3). For a complete catalog of configuration parameters, see [Global Configuration Parameters](#7.1). For the configuration API, see [Configuration API](#7.3).\n\n---\n\n## Economic Viability Problem\n\nTrading strategies must account for execution costs. Without validation, users may configure strategies that appear profitable in theory but lose money after costs.\n\n### Cost Components\n\n**Sources:** [src/config/params.ts:1-122](), [src/helpers/toProfitLossDto.ts:1-82]()\n\n| Cost Component | Default Value | Application | Impact |\n|----------------|---------------|-------------|--------|\n| `CC_PERCENT_SLIPPAGE` | 0.1% | Applied twice (entry + exit) | 0.2% total |\n| `CC_PERCENT_FEE` | 0.1% | Applied twice (entry + exit) | 0.2% total |\n| **Total Cost** | - | - | **0.4%** |\n\nEvery trade incurs these costs regardless of direction (long/short) or outcome (profit/loss). A signal with `priceTakeProfit` only 0.3% away from `priceOpen` will result in a net loss even when the take-profit is hit.\n\n### Example: Unprofitable Configuration\n\n```typescript\n// DANGEROUS: This signal loses money even when TP is hit\n{\n  position: \"long\",\n  priceOpen: 42000,\n  priceTakeProfit: 42100,  // Only 0.238% profit\n  priceStopLoss: 41000,\n  minuteEstimatedTime: 60\n}\n\n// After costs:\n// - Slippage effect: 0.2% (42000 * 1.001 entry, 42100 * 0.999 exit)\n// - Fees: 0.2% (0.1% * 2 transactions)\n// - Net PNL: -0.176% (LOSS despite hitting TP!)\n```\n\n**Sources:** [test/e2e/sanitize.test.mjs:18-122]()\n\n---\n\n## Cost Calculation Model\n\n```mermaid\ngraph TB\n    subgraph \"Entry Transaction\"\n        E1[\"priceOpen<br/>(Market Price)\"]\n        E2[\"Apply Slippage<br/>LONG: × (1 + 0.1%)<br/>SHORT: × (1 - 0.1%)\"]\n        E3[\"Apply Entry Fee<br/>× (1 + 0.1%)\"]\n        E4[\"effectivePriceOpen\"]\n        \n        E1 --> E2\n        E2 --> E3\n        E3 --> E4\n    end\n    \n    subgraph \"Exit Transaction\"\n        X1[\"priceClose<br/>(Exit Price)\"]\n        X2[\"Apply Slippage<br/>LONG: × (1 - 0.1%)<br/>SHORT: × (1 + 0.1%)\"]\n        X3[\"Apply Exit Fee<br/>× (1 - 0.1%)\"]\n        X4[\"effectivePriceClose\"]\n        \n        X1 --> X2\n        X2 --> X3\n        X3 --> X4\n    end\n    \n    subgraph \"PNL Calculation - toProfitLossDto\"\n        P1[\"Raw PNL\"]\n        P2[\"LONG:<br/>((close - open) / open) × 100\"]\n        P3[\"SHORT:<br/>((open - close) / open) × 100\"]\n        P4[\"Final PNL<br/>(after all costs)\"]\n        \n        E4 --> P1\n        X4 --> P1\n        P1 --> P2\n        P1 --> P3\n        P2 --> P4\n        P3 --> P4\n    end\n```\n\n**Sources:** [src/helpers/toProfitLossDto.ts:33-79](), [src/config/params.ts:12-24]()\n\n### Implementation: toProfitLossDto\n\n[src/helpers/toProfitLossDto.ts:33-79]()\n\n```typescript\n// Simplified excerpt showing cost application\nif (signal.position === \"long\") {\n  // LONG: buy higher, sell lower (worse execution)\n  priceOpenWithSlippage = priceOpen * (1 + GLOBAL_CONFIG.CC_PERCENT_SLIPPAGE / 100);\n  priceCloseWithSlippage = priceClose * (1 - GLOBAL_CONFIG.CC_PERCENT_SLIPPAGE / 100);\n} else {\n  // SHORT: sell lower, buy higher (worse execution)\n  priceOpenWithSlippage = priceOpen * (1 - GLOBAL_CONFIG.CC_PERCENT_SLIPPAGE / 100);\n  priceCloseWithSlippage = priceClose * (1 + GLOBAL_CONFIG.CC_PERCENT_SLIPPAGE / 100);\n}\n\nconst totalFee = GLOBAL_CONFIG.CC_PERCENT_FEE * 2;  // Entry + exit\npnlPercentage -= totalFee;  // Subtract fees from calculated PNL\n```\n\n---\n\n## ConfigValidationService\n\nThe `ConfigValidationService` validates `GLOBAL_CONFIG` on every `setConfig()` call to prevent unprofitable or dangerous configurations.\n\n### Architecture\n\n```mermaid\ngraph TB\n    subgraph \"Public API\"\n        A[\"setConfig(config, _unsafe)\"]\n    end\n    \n    subgraph \"setup.ts\"\n        B[\"Object.assign(GLOBAL_CONFIG, config)\"]\n        C[\"configValidationService.validate()\"]\n        D[\"Rollback on error\"]\n    end\n    \n    subgraph \"ConfigValidationService\"\n        E[\"validate()\"]\n        F[\"Collect all errors[]\"]\n        \n        subgraph \"Validation Rules\"\n            V1[\"Percentage Validation<br/>Non-negative, finite\"]\n            V2[\"Economic Viability Check<br/>TP >= slippage + fees\"]\n            V3[\"Range Constraints<br/>MIN_SL < MAX_SL\"]\n            V4[\"Integer Validation<br/>Timeouts, counts\"]\n        end\n        \n        G[\"Throw aggregated errors\"]\n    end\n    \n    A --> B\n    B --> C\n    C --> E\n    E --> F\n    F --> V1\n    F --> V2\n    F --> V3\n    F --> V4\n    V1 --> G\n    V2 --> G\n    V3 --> G\n    V4 --> G\n    G -.->|\"Error\"| D\n```\n\n**Sources:** [src/function/setup.ts:38-52](), [src/lib/services/validation/ConfigValidationService.ts:1-179]()\n\n### Validation Categories\n\n#### 1. Economic Viability Check\n\n**Core Logic** [src/lib/services/validation/ConfigValidationService.ts:69-88]()\n\n```typescript\n// Calculate minimum required TP distance to cover costs\nconst slippageEffect = GLOBAL_CONFIG.CC_PERCENT_SLIPPAGE * 2;  // 0.2%\nconst feesTotal = GLOBAL_CONFIG.CC_PERCENT_FEE * 2;            // 0.2%\nconst minRequiredTpDistance = slippageEffect + feesTotal;       // 0.4%\n\nif (GLOBAL_CONFIG.CC_MIN_TAKEPROFIT_DISTANCE_PERCENT < minRequiredTpDistance) {\n  errors.push(\n    `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT (${GLOBAL_CONFIG.CC_MIN_TAKEPROFIT_DISTANCE_PERCENT}%) ` +\n    `is too low to cover trading costs.\\n` +\n    `  Required minimum: ${minRequiredTpDistance.toFixed(2)}%\\n` +\n    `  Breakdown:\\n` +\n    `    - Slippage effect: ${slippageEffect.toFixed(2)}%\\n` +\n    `    - Fees: ${feesTotal.toFixed(2)}%\\n` +\n    `  All TakeProfit signals will be unprofitable with current settings!`\n  );\n}\n```\n\nThis ensures that `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT` (default 0.5%) is greater than total costs (0.4%), guaranteeing a minimum 0.1% profit buffer.\n\n#### 2. Percentage Parameter Validation\n\n| Parameter | Constraint | Reason |\n|-----------|-----------|---------|\n| `CC_PERCENT_SLIPPAGE` | ≥ 0, finite | Negative slippage is nonsensical |\n| `CC_PERCENT_FEE` | ≥ 0, finite | Negative fees don't exist |\n| `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT` | > 0, ≥ costs | Must cover execution costs |\n| `CC_MIN_STOPLOSS_DISTANCE_PERCENT` | > 0 | Prevents instant stop-out |\n| `CC_MAX_STOPLOSS_DISTANCE_PERCENT` | > 0 | Prevents catastrophic losses |\n\n**Sources:** [src/lib/services/validation/ConfigValidationService.ts:61-114]()\n\n#### 3. Range Constraint Validation\n\n[src/lib/services/validation/ConfigValidationService.ts:105-114]()\n\n```typescript\n// Validate that MIN < MAX for StopLoss\nif (GLOBAL_CONFIG.CC_MIN_STOPLOSS_DISTANCE_PERCENT >= \n    GLOBAL_CONFIG.CC_MAX_STOPLOSS_DISTANCE_PERCENT) {\n  errors.push(\n    `CC_MIN_STOPLOSS_DISTANCE_PERCENT must be less than ` +\n    `CC_MAX_STOPLOSS_DISTANCE_PERCENT`\n  );\n}\n```\n\nPrevents configurations like `MIN_SL=10%, MAX_SL=5%` which create impossible constraints.\n\n#### 4. Integer and Time Validation\n\n| Parameter | Type | Constraint | Default |\n|-----------|------|-----------|---------|\n| `CC_SCHEDULE_AWAIT_MINUTES` | integer | > 0 | 120 |\n| `CC_MAX_SIGNAL_LIFETIME_MINUTES` | integer | > 0 | 1440 |\n| `CC_MAX_SIGNAL_GENERATION_SECONDS` | integer | > 0 | 180 |\n| `CC_AVG_PRICE_CANDLES_COUNT` | integer | > 0 | 5 |\n| `CC_GET_CANDLES_RETRY_COUNT` | integer | ≥ 0 | 3 |\n| `CC_GET_CANDLES_RETRY_DELAY_MS` | integer | ≥ 0 | 5000 |\n| `CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR` | integer | > 0 | 1000 |\n| `CC_GET_CANDLES_MIN_CANDLES_FOR_MEDIAN` | integer | > 0 | 5 |\n\n**Sources:** [src/lib/services/validation/ConfigValidationService.ts:117-164]()\n\n---\n\n## Validation Flow\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant setConfig\n    participant GLOBAL_CONFIG\n    participant ConfigValidationService\n    participant errors\n    \n    User->>setConfig: setConfig({CC_MIN_TAKEPROFIT_DISTANCE_PERCENT: 0.3})\n    setConfig->>GLOBAL_CONFIG: Backup current config\n    setConfig->>GLOBAL_CONFIG: Apply new values\n    \n    setConfig->>ConfigValidationService: validate()\n    ConfigValidationService->>errors: errors = []\n    \n    ConfigValidationService->>ConfigValidationService: Check CC_PERCENT_SLIPPAGE >= 0\n    ConfigValidationService->>ConfigValidationService: Check CC_PERCENT_FEE >= 0\n    \n    ConfigValidationService->>ConfigValidationService: Calculate minRequiredTpDistance<br/>(slippage*2 + fees*2 = 0.4%)\n    ConfigValidationService->>ConfigValidationService: TP (0.3%) < minRequired (0.4%)\n    ConfigValidationService->>errors: Add: \"TP too low to cover costs\"\n    \n    ConfigValidationService->>ConfigValidationService: Check MIN_SL < MAX_SL\n    ConfigValidationService->>ConfigValidationService: Check integer constraints\n    \n    ConfigValidationService->>errors: errors.length > 0?\n    errors-->>ConfigValidationService: Yes (1 error)\n    ConfigValidationService->>ConfigValidationService: Build error message\n    \n    ConfigValidationService-->>setConfig: throw Error(\"GLOBAL_CONFIG validation failed...\")\n    setConfig->>GLOBAL_CONFIG: Rollback to backup\n    setConfig-->>User: throw error\n```\n\n**Sources:** [src/function/setup.ts:39-51](), [src/lib/services/validation/ConfigValidationService.ts:55-174]()\n\n### Error Output Example\n\n```\nGLOBAL_CONFIG validation failed:\n  1. CC_MIN_TAKEPROFIT_DISTANCE_PERCENT (0.3%) is too low to cover trading costs.\n     Required minimum: 0.40%\n     Breakdown:\n       - Slippage effect: 0.20% (0.1% × 2 transactions)\n       - Fees: 0.20% (0.1% × 2 transactions)\n     All TakeProfit signals will be unprofitable with current settings!\n```\n\n---\n\n## Safety Tests: Sanitize Suite\n\nThe sanitize test suite [test/e2e/sanitize.test.mjs:1-1507]() validates that dangerous configurations are rejected before execution.\n\n### Critical Test Categories\n\n```mermaid\ngraph TB\n    subgraph \"Economic Viability Tests\"\n        T1[\"Micro-profit eaten by fees<br/>TP too close to priceOpen<br/>scheduledCount=0, openedCount=0\"]\n    end\n    \n    subgraph \"Risk Protection Tests\"\n        T2[\"Extreme StopLoss >20%<br/>Prevents catastrophic loss<br/>Signal rejected\"]\n        T3[\"Excessive minuteEstimatedTime >30d<br/>Prevents eternal signals<br/>Strategy deadlock prevented\"]\n    end\n    \n    subgraph \"Data Integrity Tests\"\n        T4[\"Negative prices rejected<br/>priceOpen=-42000<br/>Impossible trade prevented\"]\n        T5[\"NaN/Infinity prices rejected<br/>priceOpen=NaN<br/>Calculation explosion prevented\"]\n        T6[\"Incomplete Binance candles<br/>Anomalous prices detected<br/>Fake signals prevented\"]\n    end\n    \n    subgraph \"Baseline Tests\"\n        T7[\"Basic LONG trading works<br/>scheduled → opened → closed<br/>PNL positive\"]\n        T8[\"Basic SHORT trading works<br/>scheduled → opened → closed<br/>PNL positive\"]\n    end\n```\n\n**Sources:** [test/e2e/sanitize.test.mjs:1-1507]()\n\n### Test 1: Micro-Profit Protection\n\n[test/e2e/sanitize.test.mjs:27-122]()\n\n**Scenario:** Signal with `priceTakeProfit=42010, priceOpen=42000` (0.024% profit)\n\n**Expected Behavior:** Rejected by validation (not scheduled or opened)\n\n**Cost Analysis:**\n- Raw profit: 0.024%\n- Slippage: -0.2%\n- Fees: -0.2%\n- **Net PNL: -0.376% (LOSS)**\n\n**Validation:** `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT: 0.3%` blocks this signal.\n\n### Test 2: Extreme StopLoss Protection\n\n[test/e2e/sanitize.test.mjs:134-229]()\n\n**Scenario:** `priceOpen=42000, priceStopLoss=20000` (52% risk per signal)\n\n**Expected Behavior:** Rejected to prevent portfolio destruction\n\n**Protection:** `CC_MAX_STOPLOSS_DISTANCE_PERCENT: 20%` (default) limits risk per signal.\n\n### Test 3: Excessive Lifetime Protection\n\n[test/e2e/sanitize.test.mjs:241-339]()\n\n**Scenario:** `minuteEstimatedTime=50000` (34+ days)\n\n**Problem:** Signal blocks risk limits for weeks, preventing new trades\n\n**Protection:** `CC_MAX_SIGNAL_LIFETIME_MINUTES: 43200` (30 days default) prevents strategy deadlock.\n\n### Test 4-5: Price Sanity Checks\n\n| Test | Scenario | Validation |\n|------|----------|------------|\n| Negative prices | `priceOpen=-42000` | Rejected (impossible in crypto markets) |\n| NaN/Infinity | `priceOpen=NaN` or `priceTakeProfit=Infinity` | Rejected (breaks all calculations) |\n\n**Sources:** [test/e2e/sanitize.test.mjs:351-651]()\n\n### Test 6: Incomplete Candle Detection\n\n[test/e2e/sanitize.test.mjs:666-784]()\n\n**Problem:** Binance API sometimes returns incomplete candles with anomalously low prices (e.g., `open=0.1` instead of `42000`).\n\n**Detection:** `VALIDATE_NO_INCOMPLETE_CANDLES_FN` compares prices against reference price (median or average).\n\n**Threshold:** `CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR: 1000` (price must be > referencePrice / 1000)\n\n**Example:**\n- Normal BTC price: $42,000\n- Anomalous candle: $0.1 (420,000× too low)\n- Threshold: $42 (42000/1000)\n- Result: $0.1 < $42 → **Rejected**\n\n---\n\n## Configuration Validation Mapping\n\n```mermaid\ngraph TB\n    subgraph \"GLOBAL_CONFIG Parameters\"\n        P1[\"CC_PERCENT_SLIPPAGE<br/>Default: 0.1%\"]\n        P2[\"CC_PERCENT_FEE<br/>Default: 0.1%\"]\n        P3[\"CC_MIN_TAKEPROFIT_DISTANCE_PERCENT<br/>Default: 0.5%\"]\n        P4[\"CC_MIN_STOPLOSS_DISTANCE_PERCENT<br/>Default: 0.5%\"]\n        P5[\"CC_MAX_STOPLOSS_DISTANCE_PERCENT<br/>Default: 20%\"]\n        P6[\"CC_MAX_SIGNAL_LIFETIME_MINUTES<br/>Default: 1440\"]\n    end\n    \n    subgraph \"ConfigValidationService Rules\"\n        R1[\"validate_slippage()<br/>Must be >= 0\"]\n        R2[\"validate_fee()<br/>Must be >= 0\"]\n        R3[\"validate_tp_distance()<br/>Must cover slippage+fees\"]\n        R4[\"validate_sl_range()<br/>MIN < MAX\"]\n        R5[\"validate_lifetime()<br/>Must be positive integer\"]\n    end\n    \n    subgraph \"Sanitize Tests\"\n        T1[\"Micro-profit test<br/>Verifies TP rejection\"]\n        T2[\"Extreme SL test<br/>Verifies MAX_SL enforcement\"]\n        T3[\"Excessive time test<br/>Verifies lifetime limit\"]\n    end\n    \n    P1 --> R1\n    P2 --> R2\n    P3 --> R3\n    P1 --> R3\n    P2 --> R3\n    P4 --> R4\n    P5 --> R4\n    P6 --> R5\n    \n    R3 --> T1\n    R4 --> T2\n    R5 --> T3\n```\n\n**Sources:** [src/config/params.ts:1-122](), [src/lib/services/validation/ConfigValidationService.ts:55-174](), [test/e2e/sanitize.test.mjs:1-1507]()\n\n---\n\n## Usage Examples\n\n### Valid Configuration\n\n```typescript\nimport { setConfig } from 'backtest-kit';\n\n// This passes validation (TP covers costs + buffer)\nsetConfig({\n  CC_PERCENT_SLIPPAGE: 0.1,      // 0.2% total effect\n  CC_PERCENT_FEE: 0.1,            // 0.2% total\n  CC_MIN_TAKEPROFIT_DISTANCE_PERCENT: 0.5,  // > 0.4% costs ✓\n  CC_MAX_STOPLOSS_DISTANCE_PERCENT: 15,     // Reasonable risk limit\n  CC_MAX_SIGNAL_LIFETIME_MINUTES: 2880,     // 2 days max\n});\n```\n\n### Invalid Configuration (Rejected)\n\n```typescript\n// This throws error: TP too low to cover costs\nsetConfig({\n  CC_PERCENT_SLIPPAGE: 0.1,\n  CC_PERCENT_FEE: 0.1,\n  CC_MIN_TAKEPROFIT_DISTANCE_PERCENT: 0.3,  // < 0.4% costs ✗\n});\n// Error: CC_MIN_TAKEPROFIT_DISTANCE_PERCENT (0.3%) is too low...\n```\n\n```typescript\n// This throws error: MIN > MAX\nsetConfig({\n  CC_MIN_STOPLOSS_DISTANCE_PERCENT: 25,\n  CC_MAX_STOPLOSS_DISTANCE_PERCENT: 10,  // MIN > MAX ✗\n});\n// Error: CC_MIN_STOPLOSS_DISTANCE_PERCENT must be less than...\n```\n\n### Bypassing Validation (Testing Only)\n\n[src/function/setup.ts:38-52](), [test/config/setup.mjs:89-102]()\n\n```typescript\n// For testbed only: skip validation with _unsafe flag\nsetConfig({\n  CC_MIN_TAKEPROFIT_DISTANCE_PERCENT: 0,  // Would normally fail\n  CC_MAX_STOPLOSS_DISTANCE_PERCENT: 100,\n}, true);  // _unsafe=true bypasses validation\n```\n\nThe `_unsafe` parameter is used in test environments to disable validation for testing edge cases.\n\n---\n\n## Validation Timing\n\n| Event | Validation Trigger | Impact |\n|-------|-------------------|--------|\n| `setConfig()` call | Immediate | Rollback on error, state preserved |\n| `addStrategy()` | None | Config already validated |\n| `Backtest.run()` | None | Config already validated |\n| Signal generation | Runtime checks | Separate from config validation |\n\nConfiguration validation happens once at `setConfig()` time, not during execution. This ensures performance is not impacted during backtests or live trading.\n\n**Sources:** [src/function/setup.ts:38-52]()\n\n---\n\n## Cost Model Default Values Rationale\n\n| Parameter | Default | Reasoning |\n|-----------|---------|-----------|\n| `CC_PERCENT_SLIPPAGE` | 0.1% | Conservative estimate for liquid markets (BTC, ETH) |\n| `CC_PERCENT_FEE` | 0.1% | Standard maker/taker fee on major exchanges |\n| `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT` | 0.5% | Covers 0.4% costs + 0.1% minimum profit buffer |\n| `CC_MIN_STOPLOSS_DISTANCE_PERCENT` | 0.5% | Prevents instant stop-out from normal volatility |\n| `CC_MAX_STOPLOSS_DISTANCE_PERCENT` | 20% | Limits single-signal risk to 20% of position |\n| `CC_MAX_SIGNAL_LIFETIME_MINUTES` | 1440 | 1 day prevents eternal signals blocking risk limits |\n\n**Sources:** [src/config/params.ts:1-122]()\n\n---\n\n## Test Coverage Summary\n\n| Category | Test Count | Coverage |\n|----------|-----------|----------|\n| Economic viability | 1 | Micro-profit rejection |\n| Risk protection | 2 | Extreme SL, excessive lifetime |\n| Data integrity | 4 | Negative/NaN/Infinity prices, incomplete candles |\n| Baseline functionality | 2 | LONG/SHORT basic trading |\n| Configuration validation | 25+ | All parameter constraints |\n\n**Total:** 34+ tests ensuring money safety and system stability.\n\n**Sources:** [test/e2e/sanitize.test.mjs:1-1507](), [test/spec/config.test.mjs:1-467](), [test/e2e/config.test.mjs:1-224]()\n\n---\n\n## Integration with Signal Validation\n\nConfiguration validation (`ConfigValidationService`) is distinct from signal validation at runtime:\n\n| Validation Type | Timing | Scope | Example |\n|----------------|--------|-------|---------|\n| **Config Validation** | `setConfig()` time | Global parameters | Ensure TP distance ≥ 0.4% |\n| **Signal Validation** | Runtime (per signal) | Individual signal fields | Check `priceTakeProfit > priceOpen` for LONG |\n\nBoth layers work together:\n1. Config validation ensures global constraints are sane\n2. Signal validation ensures each signal respects those constraints\n\nFor signal-level validation (e.g., `VALIDATE_SIGNAL_FN`), see [Risk Management](#4.3).\n\n**Sources:** [src/lib/services/validation/ConfigValidationService.ts:1-179](), [test/e2e/defend.test.mjs:1-1045]()\n\n---\n\n## Summary\n\nThe `ConfigValidationService` prevents unprofitable and dangerous trading configurations through:\n\n1. **Economic viability checks:** Ensures `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT` covers all execution costs (slippage + fees)\n2. **Range constraints:** Validates MIN < MAX relationships and reasonable bounds\n3. **Type safety:** Enforces integer/positive constraints on time and count parameters\n4. **Comprehensive error reporting:** Aggregates all validation errors with detailed breakdowns\n5. **Rollback on failure:** Preserves previous valid configuration if new config is rejected\n6. **Extensive test coverage:** 34+ tests verify protection against common pitfalls\n\nThis system ensures that strategies are mathematically sound before any capital is risked, providing a critical safety layer between user configuration and execution.\n\n**Sources:** [src/lib/services/validation/ConfigValidationService.ts:1-179](), [src/function/setup.ts:38-52](), [src/config/params.ts:1-122](), [test/e2e/sanitize.test.mjs:1-1507](), [test/spec/config.test.mjs:1-467]()"
                    },
                    {
                        "page_plan": {
                            "id": "7.3",
                            "title": "Configuration API"
                        },
                        "content": "# Configuration API\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/config/params.ts](src/config/params.ts)\n- [src/function/add.ts](src/function/add.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/function/list.ts](src/function/list.ts)\n- [src/function/setup.ts](src/function/setup.ts)\n- [src/helpers/toProfitLossDto.ts](src/helpers/toProfitLossDto.ts)\n- [src/index.ts](src/index.ts)\n- [src/lib/core/provide.ts](src/lib/core/provide.ts)\n- [src/lib/core/types.ts](src/lib/core/types.ts)\n- [src/lib/index.ts](src/lib/index.ts)\n- [src/lib/services/validation/ConfigValidationService.ts](src/lib/services/validation/ConfigValidationService.ts)\n- [test/config/setup.mjs](test/config/setup.mjs)\n- [test/e2e/config.test.mjs](test/e2e/config.test.mjs)\n- [test/e2e/sanitize.test.mjs](test/e2e/sanitize.test.mjs)\n- [test/spec/config.test.mjs](test/spec/config.test.mjs)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\nThis page documents the public API functions for configuring the framework's global parameters at runtime. For descriptions of individual configuration parameters, see [Global Configuration Parameters](#7.1). For details on how configuration values are validated, see [Economic Viability and Validation](#7.2).\n\n---\n\n## API Functions\n\nThe configuration API provides three primary functions for managing global settings: `setConfig()` for updating parameters, `getConfig()` for reading current values, and `getDefaultConfig()` for inspecting defaults.\n\n### setConfig()\n\nSets or updates global configuration parameters with automatic validation and rollback on error.\n\n**Function Signature:**\n```typescript\nfunction setConfig(config: Partial<GlobalConfig>, _unsafe?: boolean): void\n```\n\n**Parameters:**\n- `config`: Partial configuration object containing only the parameters to update\n- `_unsafe`: Optional boolean to skip validation (used only in test environments)\n\n**Behavior:**\n1. Creates a backup copy of current `GLOBAL_CONFIG`\n2. Merges provided config into `GLOBAL_CONFIG` using `Object.assign()`\n3. Calls `ConfigValidationService.validate()` (unless `_unsafe=true`)\n4. If validation fails, restores previous config from backup and throws error\n5. If validation succeeds, new config is active immediately\n\n**Sources:** [src/function/setup.ts:39-52](), [types.d.ts:168-179]()\n\n### getConfig()\n\nRetrieves a shallow copy of the current global configuration state.\n\n**Function Signature:**\n```typescript\nfunction getConfig(): GlobalConfig\n```\n\n**Returns:** Shallow copy of `GLOBAL_CONFIG` to prevent accidental mutations\n\n**Usage:** Inspect current configuration without modifying it\n\n**Sources:** [src/function/setup.ts:68-70](), [types.d.ts:181-209]()\n\n### getDefaultConfig()\n\nRetrieves the frozen default configuration object.\n\n**Function Signature:**\n```typescript\nfunction getDefaultConfig(): Readonly<GlobalConfig>\n```\n\n**Returns:** Read-only reference to `DEFAULT_CONFIG` with all preset values\n\n**Usage:** Compare current config against defaults or reset to known state\n\n**Sources:** [src/function/setup.ts:86-88](), [types.d.ts:210-239](), [src/config/params.ts:116]()\n\n---\n\n## Configuration Flow Architecture\n\n```mermaid\ngraph TB\n    User[\"User Code\"]\n    SetConfig[\"setConfig(config, _unsafe)\"]\n    Backup[\"Backup Current Config<br/>prevConfig = {...GLOBAL_CONFIG}\"]\n    Merge[\"Merge Into GLOBAL_CONFIG<br/>Object.assign(GLOBAL_CONFIG, config)\"]\n    CheckUnsafe{\"_unsafe === true?\"}\n    Validate[\"ConfigValidationService.validate()\"]\n    ValidationOK{\"Validation<br/>Passed?\"}\n    Restore[\"Restore Backup<br/>Object.assign(GLOBAL_CONFIG, prevConfig)\"]\n    ThrowError[\"throw Error\"]\n    Active[\"New Config Active\"]\n    GetConfig[\"getConfig()\"]\n    GetDefault[\"getDefaultConfig()\"]\n    Copy[\"Return Shallow Copy<br/>{...GLOBAL_CONFIG}\"]\n    Frozen[\"Return Frozen<br/>DEFAULT_CONFIG\"]\n    Services[\"Services Read GLOBAL_CONFIG<br/>ConfigValidationService<br/>StrategyCoreService<br/>ClientExchange<br/>toProfitLossDto\"]\n    \n    User --> SetConfig\n    User --> GetConfig\n    User --> GetDefault\n    \n    SetConfig --> Backup\n    Backup --> Merge\n    Merge --> CheckUnsafe\n    CheckUnsafe -->|No| Validate\n    CheckUnsafe -->|Yes| Active\n    Validate --> ValidationOK\n    ValidationOK -->|Yes| Active\n    ValidationOK -->|No| Restore\n    Restore --> ThrowError\n    Active --> Services\n    \n    GetConfig --> Copy\n    GetDefault --> Frozen\n    \n    style SetConfig fill:#e1f5ff,stroke:#333,stroke-width:2px\n    style Validate fill:#ffe1e1,stroke:#333,stroke-width:2px\n    style ThrowError fill:#ffcccc,stroke:#333,stroke-width:2px\n    style Active fill:#e8f5e9,stroke:#333,stroke-width:2px\n```\n\n**Sources:** [src/function/setup.ts:39-52](), [src/lib/services/validation/ConfigValidationService.ts:55-174]()\n\n---\n\n## Basic Usage Examples\n\n### Updating Configuration Parameters\n\n```typescript\nimport { setConfig } from 'backtest-kit';\n\n// Update schedule await timeout\nsetConfig({\n  CC_SCHEDULE_AWAIT_MINUTES: 90,\n});\n\n// Update multiple parameters atomically\nsetConfig({\n  CC_PERCENT_SLIPPAGE: 0.15,\n  CC_PERCENT_FEE: 0.08,\n  CC_MIN_TAKEPROFIT_DISTANCE_PERCENT: 0.6,\n});\n```\n\n**Sources:** [test/e2e/config.test.mjs:18-23](), [test/e2e/config.test.mjs:85-91]()\n\n### Partial Updates Preserve Other Values\n\n```typescript\nimport { setConfig } from 'backtest-kit';\n\n// Set both values\nsetConfig({\n  CC_SCHEDULE_AWAIT_MINUTES: 90,\n  CC_AVG_PRICE_CANDLES_COUNT: 7,\n});\n\n// Update only one value - other value remains 90\nsetConfig({\n  CC_AVG_PRICE_CANDLES_COUNT: 8,\n});\n```\n\n**Sources:** [test/e2e/config.test.mjs:84-95]()\n\n### Reading Current Configuration\n\n```typescript\nimport { getConfig } from 'backtest-kit';\n\nconst currentConfig = getConfig();\nconsole.log(currentConfig.CC_SCHEDULE_AWAIT_MINUTES); // Current value\nconsole.log(currentConfig.CC_PERCENT_SLIPPAGE); // Current value\n\n// Safe to mutate copy without affecting global config\ncurrentConfig.CC_PERCENT_FEE = 999; // Does NOT affect GLOBAL_CONFIG\n```\n\n**Sources:** [src/function/setup.ts:68-70](), [types.d.ts:189-209]()\n\n### Inspecting Default Values\n\n```typescript\nimport { getDefaultConfig } from 'backtest-kit';\n\nconst defaults = getDefaultConfig();\nconsole.log(defaults.CC_SCHEDULE_AWAIT_MINUTES); // 120\nconsole.log(defaults.CC_AVG_PRICE_CANDLES_COUNT); // 5\nconsole.log(defaults.CC_MIN_TAKEPROFIT_DISTANCE_PERCENT); // 0.5\n```\n\n**Sources:** [src/function/setup.ts:86-88](), [src/config/params.ts:1-116]()\n\n---\n\n## Validation Error Handling\n\nWhen `setConfig()` is called without the `_unsafe` parameter, the `ConfigValidationService` validates all constraints before applying changes. If validation fails, the previous configuration is restored and an error is thrown with detailed diagnostics.\n\n### Validation Error Structure\n\n```mermaid\ngraph LR\n    SetConfig[\"setConfig(invalid)\"]\n    Validate[\"ConfigValidationService.validate()\"]\n    Collect[\"Collect All Validation Errors<br/>const errors: string[] = []\"]\n    Check1[\"Check CC_PERCENT_SLIPPAGE >= 0\"]\n    Check2[\"Check CC_PERCENT_FEE >= 0\"]\n    Check3[\"Check TP covers costs\"]\n    Check4[\"Check MIN_SL < MAX_SL\"]\n    CheckN[\"Check all other params...\"]\n    HasErrors{\"errors.length > 0?\"}\n    Format[\"Format Error Message<br/>List all errors with numbers\"]\n    Restore[\"Restore prevConfig\"]\n    Throw[\"throw Error\"]\n    Apply[\"Apply Config\"]\n    \n    SetConfig --> Validate\n    Validate --> Collect\n    Collect --> Check1\n    Collect --> Check2\n    Collect --> Check3\n    Collect --> Check4\n    Collect --> CheckN\n    Check1 --> HasErrors\n    Check2 --> HasErrors\n    Check3 --> HasErrors\n    Check4 --> HasErrors\n    CheckN --> HasErrors\n    HasErrors -->|Yes| Format\n    HasErrors -->|No| Apply\n    Format --> Restore\n    Restore --> Throw\n    \n    style Validate fill:#ffe1e1,stroke:#333,stroke-width:2px\n    style Throw fill:#ffcccc,stroke:#333,stroke-width:2px\n```\n\n**Sources:** [src/lib/services/validation/ConfigValidationService.ts:55-174](), [src/function/setup.ts:43-51]()\n\n### Example Validation Errors\n\n| Scenario | Error Message |\n|----------|---------------|\n| Negative slippage | `CC_PERCENT_SLIPPAGE must be a non-negative number, got -0.1` |\n| TP below costs | `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT (0.3%) is too low to cover trading costs. Required minimum: 0.40%` |\n| MIN_SL > MAX_SL | `CC_MIN_STOPLOSS_DISTANCE_PERCENT (10%) must be less than CC_MAX_STOPLOSS_DISTANCE_PERCENT (5%)` |\n| Non-integer count | `CC_AVG_PRICE_CANDLES_COUNT must be a positive integer, got 5.5` |\n| Multiple errors | `GLOBAL_CONFIG validation failed:\\n  1. [error1]\\n  2. [error2]\\n  3. [error3]` |\n\n**Sources:** [test/spec/config.test.mjs:14-26](), [test/spec/config.test.mjs:44-64](), [test/spec/config.test.mjs:419-437]()\n\n### Error Example: Take Profit Below Cost Coverage\n\n```typescript\nimport { setConfig } from 'backtest-kit';\n\ntry {\n  setConfig({\n    CC_PERCENT_SLIPPAGE: 0.1,\n    CC_PERCENT_FEE: 0.1,\n    CC_MIN_TAKEPROFIT_DISTANCE_PERCENT: 0.3, // Too low!\n  });\n} catch (error) {\n  console.error(error.message);\n  // Output:\n  // GLOBAL_CONFIG validation failed:\n  //   1. CC_MIN_TAKEPROFIT_DISTANCE_PERCENT (0.3%) is too low to cover trading costs.\n  //      Required minimum: 0.40%\n  //      Breakdown:\n  //        - Slippage effect: 0.20% (0.1% × 2 transactions)\n  //        - Fees: 0.20% (0.1% × 2 transactions)\n  //      All TakeProfit signals will be unprofitable with current settings!\n}\n```\n\n**Sources:** [test/spec/config.test.mjs:44-64](), [src/lib/services/validation/ConfigValidationService.ts:79-88]()\n\n---\n\n## The _unsafe Parameter\n\nThe `_unsafe` parameter in `setConfig()` bypasses validation checks. This is **only for testing environments** where you need to test edge cases or invalid configurations.\n\n### When to Use _unsafe\n\n| Use Case | Reason |\n|----------|--------|\n| Test edge cases | Verify signal validation catches micro-profit signals |\n| Test error handling | Ensure system handles invalid configs gracefully |\n| Testbed isolation | Disable strict checks for faster test execution |\n| Mock configurations | Create unrealistic but controlled test scenarios |\n\n### Usage in Tests\n\n```typescript\nimport { setConfig } from 'backtest-kit';\n\n// In production code - validation runs\nsetConfig({\n  CC_MIN_TAKEPROFIT_DISTANCE_PERCENT: 0.3, // Would throw error\n});\n\n// In testbed - validation skipped\nsetConfig({\n  CC_MIN_TAKEPROFIT_DISTANCE_PERCENT: 0, // Allowed with _unsafe=true\n  CC_MAX_STOPLOSS_DISTANCE_PERCENT: 100,\n  CC_MAX_SIGNAL_LIFETIME_MINUTES: 999999,\n}, true); // _unsafe parameter\n```\n\n**Sources:** [test/config/setup.mjs:89-102](), [src/function/setup.ts:39](), [types.d.ts:170]()\n\n### Production Warning\n\n**Never use `_unsafe=true` in production code.** Disabling validation can lead to:\n- Unprofitable signals (TP below cost coverage)\n- Catastrophic losses (extreme stop loss distances)\n- System instability (negative or infinite values)\n- Mathematical errors (division by zero, NaN propagation)\n\n**Sources:** [src/function/setup.ts:30]()\n\n---\n\n## Configuration Lifecycle in Execution Modes\n\nThe configuration system integrates with all execution modes through direct reads of `GLOBAL_CONFIG`. Changes take effect immediately for subsequent operations.\n\n```mermaid\ngraph TB\n    subgraph \"Configuration Sources\"\n        DefaultConfig[\"DEFAULT_CONFIG<br/>(frozen, src/config/params.ts)\"]\n        GlobalConfig[\"GLOBAL_CONFIG<br/>(mutable, runtime state)\"]\n        UserConfig[\"User calls setConfig()\"]\n    end\n    \n    subgraph \"Validation Layer\"\n        ConfigValidation[\"ConfigValidationService.validate()\"]\n    end\n    \n    subgraph \"Consumers - Core Logic\"\n        StrategyCore[\"StrategyCoreService<br/>Reads: CC_MAX_SIGNAL_GENERATION_SECONDS<br/>CC_MAX_SIGNAL_LIFETIME_MINUTES\"]\n        ExchangeCore[\"ExchangeCoreService<br/>Reads: CC_GET_CANDLES_RETRY_COUNT<br/>CC_GET_CANDLES_RETRY_DELAY_MS\"]\n        ProfitLoss[\"toProfitLossDto()<br/>Reads: CC_PERCENT_SLIPPAGE<br/>CC_PERCENT_FEE\"]\n    end\n    \n    subgraph \"Consumers - Clients\"\n        ClientStrategy[\"ClientStrategy<br/>Reads: CC_SCHEDULE_AWAIT_MINUTES<br/>CC_MAX_SIGNAL_LIFETIME_MINUTES\"]\n        ClientExchange[\"ClientExchange.getAveragePrice()<br/>Reads: CC_AVG_PRICE_CANDLES_COUNT<br/>CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR\"]\n    end\n    \n    subgraph \"Consumers - Validation\"\n        SignalValidation[\"VALIDATE_SIGNAL_FN<br/>Reads: CC_MIN_TAKEPROFIT_DISTANCE_PERCENT<br/>CC_MIN_STOPLOSS_DISTANCE_PERCENT<br/>CC_MAX_STOPLOSS_DISTANCE_PERCENT\"]\n    end\n    \n    DefaultConfig -->|\"Object.freeze()\"| GlobalConfig\n    UserConfig -->|\"setConfig()\"| ConfigValidation\n    ConfigValidation -->|\"validate()\"| GlobalConfig\n    \n    GlobalConfig --> StrategyCore\n    GlobalConfig --> ExchangeCore\n    GlobalConfig --> ProfitLoss\n    GlobalConfig --> ClientStrategy\n    GlobalConfig --> ClientExchange\n    GlobalConfig --> SignalValidation\n    \n    style GlobalConfig fill:#e1f5ff,stroke:#333,stroke-width:3px\n    style ConfigValidation fill:#ffe1e1,stroke:#333,stroke-width:2px\n```\n\n**Sources:** [src/config/params.ts:1-122](), [src/function/setup.ts:1-89](), [src/helpers/toProfitLossDto.ts:44-53]()\n\n---\n\n## Code Entity Reference\n\n### Core Configuration Types and Functions\n\n| Entity | Location | Purpose |\n|--------|----------|---------|\n| `GlobalConfig` | [types.d.ts:119]() | Type definition for configuration object |\n| `GLOBAL_CONFIG` | [src/config/params.ts:1-114]() | Mutable runtime configuration state |\n| `DEFAULT_CONFIG` | [src/config/params.ts:116]() | Frozen default configuration values |\n| `setConfig()` | [src/function/setup.ts:39-52]() | Update configuration with validation |\n| `getConfig()` | [src/function/setup.ts:68-70]() | Retrieve current configuration copy |\n| `getDefaultConfig()` | [src/function/setup.ts:86-88]() | Retrieve default configuration |\n| `ConfigValidationService` | [src/lib/services/validation/ConfigValidationService.ts:37]() | Validates configuration constraints |\n\n**Sources:** [src/index.ts:1-6](), [types.d.ts:5-122](), [src/config/params.ts:1-122]()\n\n---\n\n## Advanced Configuration Patterns\n\n### Conditional Configuration Based on Environment\n\n```typescript\nimport { setConfig } from 'backtest-kit';\n\nif (process.env.NODE_ENV === 'production') {\n  setConfig({\n    CC_PERCENT_SLIPPAGE: 0.15, // Higher slippage for production\n    CC_PERCENT_FEE: 0.1,\n    CC_MIN_TAKEPROFIT_DISTANCE_PERCENT: 0.7, // More conservative\n  });\n} else {\n  setConfig({\n    CC_PERCENT_SLIPPAGE: 0.05, // Lower slippage for testing\n    CC_PERCENT_FEE: 0.05,\n    CC_MIN_TAKEPROFIT_DISTANCE_PERCENT: 0.3,\n  });\n}\n```\n\n**Sources:** [test/e2e/config.test.mjs:156-163]()\n\n### Configuration Before Strategy Registration\n\nConfiguration changes must be applied **before** calling `addStrategy()`, `addExchange()`, etc. The framework reads `GLOBAL_CONFIG` during strategy execution, not during registration.\n\n```typescript\nimport { setConfig, addExchange, addStrategy, Backtest } from 'backtest-kit';\n\n// 1. Configure FIRST\nsetConfig({\n  CC_AVG_PRICE_CANDLES_COUNT: 6,\n  CC_SCHEDULE_AWAIT_MINUTES: 90,\n});\n\n// 2. Register components SECOND\naddExchange({ /* ... */ });\naddStrategy({ /* ... */ });\naddFrame({ /* ... */ });\n\n// 3. Execute THIRD - uses current GLOBAL_CONFIG\nBacktest.run(\"BTCUSDT\", {\n  strategyName: \"my-strategy\",\n  exchangeName: \"my-exchange\",\n  frameName: \"my-frame\",\n});\n```\n\n**Sources:** [test/e2e/config.test.mjs:156-223]()\n\n---\n\n## Related Pages\n\n- [Global Configuration Parameters](#7.1) - Descriptions of all configuration parameters\n- [Economic Viability and Validation](#7.2) - Details on how validation logic prevents unprofitable configurations\n- [Risk Management](#4.3) - How configuration affects risk validation\n- [Position Sizing](#4.4) - How configuration influences position calculations\n\n**Sources:** [types.d.ts:5-239](), [src/function/setup.ts:1-89](), [src/config/params.ts:1-122]()"
                    },
                    {
                        "page_plan": {
                            "id": "8",
                            "title": "Reporting and Analytics"
                        },
                        "content": "# Reporting and Analytics\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [src/interfaces/Heatmap.interface.ts](src/interfaces/Heatmap.interface.ts)\n- [src/lib/services/markdown/BacktestMarkdownService.ts](src/lib/services/markdown/BacktestMarkdownService.ts)\n- [src/lib/services/markdown/HeatMarkdownService.ts](src/lib/services/markdown/HeatMarkdownService.ts)\n- [src/lib/services/markdown/LiveMarkdownService.ts](src/lib/services/markdown/LiveMarkdownService.ts)\n- [src/lib/services/markdown/PartialMarkdownService.ts](src/lib/services/markdown/PartialMarkdownService.ts)\n- [src/lib/services/markdown/PerformanceMarkdownService.ts](src/lib/services/markdown/PerformanceMarkdownService.ts)\n- [src/lib/services/markdown/ScheduleMarkdownService.ts](src/lib/services/markdown/ScheduleMarkdownService.ts)\n- [src/lib/services/markdown/WalkerMarkdownService.ts](src/lib/services/markdown/WalkerMarkdownService.ts)\n- [test/e2e/defend.test.mjs](test/e2e/defend.test.mjs)\n- [test/e2e/risk.test.mjs](test/e2e/risk.test.mjs)\n- [test/index.mjs](test/index.mjs)\n- [test/mock/getMockCandles.mjs](test/mock/getMockCandles.mjs)\n- [test/spec/heat.test.mjs](test/spec/heat.test.mjs)\n- [test/spec/list.test.mjs](test/spec/list.test.mjs)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\nThe reporting and analytics subsystem provides comprehensive markdown report generation and statistical analysis for trading strategy execution. This page documents the nine markdown service implementations, their data accumulation patterns, statistics calculation methods, and report output formats.\n\nFor information about the event system that feeds these services, see [Event-Driven Architecture](#2.3). For details on execution modes that generate reportable events, see [Execution Modes Overview](#2.2).\n\n---\n\n## Overview of Markdown Services\n\nThe framework implements nine specialized markdown services, each responsible for tracking and reporting on a specific aspect of strategy execution. All services follow a consistent three-method API pattern: `getData()` for retrieving statistics objects, `getReport()` for generating markdown strings, and `dump()` for writing reports to disk.\n\n### Service Categories\n\n```mermaid\ngraph TB\n    subgraph \"Signal Tracking Services\"\n        BT[\"BacktestMarkdownService<br/>Closed signals only<br/>signalBacktestEmitter\"]\n        LV[\"LiveMarkdownService<br/>All tick types<br/>signalLiveEmitter\"]\n        SCH[\"ScheduleMarkdownService<br/>Scheduled/cancelled<br/>signalEmitter\"]\n    end\n    \n    subgraph \"Portfolio Analysis Services\"\n        HT[\"HeatMarkdownService<br/>Per-symbol stats<br/>signalEmitter\"]\n        PRT[\"PartialMarkdownService<br/>P/L milestones<br/>partialProfitSubject<br/>partialLossSubject\"]\n    end\n    \n    subgraph \"Comparison Services\"\n        WK[\"WalkerMarkdownService<br/>Strategy comparison<br/>walkerEmitter\"]\n    end\n    \n    subgraph \"System Monitoring Services\"\n        PRF[\"PerformanceMarkdownService<br/>Execution metrics<br/>performanceEmitter\"]\n        RSK[\"RiskMarkdownService<br/>Risk rejections<br/>riskSubject\"]\n        OUT[\"OutlineMarkdownService<br/>Config dump<br/>No emitter\"]\n    end\n    \n    subgraph \"Storage Pattern\"\n        RS[\"ReportStorage<br/>Memoized per symbol:strategy<br/>MAX_EVENTS bounds\"]\n    end\n    \n    subgraph \"Public API\"\n        BT_API[\"Backtest.getData()<br/>Backtest.getReport()<br/>Backtest.dump()\"]\n        LV_API[\"Live.getData()<br/>Live.getReport()<br/>Live.dump()\"]\n        HT_API[\"Heat.getData()<br/>Heat.getReport()<br/>Heat.dump()\"]\n    end\n    \n    BT --> RS\n    LV --> RS\n    SCH --> RS\n    HT --> RS\n    PRT --> RS\n    WK --> RS\n    PRF --> RS\n    RSK --> RS\n    \n    BT_API --> BT\n    LV_API --> LV\n    HT_API --> HT\n```\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:1-571](), [src/lib/services/markdown/LiveMarkdownService.ts:1-778](), [src/lib/services/markdown/ScheduleMarkdownService.ts:1-625](), [src/lib/services/markdown/WalkerMarkdownService.ts:1-569](), [src/lib/services/markdown/PerformanceMarkdownService.ts:1-467](), [src/lib/services/markdown/HeatMarkdownService.ts:1-540](), [src/lib/services/markdown/PartialMarkdownService.ts:1-399]()\n\n### Service Summary Table\n\n| Service | Primary Purpose | Event Source | Statistics Interface | MAX_EVENTS |\n|---------|----------------|--------------|---------------------|------------|\n| `BacktestMarkdownService` | Tracks closed backtest signals | `signalBacktestEmitter` | `BacktestStatistics` | 250 |\n| `LiveMarkdownService` | Tracks all live tick events | `signalLiveEmitter` | `LiveStatistics` | 250 |\n| `ScheduleMarkdownService` | Tracks scheduled signal lifecycle | `signalEmitter` | `ScheduleStatistics` | 250 |\n| `HeatMarkdownService` | Portfolio-wide symbol statistics | `signalEmitter` | `IHeatmapStatistics` | 250 per symbol |\n| `PartialMarkdownService` | Profit/loss milestone tracking | `partialProfitSubject`<br/>`partialLossSubject` | `PartialStatistics` | 250 |\n| `WalkerMarkdownService` | Strategy comparison results | `walkerEmitter` | `WalkerStatistics` | Unbounded |\n| `PerformanceMarkdownService` | Execution timing metrics | `performanceEmitter` | `PerformanceStatistics` | 10000 |\n| `RiskMarkdownService` | Risk validation rejections | `riskSubject` | `RiskStatistics` | Unbounded |\n| `OutlineMarkdownService` | System configuration dump | N/A (manual) | N/A | N/A |\n\n**Sources:** [types.d.ts:151-157](), [src/config/emitters.ts:1-133]()\n\n---\n\n## ReportStorage Pattern\n\nAll markdown services use an internal `ReportStorage` class that implements a bounded queue pattern for memory-safe data accumulation. Each storage instance is memoized per `symbol:strategyName` key to maintain isolated statistics.\n\n### Storage Architecture\n\n```mermaid\ngraph TB\n    subgraph \"BacktestMarkdownService Instance\"\n        GS[\"getStorage() memoized<br/>Key: symbol:strategyName<br/>Factory: new ReportStorage()\"]\n        TICK[\"tick() private method<br/>Filters for closed signals\"]\n    end\n    \n    subgraph \"ReportStorage Instance\"\n        LIST[\"_signalList: IStrategyTickResultClosed[]<br/>Bounded by MAX_EVENTS=250<br/>FIFO unshift/pop\"]\n        ADD[\"addSignal(data)<br/>Unshift to front<br/>Pop from end if > MAX_EVENTS\"]\n        GETDATA[\"getData(): Promise&lt;BacktestStatistics&gt;<br/>Calculate statistics<br/>Sharpe, win rate, etc.\"]\n        GETREP[\"getReport(strategyName): Promise&lt;string&gt;<br/>Generate markdown table<br/>Format with columns\"]\n        DUMP[\"dump(strategyName, path)<br/>Write to ./dump/backtest/<br/>Create directory if needed\"]\n    end\n    \n    subgraph \"Event Subscription\"\n        EMT[\"signalBacktestEmitter<br/>Subject&lt;IStrategyTickResult&gt;\"]\n        INIT[\"init() singleshot<br/>Subscribe once on first use\"]\n    end\n    \n    EMT -->|\"subscribe(tick)\"| INIT\n    INIT -->|\"Automatic\"| TICK\n    TICK -->|\"action === 'closed'\"| GS\n    GS -->|\"Returns cached instance\"| ADD\n    ADD -->|\"Append to\"| LIST\n    LIST -->|\"Calculate from\"| GETDATA\n    LIST -->|\"Format from\"| GETREP\n    GETREP -->|\"Write to disk\"| DUMP\n```\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:199-367](), [src/lib/services/markdown/BacktestMarkdownService.ts:396-570]()\n\n### Memoization Key Format\n\nServices use different memoization strategies based on their data isolation requirements:\n\n- **Per symbol-strategy**: `BacktestMarkdownService`, `LiveMarkdownService`, `ScheduleMarkdownService`, `PartialMarkdownService`, `PerformanceMarkdownService` use key `\"${symbol}:${strategyName}\"`\n- **Per strategy**: `WalkerMarkdownService`, `RiskMarkdownService` use key `strategyName`\n- **Global**: `HeatMarkdownService` uses key `strategyName` but aggregates across symbols\n\n```typescript\n// Example from BacktestMarkdownService\nprivate getStorage = memoize<(symbol: string, strategyName: string) => ReportStorage>(\n  ([symbol, strategyName]) => `${symbol}:${strategyName}`,\n  () => new ReportStorage()\n);\n```\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:404-407](), [src/lib/services/markdown/LiveMarkdownService.ts:604-607]()\n\n---\n\n## Statistics Calculation\n\nEach markdown service calculates domain-specific statistics from accumulated event data. All services implement null-safe calculations that return `null` for unsafe values (NaN, Infinity, division by zero).\n\n### Common Metrics Across Services\n\n#### Trading Performance Metrics\n\nThe following metrics appear in `BacktestStatistics`, `LiveStatistics`, and per-symbol calculations in `IHeatmapRow`:\n\n| Metric | Formula | Interpretation |\n|--------|---------|----------------|\n| **Win Rate** | `(winCount / totalTrades) × 100` | Percentage of profitable trades (higher is better) |\n| **Average PNL** | `Σ(pnlPercentage) / totalTrades` | Mean profit/loss per trade (higher is better) |\n| **Total PNL** | `Σ(pnlPercentage)` | Cumulative profit/loss (higher is better) |\n| **Standard Deviation** | `√(Σ(pnl - avgPnl)² / totalTrades)` | Volatility measure (lower is better) |\n| **Sharpe Ratio** | `avgPnl / stdDev` | Risk-adjusted return (higher is better) |\n| **Annualized Sharpe** | `sharpeRatio × √365` | Yearly risk-adjusted return (higher is better) |\n| **Certainty Ratio** | `avgWin / |avgLoss|` | Win size vs loss size (higher is better) |\n| **Expected Yearly Returns** | `avgPnl × (365 / avgDurationDays)` | Projected annual return (higher is better) |\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:227-295](), [src/lib/services/markdown/LiveMarkdownService.ts:409-492]()\n\n#### Risk-Adjusted Calculations\n\n```mermaid\ngraph LR\n    subgraph \"Data Collection\"\n        SIGNALS[\"Closed Signals<br/>pnlPercentage<br/>duration\"]\n    end\n    \n    subgraph \"Basic Statistics\"\n        AVG[\"avgPnl = Σpnl / n\"]\n        STD[\"stdDev = √(Σ(pnl - avg)² / n)\"]\n        WINS[\"wins = filter(pnl > 0)\"]\n        LOSSES[\"losses = filter(pnl < 0)\"]\n    end\n    \n    subgraph \"Derived Metrics\"\n        SHARPE[\"sharpeRatio = avgPnl / stdDev<br/>(risk-adjusted return)\"]\n        CERT[\"certaintyRatio = avgWin / |avgLoss|<br/>(win/loss size ratio)\"]\n        ANNUAL[\"annualizedSharpe = sharpe × √365<br/>(yearly projection)\"]\n        EXPECT[\"expectedYearlyReturns<br/>= avgPnl × tradesPerYear\"]\n    end\n    \n    SIGNALS --> AVG\n    SIGNALS --> STD\n    SIGNALS --> WINS\n    SIGNALS --> LOSSES\n    \n    AVG --> SHARPE\n    STD --> SHARPE\n    WINS --> CERT\n    LOSSES --> CERT\n    SHARPE --> ANNUAL\n    AVG --> EXPECT\n```\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:254-279](), [src/lib/services/markdown/LiveMarkdownService.ts:440-475]()\n\n### Specialized Service Statistics\n\n#### ScheduleMarkdownService Metrics\n\nTracks scheduled signal activation and cancellation rates:\n\n| Metric | Formula | Purpose |\n|--------|---------|---------|\n| **Activation Rate** | `(totalOpened / totalScheduled) × 100` | Percentage of scheduled signals that activated |\n| **Cancellation Rate** | `(totalCancelled / totalScheduled) × 100` | Percentage of scheduled signals that timed out |\n| **Avg Activation Time** | `Σ(pendingAt - scheduledAt) / totalOpened / 60000` | Average minutes until activation |\n| **Avg Wait Time** | `Σ(closeTimestamp - scheduledAt) / totalCancelled / 60000` | Average minutes until cancellation |\n\n**Sources:** [src/lib/services/markdown/ScheduleMarkdownService.ts:290-351]()\n\n#### PerformanceMarkdownService Metrics\n\nProvides execution timing analysis per metric type:\n\n| Metric | Calculation | Interpretation |\n|--------|-------------|----------------|\n| **Count** | Number of events | Invocation frequency |\n| **Total Duration** | `Σ(duration)` | Total time spent (ms) |\n| **Avg Duration** | `Σ(duration) / count` | Mean execution time (ms) |\n| **Std Dev** | `√(Σ(d - avg)² / count)` | Timing consistency |\n| **Median** | 50th percentile | Typical execution time |\n| **P95 / P99** | 95th / 99th percentile | Worst-case latency |\n| **Avg Wait Time** | `Σ(timestamp - previousTimestamp) / count` | Time between events |\n\n**Sources:** [src/lib/services/markdown/PerformanceMarkdownService.ts:228-309]()\n\n#### HeatMarkdownService Portfolio Metrics\n\nAggregates symbol-level statistics with additional portfolio-wide calculations:\n\n- **Max Drawdown**: Largest peak-to-trough decline calculated from cumulative PNL curve\n- **Profit Factor**: `Σ(wins) / |Σ(losses)|` ratio\n- **Expectancy**: `(winRate × avgWin) - (lossRate × avgLoss)`\n- **Max Win/Loss Streak**: Consecutive winning/losing trades\n\n**Sources:** [src/lib/services/markdown/HeatMarkdownService.ts:180-336]()\n\n---\n\n## Column Configuration System\n\nEach markdown service defines a `Column` interface to configure table generation. Columns are filtered by visibility before rendering, allowing dynamic table layouts based on configuration.\n\n### Column Interface Structure\n\n```typescript\ninterface Column {\n  key: string;           // Unique identifier\n  label: string;         // Table header text\n  format: (data: T) => string;  // Data formatter\n  isVisible: () => boolean;     // Visibility predicate\n}\n```\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:20-29](), [src/lib/services/markdown/LiveMarkdownService.ts:142-151]()\n\n### Example: BacktestMarkdownService Columns\n\n```mermaid\ngraph TB\n    subgraph \"Column Definitions Array\"\n        C1[\"signalId: data.signal.id\"]\n        C2[\"symbol: data.signal.symbol\"]\n        C3[\"position: data.signal.position.toUpperCase()\"]\n        C4[\"note: toPlainString(data.signal.note)<br/>isVisible: CC_REPORT_SHOW_SIGNAL_NOTE\"]\n        C5[\"openPrice: data.signal.priceOpen.toFixed(8)\"]\n        C6[\"closePrice: data.currentPrice.toFixed(8)\"]\n        C7[\"pnl: data.pnl.pnlPercentage.toFixed(2)%\"]\n        C8[\"closeReason: data.closeReason\"]\n        C9[\"duration: (closeTime - openTime) / 60000\"]\n        C10[\"openTimestamp: new Date(pendingAt).toISOString()\"]\n        C11[\"closeTimestamp: new Date(closeTimestamp).toISOString()\"]\n    end\n    \n    subgraph \"Table Generation Process\"\n        FILTER[\"Filter columns<br/>visibleColumns = columns.filter(col => col.isVisible())\"]\n        HEADER[\"Build header<br/>header = visibleColumns.map(col => col.label)\"]\n        ROWS[\"Format rows<br/>rows = signals.map(signal =><br/>  visibleColumns.map(col => col.format(signal))\"]\n        TABLE[\"Assemble markdown<br/>| header1 | header2 |<br/>| --- | --- |<br/>| row1col1 | row1col2 |\"]\n    end\n    \n    C1 --> FILTER\n    C2 --> FILTER\n    C3 --> FILTER\n    C4 --> FILTER\n    C5 --> FILTER\n    \n    FILTER --> HEADER\n    FILTER --> ROWS\n    HEADER --> TABLE\n    ROWS --> TABLE\n```\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:108-194](), [src/lib/services/markdown/BacktestMarkdownService.ts:314-322]()\n\n### Dynamic Visibility Control\n\nThe `CC_REPORT_SHOW_SIGNAL_NOTE` configuration parameter controls note column visibility across all services:\n\n```typescript\n{\n  key: \"note\",\n  label: \"Note\",\n  format: (data) => toPlainString(data.note ?? \"N/A\"),\n  isVisible: () => GLOBAL_CONFIG.CC_REPORT_SHOW_SIGNAL_NOTE,\n}\n```\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:128-132](), [types.d.ts:108-114]()\n\n---\n\n## Event Subscription and Data Flow\n\nMarkdown services initialize lazily using `singleshot()` to subscribe to relevant event emitters only when first accessed. This prevents unnecessary event processing for unused services.\n\n### Initialization Pattern\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant BacktestDump as Backtest.dump()\n    participant Service as BacktestMarkdownService\n    participant Init as init() singleshot\n    participant Emitter as signalBacktestEmitter\n    participant Tick as tick() private\n    participant Storage as ReportStorage\n    \n    User->>BacktestDump: Call Backtest.dump(symbol, strategy)\n    BacktestDump->>Service: await dump(symbol, strategy)\n    Service->>Init: First access triggers init()\n    Init->>Emitter: subscribe(tick)\n    Note over Init,Emitter: Subscription established once\n    \n    loop Background Execution\n        Emitter->>Tick: Event: IStrategyTickResult\n        Tick->>Storage: addSignal(data) if closed\n        Storage->>Storage: Bounded append to _signalList\n    end\n    \n    Service->>Storage: getReport(strategyName)\n    Storage->>Service: Markdown string\n    Service->>User: Write to ./dump/backtest/\n```\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:564-567](), [src/lib/services/markdown/LiveMarkdownService.ts:771-774]()\n\n### Service-to-Emitter Mapping\n\n```mermaid\ngraph LR\n    subgraph \"Event Emitters\"\n        E1[\"signalBacktestEmitter<br/>Closed backtest signals\"]\n        E2[\"signalLiveEmitter<br/>All live tick types\"]\n        E3[\"signalEmitter<br/>All signals (live + backtest)\"]\n        E4[\"partialProfitSubject<br/>Profit milestones\"]\n        E5[\"partialLossSubject<br/>Loss milestones\"]\n        E6[\"walkerEmitter<br/>Strategy results\"]\n        E7[\"performanceEmitter<br/>Timing metrics\"]\n        E8[\"riskSubject<br/>Risk rejections\"]\n    end\n    \n    subgraph \"Markdown Services\"\n        S1[\"BacktestMarkdownService\"]\n        S2[\"LiveMarkdownService\"]\n        S3[\"ScheduleMarkdownService<br/>HeatMarkdownService\"]\n        S4[\"PartialMarkdownService\"]\n        S5[\"WalkerMarkdownService\"]\n        S6[\"PerformanceMarkdownService\"]\n        S7[\"RiskMarkdownService\"]\n    end\n    \n    E1 -->|\"subscribe(tick)\"| S1\n    E2 -->|\"subscribe(tick)\"| S2\n    E3 -->|\"subscribe(tick)\"| S3\n    E4 -->|\"subscribe(onProfit)\"| S4\n    E5 -->|\"subscribe(onLoss)\"| S4\n    E6 -->|\"subscribe(addResult)\"| S5\n    E7 -->|\"subscribe(addEvent)\"| S6\n    E8 -->|\"subscribe(addRejection)\"| S7\n```\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:566](), [src/lib/services/markdown/LiveMarkdownService.ts:773](), [src/lib/services/markdown/ScheduleMarkdownService.ts:620](), [src/lib/services/markdown/HeatMarkdownService.ts:519](), [src/lib/services/markdown/PartialMarkdownService.ts:363-364](), [src/lib/services/markdown/WalkerMarkdownService.ts:530](), [src/lib/services/markdown/PerformanceMarkdownService.ts:437](), [src/config/emitters.ts:1-133]()\n\n---\n\n## Public API Methods\n\nAll markdown services expose three core methods. These are typically accessed through facade classes like `Backtest`, `Live`, `Heat`, etc.\n\n### Method Signatures\n\n#### getData()\n\nRetrieves typed statistics object without generating markdown.\n\n```typescript\n// BacktestMarkdownService\npublic getData = async (\n  symbol: string,\n  strategyName: StrategyName\n): Promise<BacktestStatistics>\n\n// LiveMarkdownService  \npublic getData = async (\n  symbol: string,\n  strategyName: StrategyName\n): Promise<LiveStatistics>\n\n// HeatMarkdownService (strategy-wide)\npublic getData = async (\n  strategyName: StrategyName\n): Promise<IHeatmapStatistics>\n```\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:456-462](), [src/lib/services/markdown/LiveMarkdownService.ts:663-670](), [src/lib/services/markdown/HeatMarkdownService.ts:395-403]()\n\n#### getReport()\n\nGenerates markdown-formatted report string.\n\n```typescript\npublic getReport = async (\n  symbol: string,\n  strategyName: StrategyName\n): Promise<string>\n```\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:480-486](), [src/lib/services/markdown/LiveMarkdownService.ts:687-694]()\n\n#### dump()\n\nWrites markdown report to file system with automatic directory creation.\n\n```typescript\npublic dump = async (\n  symbol: string,\n  strategyName: StrategyName,\n  path = \"./dump/backtest\"  // Default path varies by service\n): Promise<void>\n```\n\n**Default Paths:**\n- `BacktestMarkdownService`: `./dump/backtest`\n- `LiveMarkdownService`: `./dump/live`\n- `ScheduleMarkdownService`: `./dump/schedule`\n- `HeatMarkdownService`: `./dump/heat`\n- `PartialMarkdownService`: `./dump/partial`\n- `WalkerMarkdownService`: `./dump/walker`\n- `PerformanceMarkdownService`: `./dump/performance`\n- `RiskMarkdownService`: `./dump/risk`\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:509-521](), [src/lib/services/markdown/LiveMarkdownService.ts:716-728]()\n\n### Facade Access Pattern\n\n```mermaid\ngraph TB\n    subgraph \"Public Facades\"\n        BT_F[\"Backtest class<br/>static getData(symbol, strategy)<br/>static getReport(symbol, strategy)<br/>static dump(symbol, strategy)\"]\n        LV_F[\"Live class<br/>static getData(symbol, strategy)<br/>static getReport(symbol, strategy)<br/>static dump(symbol, strategy)\"]\n        HT_F[\"Heat class<br/>static getData(strategy)<br/>static getReport(strategy)<br/>static dump(strategy)\"]\n    end\n    \n    subgraph \"Service Layer (DI)\"\n        BT_SRV[\"BacktestMarkdownService<br/>injected from TYPES.backtestMarkdownService\"]\n        LV_SRV[\"LiveMarkdownService<br/>injected from TYPES.liveMarkdownService\"]\n        HT_SRV[\"HeatMarkdownService<br/>injected from TYPES.heatMarkdownService\"]\n    end\n    \n    subgraph \"File System Output\"\n        BT_FILE[\"./dump/backtest/{strategy}.md\"]\n        LV_FILE[\"./dump/live/{strategy}.md\"]\n        HT_FILE[\"./dump/heat/{strategy}.md\"]\n    end\n    \n    BT_F -->|\"Delegate to\"| BT_SRV\n    LV_F -->|\"Delegate to\"| LV_SRV\n    HT_F -->|\"Delegate to\"| HT_SRV\n    \n    BT_SRV -->|\"dump() writes to\"| BT_FILE\n    LV_SRV -->|\"dump() writes to\"| LV_FILE\n    HT_SRV -->|\"dump() writes to\"| HT_FILE\n```\n\n**Sources:** [src/classes/Backtest.ts:1-200](), [src/classes/Live.ts:1-200](), [src/classes/Heat.ts:1-150]()\n\n---\n\n## Memory Management and Bounds\n\nMarkdown services implement bounded queues using `MAX_EVENTS` constants to prevent unbounded memory growth during long-running executions. Events are stored in FIFO order with `unshift()` for insertion and `pop()` for eviction.\n\n### Bounded Queue Implementation\n\n```typescript\n// Example from BacktestMarkdownService ReportStorage\npublic addSignal(data: IStrategyTickResultClosed) {\n  this._signalList.unshift(data);\n\n  // Trim queue if exceeded MAX_EVENTS\n  if (this._signalList.length > MAX_EVENTS) {\n    this._signalList.pop();\n  }\n}\n```\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:212-219]()\n\n### MAX_EVENTS by Service\n\n| Service | MAX_EVENTS | Scope | Notes |\n|---------|-----------|-------|-------|\n| `BacktestMarkdownService` | 250 | Per symbol:strategy | Closed signals only |\n| `LiveMarkdownService` | 250 | Per symbol:strategy | All tick types (idle replaced) |\n| `ScheduleMarkdownService` | 250 | Per symbol:strategy | Scheduled/opened/cancelled |\n| `HeatMarkdownService` | 250 | Per symbol within strategy | Signals per symbol |\n| `PartialMarkdownService` | 250 | Per symbol:strategy | Profit/loss milestones |\n| `PerformanceMarkdownService` | 10000 | Per symbol:strategy | High-frequency timing events |\n| `WalkerMarkdownService` | Unbounded | N/A | Complete strategy list needed |\n| `RiskMarkdownService` | Unbounded | N/A | All rejections tracked |\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:197](), [src/lib/services/markdown/LiveMarkdownService.ts:258](), [src/lib/services/markdown/ScheduleMarkdownService.ts:187](), [src/lib/services/markdown/HeatMarkdownService.ts:141](), [src/lib/services/markdown/PartialMarkdownService.ts:141](), [src/lib/services/markdown/PerformanceMarkdownService.ts:199]()\n\n### Special Case: LiveMarkdownService Idle Event Replacement\n\n`LiveMarkdownService` implements intelligent idle event consolidation to prevent queue saturation from repetitive idle ticks:\n\n```typescript\npublic addIdleEvent(currentPrice: number) {\n  const newEvent: TickEvent = {\n    timestamp: Date.now(),\n    action: \"idle\",\n    currentPrice,\n  };\n\n  // Find last idle event index\n  const lastIdleIndex = this._eventList.findLastIndex(\n    (event) => event.action === \"idle\"\n  );\n\n  // Replace last idle if no opened/active events occurred after it\n  const canReplaceLastIdle = lastIdleIndex !== -1 &&\n    !this._eventList\n      .slice(lastIdleIndex + 1)\n      .some((event) => event.action === \"opened\" || event.action === \"active\");\n\n  if (canReplaceLastIdle) {\n    this._eventList[lastIdleIndex] = newEvent;\n    return;\n  }\n  \n  // Otherwise append normally\n  this._eventList.unshift(newEvent);\n  if (this._eventList.length > MAX_EVENTS) {\n    this._eventList.pop();\n  }\n}\n```\n\n**Sources:** [src/lib/services/markdown/LiveMarkdownService.ts:274-300]()\n\n---\n\n## Report Output Format\n\nAll markdown services generate standardized reports with:\n1. Title header (`# Service Report: {strategyName}`)\n2. Metadata section (symbol, exchange, frame where applicable)\n3. Markdown table with filtered columns\n4. Summary statistics section\n5. Interpretive notes (e.g., \"higher is better\" annotations)\n\n### Example: Backtest Report Structure\n\n```markdown\n# Backtest Report: my-strategy\n\n| Signal ID | Symbol | Position | Open Price | Close Price | PNL (net) | Close Reason | Duration (min) | Open Time | Close Time |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| abc-123 | BTCUSDT | LONG | 42000.00000000 USD | 43000.00000000 USD | +2.38% | take_profit | 45 | 2024-01-01T00:00:00.000Z | 2024-01-01T00:45:00.000Z |\n\n**Total signals:** 100\n**Closed signals:** 100\n**Win rate:** 65.00% (65W / 35L) (higher is better)\n**Average PNL:** +1.25% (higher is better)\n**Total PNL:** +125.00% (higher is better)\n**Standard Deviation:** 2.345% (lower is better)\n**Sharpe Ratio:** 0.533 (higher is better)\n**Annualized Sharpe Ratio:** 10.181 (higher is better)\n**Certainty Ratio:** 1.850 (higher is better)\n**Expected Yearly Returns:** +456.25% (higher is better)\n```\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:303-339]()\n\n### Example: Walker Comparison Report\n\n```markdown\n# Walker Comparison Report: my-walker\n\n**Symbol:** BTCUSDT\n**Exchange:** binance\n**Frame:** 1d-backtest\n**Optimization Metric:** sharpeRatio\n**Strategies Tested:** 5\n\n## Best Strategy: strategy-alpha\n\n**Best sharpeRatio:** 0.85\n**Total Signals:** 120\n\n## Strategy Comparison (Top 10)\n\n| Rank | Strategy | sharpeRatio | Total Signals | Win Rate | Avg PNL | Total PNL | Sharpe Ratio | Std Dev |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| 1 | strategy-alpha | 0.85 | 120 | 68.33% | +1.40% | +168.00% | 0.850 | 1.647% |\n| 2 | strategy-beta | 0.72 | 115 | 63.48% | +1.20% | +138.00% | 0.720 | 1.667% |\n\n## PNL Table (All Signals)\n\n| Strategy | Signal ID | Symbol | Position | PNL (net) | Close Reason | Open Time | Close Time |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| strategy-alpha | xyz-789 | BTCUSDT | LONG | +2.50% | take_profit | 2024-01-01T00:00:00.000Z | 2024-01-01T01:00:00.000Z |\n```\n\n**Sources:** [src/lib/services/markdown/WalkerMarkdownService.ts:430-500]()\n\n---\n\n## Clear API for Data Reset\n\nAll markdown services provide a `clear()` method to reset accumulated data. This is primarily used in testing to ensure test isolation, but can also be used to reset statistics during live execution.\n\n### Clear Method Signature\n\n```typescript\npublic clear = async (ctx?: { \n  symbol: string; \n  strategyName: StrategyName \n}) => {\n  if (ctx) {\n    const key = `${ctx.symbol}:${ctx.strategyName}`;\n    this.getStorage.clear(key);\n  } else {\n    this.getStorage.clear();\n  }\n}\n```\n\n**Behavior:**\n- **With context**: Clears only the specified symbol:strategy pair\n- **Without context**: Clears all accumulated data across all keys\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:541-551](), [src/lib/services/markdown/LiveMarkdownService.ts:748-758]()\n\n---\n\n## Integration with Execution Pipeline\n\n```mermaid\ngraph TB\n    subgraph \"Execution Layer\"\n        BT_RUN[\"Backtest.run()<br/>Generator yields signals\"]\n        LV_RUN[\"Live.run()<br/>Generator yields signals\"]\n    end\n    \n    subgraph \"Event Emission Layer\"\n        EMIT_BT[\"signalBacktestEmitter.next(result)<br/>After tick() returns closed\"]\n        EMIT_LV[\"signalLiveEmitter.next(result)<br/>After tick() returns any\"]\n        EMIT_PERF[\"performanceEmitter.next(metrics)<br/>After operations complete\"]\n        EMIT_RISK[\"riskSubject.next(rejection)<br/>When validation fails\"]\n    end\n    \n    subgraph \"Markdown Services Layer\"\n        SRV_BT[\"BacktestMarkdownService<br/>tick() filters closed<br/>addSignal() to storage\"]\n        SRV_LV[\"LiveMarkdownService<br/>tick() processes all<br/>addEvent() to storage\"]\n        SRV_PERF[\"PerformanceMarkdownService<br/>addEvent() accumulates metrics\"]\n        SRV_RISK[\"RiskMarkdownService<br/>addRejection() tracks failures\"]\n    end\n    \n    subgraph \"Storage Layer\"\n        STORE[\"ReportStorage instances<br/>Memoized per symbol:strategy<br/>Bounded by MAX_EVENTS\"]\n    end\n    \n    subgraph \"Report Access Layer\"\n        API_GET[\"getData() methods<br/>Calculate statistics<br/>Return typed objects\"]\n        API_REP[\"getReport() methods<br/>Format markdown tables<br/>Return strings\"]\n        API_DUMP[\"dump() methods<br/>Write to ./dump/<br/>Create directories\"]\n    end\n    \n    BT_RUN -->|\"Closed signals\"| EMIT_BT\n    LV_RUN -->|\"All tick types\"| EMIT_LV\n    BT_RUN -->|\"Execution timing\"| EMIT_PERF\n    BT_RUN -->|\"Risk rejections\"| EMIT_RISK\n    \n    EMIT_BT -->|\"subscribe()\"| SRV_BT\n    EMIT_LV -->|\"subscribe()\"| SRV_LV\n    EMIT_PERF -->|\"subscribe()\"| SRV_PERF\n    EMIT_RISK -->|\"subscribe()\"| SRV_RISK\n    \n    SRV_BT -->|\"addSignal()\"| STORE\n    SRV_LV -->|\"addEvent()\"| STORE\n    SRV_PERF -->|\"addEvent()\"| STORE\n    SRV_RISK -->|\"addRejection()\"| STORE\n    \n    STORE -->|\"Read from\"| API_GET\n    STORE -->|\"Read from\"| API_REP\n    API_REP -->|\"Write to disk\"| API_DUMP\n```\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:428-439](), [src/lib/services/markdown/LiveMarkdownService.ts:630-646](), [src/lib/services/markdown/PerformanceMarkdownService.ts:410-419](), [src/config/emitters.ts:19-131]()"
                    },
                    {
                        "page_plan": {
                            "id": "8.1",
                            "title": "Markdown Report System"
                        },
                        "content": "# Markdown Report System\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [src/lib/services/markdown/BacktestMarkdownService.ts](src/lib/services/markdown/BacktestMarkdownService.ts)\n- [src/lib/services/markdown/HeatMarkdownService.ts](src/lib/services/markdown/HeatMarkdownService.ts)\n- [src/lib/services/markdown/LiveMarkdownService.ts](src/lib/services/markdown/LiveMarkdownService.ts)\n- [src/lib/services/markdown/PartialMarkdownService.ts](src/lib/services/markdown/PartialMarkdownService.ts)\n- [src/lib/services/markdown/PerformanceMarkdownService.ts](src/lib/services/markdown/PerformanceMarkdownService.ts)\n- [src/lib/services/markdown/ScheduleMarkdownService.ts](src/lib/services/markdown/ScheduleMarkdownService.ts)\n- [src/lib/services/markdown/WalkerMarkdownService.ts](src/lib/services/markdown/WalkerMarkdownService.ts)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThe Markdown Report System provides comprehensive analytics and reporting capabilities for trading strategy execution. This system consists of 9 specialized markdown services that subscribe to event emitters, accumulate trading data, calculate statistical metrics, and generate human-readable markdown reports. Each service focuses on a specific aspect of strategy performance (backtest results, live trading, scheduled signals, strategy comparison, performance profiling, portfolio heatmaps, partial P/L tracking, risk rejections, and system configuration).\n\nFor information about the event system that feeds these reports, see [Event-Driven Architecture](#2.3). For statistics interface types exported from these services, see [Performance Statistics](#8.2).\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:1-571](), [src/lib/services/markdown/LiveMarkdownService.ts:1-778](), [src/lib/services/markdown/WalkerMarkdownService.ts:1-644]()\n\n---\n\n## System Architecture Overview\n\n```mermaid\ngraph TB\n    subgraph \"Event Emitters\"\n        SIGNAL_BACKTEST[\"signalBacktestEmitter\"]\n        SIGNAL_LIVE[\"signalLiveEmitter\"]\n        SIGNAL_ALL[\"signalEmitter\"]\n        WALKER_EMIT[\"walkerEmitter\"]\n        PERFORMANCE_EMIT[\"performanceEmitter\"]\n        PARTIAL_PROFIT[\"partialProfitSubject\"]\n        PARTIAL_LOSS[\"partialLossSubject\"]\n        RISK_SUBJECT[\"riskSubject\"]\n    end\n    \n    subgraph \"Markdown Services\"\n        BACKTEST_MD[\"BacktestMarkdownService\"]\n        LIVE_MD[\"LiveMarkdownService\"]\n        SCHEDULE_MD[\"ScheduleMarkdownService\"]\n        WALKER_MD[\"WalkerMarkdownService\"]\n        PERFORMANCE_MD[\"PerformanceMarkdownService\"]\n        HEAT_MD[\"HeatMarkdownService\"]\n        PARTIAL_MD[\"PartialMarkdownService\"]\n        RISK_MD[\"RiskMarkdownService\"]\n        OUTLINE_MD[\"OutlineMarkdownService\"]\n    end\n    \n    subgraph \"ReportStorage Pattern\"\n        STORAGE[\"ReportStorage Class\"]\n        MEMOIZE[\"Memoized getStorage()\"]\n        EVENTS[\"_eventList / _signalList\"]\n    end\n    \n    subgraph \"Public API Methods\"\n        GET_DATA[\"getData()\"]\n        GET_REPORT[\"getReport()\"]\n        DUMP[\"dump()\"]\n        CLEAR[\"clear()\"]\n    end\n    \n    subgraph \"Output Files\"\n        BACKTEST_FILE[\"./dump/backtest/*.md\"]\n        LIVE_FILE[\"./dump/live/*.md\"]\n        WALKER_FILE[\"./dump/walker/*.md\"]\n        PERFORMANCE_FILE[\"./dump/performance/*.md\"]\n        HEAT_FILE[\"./dump/heatmap/*.md\"]\n    end\n    \n    SIGNAL_BACKTEST --> BACKTEST_MD\n    SIGNAL_LIVE --> LIVE_MD\n    SIGNAL_ALL --> SCHEDULE_MD\n    SIGNAL_ALL --> HEAT_MD\n    WALKER_EMIT --> WALKER_MD\n    PERFORMANCE_EMIT --> PERFORMANCE_MD\n    PARTIAL_PROFIT --> PARTIAL_MD\n    PARTIAL_LOSS --> PARTIAL_MD\n    RISK_SUBJECT --> RISK_MD\n    \n    BACKTEST_MD --> STORAGE\n    LIVE_MD --> STORAGE\n    SCHEDULE_MD --> STORAGE\n    WALKER_MD --> STORAGE\n    PERFORMANCE_MD --> STORAGE\n    HEAT_MD --> STORAGE\n    PARTIAL_MD --> STORAGE\n    \n    STORAGE --> MEMOIZE\n    STORAGE --> EVENTS\n    \n    BACKTEST_MD --> GET_DATA\n    BACKTEST_MD --> GET_REPORT\n    BACKTEST_MD --> DUMP\n    BACKTEST_MD --> CLEAR\n    \n    DUMP --> BACKTEST_FILE\n    DUMP --> LIVE_FILE\n    DUMP --> WALKER_FILE\n    DUMP --> PERFORMANCE_FILE\n    DUMP --> HEAT_FILE\n```\n\nThe system implements a consistent **ReportStorage Pattern** across all 9 markdown services. Each service subscribes to specific event emitters, accumulates data in memoized storage instances, and provides three primary methods: `getData()` for retrieving statistics objects, `getReport()` for generating markdown strings, and `dump()` for saving reports to the filesystem.\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:396-571](), [src/lib/services/markdown/LiveMarkdownService.ts:596-778](), [src/config/emitters.ts:1-133]()\n\n---\n\n## Markdown Service Catalog\n\n### Service Overview Table\n\n| Service | Event Source | Storage Key | MAX_EVENTS | Default Path | Primary Metric |\n|---------|-------------|-------------|------------|--------------|----------------|\n| `BacktestMarkdownService` | `signalBacktestEmitter` | `symbol:strategyName` | 250 | `./dump/backtest` | Closed signals only |\n| `LiveMarkdownService` | `signalLiveEmitter` | `symbol:strategyName` | 250 | `./dump/live` | All tick types |\n| `ScheduleMarkdownService` | `signalEmitter` | `symbol:strategyName` | 250 | `./dump/schedule` | Scheduled/cancelled |\n| `WalkerMarkdownService` | `walkerEmitter` | `walkerName` | Unbounded | `./dump/walker` | Strategy comparison |\n| `PerformanceMarkdownService` | `performanceEmitter` | `symbol:strategyName` | 10000 | `./dump/performance` | Execution metrics |\n| `HeatMarkdownService` | `signalEmitter` | `strategyName` | 250 per symbol | `./dump/heatmap` | Portfolio-wide stats |\n| `PartialMarkdownService` | `partialProfitSubject` + `partialLossSubject` | `symbol:strategyName` | 250 | `./dump/partial` | Milestone events |\n| `RiskMarkdownService` | `riskSubject` | `symbol:strategyName` | Unbounded | `./dump/risk` | Risk rejections |\n| `OutlineMarkdownService` | N/A (direct query) | N/A | N/A | `./dump/outline` | System configuration |\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:197-198](), [src/lib/services/markdown/LiveMarkdownService.ts:258](), [src/lib/services/markdown/PerformanceMarkdownService.ts:199]()\n\n---\n\n## ReportStorage Pattern Architecture\n\n```mermaid\ngraph TB\n    subgraph \"Markdown Service Class\"\n        LOGGER[\"loggerService: LoggerService\"]\n        GET_STORAGE[\"getStorage = memoize()\"]\n        INIT[\"init = singleshot()\"]\n        TICK[\"tick()\"]\n        PUBLIC_GET_DATA[\"getData()\"]\n        PUBLIC_GET_REPORT[\"getReport()\"]\n        PUBLIC_DUMP[\"dump()\"]\n        PUBLIC_CLEAR[\"clear()\"]\n    end\n    \n    subgraph \"ReportStorage Class\"\n        EVENT_LIST[\"_eventList: Array\"]\n        ADD_METHOD[\"addSignal() / addEvent()\"]\n        CALC_STATS[\"getData(): Statistics\"]\n        GEN_REPORT[\"getReport(): string\"]\n        SAVE_REPORT[\"dump(): void\"]\n    end\n    \n    subgraph \"Column Configuration\"\n        COLUMNS[\"columns: Column[]\"]\n        COL_KEY[\"key: string\"]\n        COL_LABEL[\"label: string\"]\n        COL_FORMAT[\"format: (data) => string\"]\n        COL_VISIBLE[\"isVisible: () => boolean\"]\n    end\n    \n    subgraph \"Statistics Interface\"\n        STAT_LIST[\"eventList / signalList\"]\n        STAT_TOTAL[\"totalEvents / totalSignals\"]\n        STAT_METRICS[\"winRate, avgPnl, sharpeRatio, etc\"]\n    end\n    \n    INIT --> TICK\n    GET_STORAGE --> EVENT_LIST\n    TICK --> ADD_METHOD\n    ADD_METHOD --> EVENT_LIST\n    \n    PUBLIC_GET_DATA --> CALC_STATS\n    PUBLIC_GET_REPORT --> GEN_REPORT\n    PUBLIC_DUMP --> SAVE_REPORT\n    PUBLIC_CLEAR --> GET_STORAGE\n    \n    CALC_STATS --> STAT_LIST\n    CALC_STATS --> STAT_TOTAL\n    CALC_STATS --> STAT_METRICS\n    \n    GEN_REPORT --> COLUMNS\n    COLUMNS --> COL_KEY\n    COLUMNS --> COL_LABEL\n    COLUMNS --> COL_FORMAT\n    COLUMNS --> COL_VISIBLE\n    \n    SAVE_REPORT --> GEN_REPORT\n```\n\n### Pattern Components\n\n**1. Service Initialization**\n\nAll markdown services use `singleshot` from `functools-kit` to ensure event subscription happens exactly once:\n\n```typescript\nprotected init = singleshot(async () => {\n  this.loggerService.log(\"backtestMarkdownService init\");\n  signalBacktestEmitter.subscribe(this.tick);\n});\n```\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:564-567](), [src/lib/services/markdown/LiveMarkdownService.ts:771-774]()\n\n**2. Memoized Storage**\n\nServices use `memoize` to create and cache `ReportStorage` instances per key (typically `symbol:strategyName`):\n\n```typescript\nprivate getStorage = memoize<(symbol: string, strategyName: string) => ReportStorage>(\n  ([symbol, strategyName]) => `${symbol}:${strategyName}`,\n  () => new ReportStorage()\n);\n```\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:404-407](), [src/lib/services/markdown/LiveMarkdownService.ts:604-607]()\n\n**3. Event Accumulation**\n\nThe `ReportStorage` class maintains an internal event array with bounds checking:\n\n```typescript\npublic addSignal(data: IStrategyTickResultClosed) {\n  this._signalList.unshift(data);\n  \n  // Trim queue if exceeded MAX_EVENTS\n  if (this._signalList.length > MAX_EVENTS) {\n    this._signalList.pop();\n  }\n}\n```\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:212-219](), [src/lib/services/markdown/LiveMarkdownService.ts:296-300]()\n\n**4. Column-Based Table Generation**\n\nReports use column configurations to dynamically build markdown tables:\n\n```typescript\ninterface Column {\n  key: string;\n  label: string;\n  format: (data: IStrategyTickResultClosed) => string;\n  isVisible: () => boolean;\n}\n```\n\nTables respect `CC_REPORT_SHOW_SIGNAL_NOTE` configuration for conditional column visibility.\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:20-29](), [src/lib/services/markdown/LiveMarkdownService.ts:142-151](), [src/config/params.ts:113-114]()\n\n---\n\n## Event Flow and Data Accumulation\n\n```mermaid\nsequenceDiagram\n    participant Strategy as \"ClientStrategy\"\n    participant Emitter as \"signalBacktestEmitter\"\n    participant Service as \"BacktestMarkdownService\"\n    participant Storage as \"ReportStorage\"\n    participant FS as \"File System\"\n    \n    Note over Service: init() called on first use\n    Service->>Emitter: subscribe(this.tick)\n    \n    Strategy->>Emitter: emit(closedSignal)\n    Emitter->>Service: tick(closedSignal)\n    Service->>Service: getStorage(symbol, strategyName)\n    Service->>Storage: addSignal(closedSignal)\n    Storage->>Storage: _signalList.unshift(data)\n    Storage->>Storage: Check MAX_EVENTS (250)\n    Storage->>Storage: _signalList.pop() if needed\n    \n    Note over Service: User requests report\n    Service->>Storage: getData()\n    Storage->>Storage: Calculate statistics\n    Storage-->>Service: BacktestStatistics\n    \n    Service->>Storage: getReport()\n    Storage->>Storage: Generate markdown tables\n    Storage-->>Service: markdown string\n    \n    Service->>Storage: dump()\n    Storage->>FS: writeFile(filepath, markdown)\n    FS-->>Storage: Success\n```\n\n### Memory Management Strategy\n\nEach markdown service implements bounded queues to prevent memory leaks:\n\n1. **MAX_EVENTS Constant**: Defines maximum events per storage instance\n2. **FIFO Queue**: New events added to front with `unshift()`, old events removed from back with `pop()`\n3. **Per-Key Isolation**: Each `symbol:strategyName` combination gets its own storage instance\n\n**Exception**: `WalkerMarkdownService` and `RiskMarkdownService` do not enforce MAX_EVENTS bounds because they aggregate across strategy runs and need complete data.\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:197](), [src/lib/services/markdown/PerformanceMarkdownService.ts:199](), [src/lib/services/markdown/WalkerMarkdownService.ts:519-644]()\n\n---\n\n## Statistics Calculation\n\n### Backtest and Live Statistics\n\nBoth `BacktestMarkdownService` and `LiveMarkdownService` calculate identical metrics:\n\n```mermaid\ngraph LR\n    INPUT[\"Closed Signals Array\"]\n    \n    BASIC[\"Basic Stats<br/>totalSignals<br/>winCount<br/>lossCount<br/>winRate\"]\n    \n    PNL[\"P&L Metrics<br/>avgPnl<br/>totalPnl<br/>avgWin<br/>avgLoss\"]\n    \n    RISK[\"Risk Metrics<br/>stdDev<br/>sharpeRatio<br/>annualizedSharpeRatio<br/>certaintyRatio\"]\n    \n    RETURN[\"Return Projection<br/>avgDuration<br/>tradesPerYear<br/>expectedYearlyReturns\"]\n    \n    INPUT --> BASIC\n    INPUT --> PNL\n    INPUT --> RISK\n    INPUT --> RETURN\n    \n    BASIC --> OUTPUT[\"Statistics Interface\"]\n    PNL --> OUTPUT\n    RISK --> OUTPUT\n    RETURN --> OUTPUT\n```\n\n**Key Formulas:**\n\n| Metric | Formula | Description |\n|--------|---------|-------------|\n| Win Rate | `(winCount / totalSignals) * 100` | Percentage of profitable trades |\n| Sharpe Ratio | `avgPnl / stdDev` | Risk-adjusted return |\n| Annualized Sharpe | `sharpeRatio * √365` | Yearly scaled Sharpe ratio |\n| Certainty Ratio | `avgWin / \\|avgLoss\\|` | Average win to average loss ratio |\n| Expected Yearly Returns | `avgPnl * (365 / avgDurationDays)` | Projected annual return |\n\n**Safe Math**: All statistics apply `isUnsafe()` checks to return `null` for `NaN`, `Infinity`, or invalid numeric values.\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:227-295](), [src/lib/services/markdown/LiveMarkdownService.ts:409-492]()\n\n---\n\n## Report-Specific Implementations\n\n### BacktestMarkdownService\n\n**Purpose**: Track closed signals from backtest execution, calculate performance statistics.\n\n**Event Source**: `signalBacktestEmitter` (filtered to `action === \"closed\"`)\n\n**Storage Key**: `symbol:strategyName`\n\n**Output Example**:\n```markdown\n# Backtest Report: my-strategy\n\n| Signal ID | Symbol | Position | Open Price | Close Price | PNL (net) | Close Reason | Duration (min) |\n|-----------|--------|----------|------------|-------------|-----------|--------------|----------------|\n| abc-123   | BTCUSDT| LONG     | 50000 USD  | 52000 USD   | +3.60%    | take_profit  | 120            |\n\n**Total signals:** 45\n**Win rate:** 62.22% (28W / 17L) (higher is better)\n**Average PNL:** +1.25% (higher is better)\n**Sharpe Ratio:** 1.523 (higher is better)\n```\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:303-340]()\n\n---\n\n### LiveMarkdownService\n\n**Purpose**: Track all tick events (idle, opened, active, closed) from live trading execution.\n\n**Event Source**: `signalLiveEmitter` (all action types)\n\n**Storage Key**: `symbol:strategyName`\n\n**Unique Features**:\n- Tracks idle events (replaces last idle if no opened/active events follow)\n- Tracks active events (replaces last active for same signalId)\n- Provides comprehensive live monitoring view\n\n**Output Example**:\n```markdown\n# Live Trading Report: my-strategy\n\n| Timestamp | Action | Symbol | Signal ID | Position | Current Price | % to TP | % to SL |\n|-----------|--------|--------|-----------|----------|---------------|---------|---------|\n| 2024-... | ACTIVE | BTCUSDT| abc-123   | LONG     | 51500 USD     | +45.5%  | -12.3%  |\n| 2024-... | OPENED | BTCUSDT| abc-123   | LONG     | 50000 USD     | N/A     | N/A     |\n| 2024-... | IDLE   | BTCUSDT| N/A       | N/A      | 49800 USD     | N/A     | N/A     |\n\n**Total events:** 123\n**Closed signals:** 12\n**Win rate:** 58.33%\n```\n\n**Sources:** [src/lib/services/markdown/LiveMarkdownService.ts:500-537]()\n\n---\n\n### ScheduleMarkdownService\n\n**Purpose**: Track scheduled signals and their activation/cancellation status.\n\n**Event Source**: `signalEmitter` (filtered to `scheduled`, `opened`, `cancelled`)\n\n**Storage Key**: `symbol:strategyName`\n\n**Unique Logic**: Only tracks opened signals that were previously scheduled (checks `scheduledAt !== pendingAt`)\n\n**Statistics Computed**:\n- `activationRate`: Percentage of scheduled signals that opened\n- `cancellationRate`: Percentage of scheduled signals that cancelled\n- `avgActivationTime`: Average wait time for successful activations\n- `avgWaitTime`: Average wait time for cancelled signals\n\n**Sources:** [src/lib/services/markdown/ScheduleMarkdownService.ts:290-352](), [src/lib/services/markdown/ScheduleMarkdownService.ts:472-490]()\n\n---\n\n### WalkerMarkdownService\n\n**Purpose**: Aggregate backtest results across multiple strategies for comparison.\n\n**Event Source**: `walkerEmitter` (progress events from `WalkerLogicPrivateService`)\n\n**Storage Key**: `walkerName` (not per-symbol, aggregates all strategies)\n\n**Unique Features**:\n- Unbounded storage (no MAX_EVENTS limit)\n- Tracks best strategy by metric value\n- Generates comparison table sorted by metric\n- Includes PNL table with all signals from all strategies\n\n**Output Structure**:\n```markdown\n# Walker Comparison Report: my-walker\n\n**Best Strategy:** strategy-A\n**Best sharpeRatio:** 2.15\n\n## Top Strategies Comparison\n\n| Rank | Strategy | sharpeRatio | Total Signals | Win Rate | Avg PNL |\n|------|----------|-------------|---------------|----------|---------|\n| 1    | strategy-A | 2.15      | 45            | 62.22%   | +1.25%  |\n| 2    | strategy-B | 1.89      | 38            | 57.89%   | +0.98%  |\n\n## All Signals (PNL Table)\n\n| Strategy | Signal ID | Symbol | Position | PNL (net) | Close Reason |\n|----------|-----------|--------|----------|-----------|--------------|\n| ...      | ...       | ...    | ...      | ...       | ...          |\n```\n\n**Sources:** [src/lib/services/markdown/WalkerMarkdownService.ts:430-467]()\n\n---\n\n### PerformanceMarkdownService\n\n**Purpose**: Profile execution performance with metrics like duration, percentiles, and wait times.\n\n**Event Source**: `performanceEmitter`\n\n**Storage Key**: `symbol:strategyName`\n\n**MAX_EVENTS**: 10000 (higher than other services to capture statistical significance)\n\n**Unique Features**:\n- Groups events by `metricType` (e.g., \"getCandles\", \"tick\", \"backtest\")\n- Calculates percentiles (P95, P99) for latency analysis\n- Tracks wait times between consecutive events of same type\n- Sorts metrics by `totalDuration` to highlight bottlenecks\n\n**Statistics Computed**:\n\n| Metric | Description |\n|--------|-------------|\n| `count` | Number of samples |\n| `totalDuration` | Sum of all durations (ms) |\n| `avgDuration` | Mean duration (ms) |\n| `minDuration` | Minimum duration (ms) |\n| `maxDuration` | Maximum duration (ms) |\n| `stdDev` | Standard deviation (ms) |\n| `median` | 50th percentile (ms) |\n| `p95` | 95th percentile (ms) |\n| `p99` | 99th percentile (ms) |\n| `avgWaitTime` | Average interval between events (ms) |\n\n**Sources:** [src/lib/services/markdown/PerformanceMarkdownService.ts:228-309](), [src/lib/services/markdown/PerformanceMarkdownService.ts:317-366]()\n\n---\n\n### HeatMarkdownService\n\n**Purpose**: Generate portfolio-wide heatmap showing per-symbol statistics and aggregated portfolio metrics.\n\n**Event Source**: `signalEmitter` (filtered to `action === \"closed\"`)\n\n**Storage Key**: `strategyName` (aggregates across all symbols)\n\n**Unique Features**:\n- Groups closed signals by symbol\n- Calculates per-symbol statistics\n- Computes portfolio-wide metrics weighted by trade count\n- Sorts symbols by Sharpe ratio (best performers first)\n\n**Per-Symbol Statistics**:\n- Total PNL, Sharpe Ratio, Max Drawdown\n- Profit Factor (sum wins / sum losses)\n- Expectancy (weighted average of avg win/loss by win rate)\n- Win/Loss Streaks\n\n**Portfolio Statistics**:\n- `portfolioTotalPnl`: Sum of all symbols' total PNL\n- `portfolioSharpeRatio`: Trade-count weighted average of Sharpe ratios\n- `portfolioTotalTrades`: Total trades across all symbols\n\n**Sources:** [src/lib/services/markdown/HeatMarkdownService.ts:180-336](), [src/lib/services/markdown/HeatMarkdownService.ts:343-395]()\n\n---\n\n### PartialMarkdownService\n\n**Purpose**: Track profit/loss milestone events (10%, 20%, 30%, etc) for active signals.\n\n**Event Sources**: `partialProfitSubject`, `partialLossSubject`\n\n**Storage Key**: `symbol:strategyName`\n\n**Event Data**:\n- `action`: \"profit\" or \"loss\"\n- `level`: PartialLevel (10, 20, 30, 40, 50, 60, 70, 80, 90, 100)\n- `symbol`, `strategyName`, `signalId`, `position`\n- `currentPrice`, `timestamp`, `backtest` flag\n\n**Statistics Computed**:\n- `totalEvents`: Total milestone events\n- `totalProfit`: Count of profit milestone events\n- `totalLoss`: Count of loss milestone events\n\n**Sources:** [src/lib/services/markdown/PartialMarkdownService.ts:222-241](), [src/lib/services/markdown/PartialMarkdownService.ts:353-373]()\n\n---\n\n## Column Configuration System\n\n```mermaid\ngraph TB\n    COLUMNS[\"columns: Column[]\"]\n    \n    KEY[\"key: string<br/>Unique identifier\"]\n    LABEL[\"label: string<br/>Table header\"]\n    FORMAT[\"format: (data) => string<br/>Cell formatting\"]\n    VISIBLE[\"isVisible: () => boolean<br/>Conditional display\"]\n    \n    COLUMNS --> KEY\n    COLUMNS --> LABEL\n    COLUMNS --> FORMAT\n    COLUMNS --> VISIBLE\n    \n    VISIBLE --> GLOBAL_CONFIG[\"GLOBAL_CONFIG.CC_REPORT_SHOW_SIGNAL_NOTE\"]\n    \n    FORMAT --> HELPERS[\"toPlainString()<br/>str() formatter<br/>toFixed() precision\"]\n    \n    TABLE_GEN[\"Table Generation\"]\n    COLUMNS --> TABLE_GEN\n    \n    TABLE_GEN --> FILTER[\"Filter visible columns\"]\n    TABLE_GEN --> HEADER[\"Build header row\"]\n    TABLE_GEN --> SEPARATOR[\"Build separator row\"]\n    TABLE_GEN --> ROWS[\"Map data through formatters\"]\n    TABLE_GEN --> MARKDOWN[\"Join with | delimiters\"]\n```\n\n### Column Interface\n\n```typescript\ninterface Column {\n  key: string;           // Unique identifier\n  label: string;         // Display header\n  format: (data) => string;  // Cell formatter\n  isVisible: () => boolean;  // Conditional visibility\n}\n```\n\n### Example Column Definitions\n\n**BacktestMarkdownService** includes columns for signal details:\n\n```typescript\n{\n  key: \"pnl\",\n  label: \"PNL (net)\",\n  format: (data) => {\n    const pnlPercentage = data.pnl.pnlPercentage;\n    return `${pnlPercentage > 0 ? \"+\" : \"\"}${pnlPercentage.toFixed(2)}%`;\n  },\n  isVisible: () => true,\n}\n```\n\n**Note column** respects global configuration:\n\n```typescript\n{\n  key: \"note\",\n  label: \"Note\",\n  format: (data) => toPlainString(data.note ?? \"N/A\"),\n  isVisible: () => GLOBAL_CONFIG.CC_REPORT_SHOW_SIGNAL_NOTE,\n}\n```\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:108-194](), [src/lib/services/markdown/LiveMarkdownService.ts:153-255]()\n\n---\n\n## File Output Structure\n\n```mermaid\ngraph TB\n    ROOT[\"Project Root\"]\n    DUMP[\"./dump/\"]\n    \n    BACKTEST_DIR[\"backtest/\"]\n    LIVE_DIR[\"live/\"]\n    SCHEDULE_DIR[\"schedule/\"]\n    WALKER_DIR[\"walker/\"]\n    PERFORMANCE_DIR[\"performance/\"]\n    HEAT_DIR[\"heatmap/\"]\n    PARTIAL_DIR[\"partial/\"]\n    RISK_DIR[\"risk/\"]\n    OUTLINE_DIR[\"outline/\"]\n    \n    ROOT --> DUMP\n    DUMP --> BACKTEST_DIR\n    DUMP --> LIVE_DIR\n    DUMP --> SCHEDULE_DIR\n    DUMP --> WALKER_DIR\n    DUMP --> PERFORMANCE_DIR\n    DUMP --> HEAT_DIR\n    DUMP --> PARTIAL_DIR\n    DUMP --> RISK_DIR\n    DUMP --> OUTLINE_DIR\n    \n    BACKTEST_DIR --> BT_FILE[\"strategy-name.md\"]\n    LIVE_DIR --> LV_FILE[\"strategy-name.md\"]\n    SCHEDULE_DIR --> SC_FILE[\"strategy-name.md\"]\n    WALKER_DIR --> WK_FILE[\"walker-name.md\"]\n    PERFORMANCE_DIR --> PF_FILE[\"strategy-name.md\"]\n    HEAT_DIR --> HT_FILE[\"strategy-name.md\"]\n    PARTIAL_DIR --> PT_FILE[\"symbol_strategy-name.md\"]\n```\n\n### File Creation Process\n\nAll markdown services use Node.js filesystem APIs with atomic writes:\n\n1. **Create Directory**: `mkdir(dir, { recursive: true })` ensures parent directories exist\n2. **Generate Filename**: Pattern varies by service (e.g., `{strategyName}.md`, `{symbol}_{strategyName}.md`)\n3. **Write File**: `writeFile(filepath, markdown, \"utf-8\")` writes markdown string\n4. **Log Success**: Console log confirms file path\n\n**Default Paths**:\n\n| Service | Default Path | Filename Pattern |\n|---------|-------------|------------------|\n| BacktestMarkdownService | `./dump/backtest` | `{strategyName}.md` |\n| LiveMarkdownService | `./dump/live` | `{strategyName}.md` |\n| ScheduleMarkdownService | `./dump/schedule` | `{strategyName}.md` |\n| WalkerMarkdownService | `./dump/walker` | `{walkerName}.md` |\n| PerformanceMarkdownService | `./dump/performance` | `{strategyName}.md` |\n| HeatMarkdownService | `./dump/heatmap` | `{strategyName}.md` |\n| PartialMarkdownService | `./dump/partial` | `{symbol}_{strategyName}.md` |\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:348-366](), [src/lib/services/markdown/LiveMarkdownService.ts:545-563](), [src/lib/services/markdown/PartialMarkdownService.ts:289-304]()\n\n---\n\n## Public API Usage\n\n### Class-Based API\n\nMarkdown services are accessed through public static methods on report classes:\n\n```mermaid\ngraph LR\n    USER[\"User Code\"]\n    \n    BACKTEST_CLASS[\"Backtest Class\"]\n    LIVE_CLASS[\"Live Class\"]\n    WALKER_CLASS[\"Walker Class\"]\n    PERFORMANCE_CLASS[\"Performance Class\"]\n    HEAT_CLASS[\"Heat Class\"]\n    PARTIAL_CLASS[\"Partial Class\"]\n    \n    BACKTEST_SERVICE[\"BacktestMarkdownService\"]\n    LIVE_SERVICE[\"LiveMarkdownService\"]\n    WALKER_SERVICE[\"WalkerMarkdownService\"]\n    \n    USER --> BACKTEST_CLASS\n    USER --> LIVE_CLASS\n    USER --> WALKER_CLASS\n    USER --> PERFORMANCE_CLASS\n    USER --> HEAT_CLASS\n    USER --> PARTIAL_CLASS\n    \n    BACKTEST_CLASS --> BACKTEST_SERVICE\n    LIVE_CLASS --> LIVE_SERVICE\n    WALKER_CLASS --> WALKER_SERVICE\n```\n\n### Method Signatures\n\n**Backtest, Live, Schedule, Partial** (symbol + strategyName scope):\n```typescript\n// Get statistics object\nawait Backtest.getData(symbol: string, strategyName: string): Promise<BacktestStatistics>\n\n// Generate markdown string\nawait Backtest.getReport(symbol: string, strategyName: string): Promise<string>\n\n// Save to filesystem\nawait Backtest.dump(symbol: string, strategyName: string, path?: string): Promise<void>\n\n// Clear accumulated data\nawait Backtest.clear(ctx?: { symbol: string; strategyName: string }): Promise<void>\n```\n\n**Walker** (walkerName scope):\n```typescript\nawait Walker.getData(\n  walkerName: string,\n  symbol: string,\n  metric: WalkerMetric,\n  context: { exchangeName: string; frameName: string }\n): Promise<WalkerStatistics>\n\nawait Walker.getReport(...): Promise<string>\nawait Walker.dump(...): Promise<void>\n```\n\n**Performance** (symbol + strategyName scope):\n```typescript\nawait Performance.getData(symbol: string, strategyName: string): Promise<PerformanceStatistics>\nawait Performance.getReport(symbol: string, strategyName: string): Promise<string>\nawait Performance.dump(symbol: string, strategyName: string, path?: string): Promise<void>\n```\n\n**Heat** (strategyName scope):\n```typescript\nawait Heat.getData(strategyName: string): Promise<IHeatmapStatistics>\nawait Heat.getReport(strategyName: string): Promise<string>\nawait Heat.dump(strategyName: string, path?: string): Promise<void>\nawait Heat.clear(strategyName?: string): Promise<void>\n```\n\n**Sources:** [src/index.ts:178-188](), [types.d.ts:3645-3884]()\n\n---\n\n## Usage Examples\n\n### Example 1: Backtest Report Generation\n\n```typescript\nimport { Backtest, listenDoneBacktest } from \"backtest-kit\";\n\n// Wait for backtest to complete\nlistenDoneBacktest(async (event) => {\n  const { symbol, strategyName } = event;\n  \n  // Get statistics object\n  const stats = await Backtest.getData(symbol, strategyName);\n  console.log(`Win Rate: ${stats.winRate}%`);\n  console.log(`Sharpe Ratio: ${stats.sharpeRatio}`);\n  \n  // Generate and save markdown report\n  await Backtest.dump(symbol, strategyName);\n  // Saves to: ./dump/backtest/{strategyName}.md\n});\n```\n\n**Sources:** [types.d.ts:3645-3711]()\n\n---\n\n### Example 2: Live Trading Report with Custom Path\n\n```typescript\nimport { Live } from \"backtest-kit\";\n\n// During live trading execution\nsetInterval(async () => {\n  const stats = await Live.getData(\"BTCUSDT\", \"my-strategy\");\n  \n  if (stats.totalClosed > 10) {\n    // Save to custom directory\n    await Live.dump(\"BTCUSDT\", \"my-strategy\", \"./reports/live\");\n    // Saves to: ./reports/live/my-strategy.md\n  }\n}, 60000); // Every minute\n```\n\n**Sources:** [types.d.ts:3713-3787]()\n\n---\n\n### Example 3: Walker Comparison Report\n\n```typescript\nimport { Walker, listenWalkerComplete } from \"backtest-kit\";\n\nlistenWalkerComplete(async (results) => {\n  const { walkerName, symbol, metric, bestStrategy } = results;\n  \n  console.log(`Best strategy: ${bestStrategy}`);\n  \n  // Get detailed results\n  const stats = await Walker.getData(\n    walkerName,\n    symbol,\n    metric,\n    { exchangeName: \"binance\", frameName: \"1d\" }\n  );\n  \n  // Save comparison report\n  await Walker.dump(walkerName, symbol, metric, { exchangeName: \"binance\", frameName: \"1d\" });\n  // Saves to: ./dump/walker/{walkerName}.md\n});\n```\n\n**Sources:** [types.d.ts:3897-3980]()\n\n---\n\n### Example 4: Performance Profiling\n\n```typescript\nimport { Performance, listenPerformance } from \"backtest-kit\";\n\n// Monitor performance in real-time\nlistenPerformance((event) => {\n  console.log(`${event.metricType}: ${event.duration.toFixed(2)}ms`);\n});\n\n// After execution\nconst stats = await Performance.getData(\"BTCUSDT\", \"my-strategy\");\n\n// Find bottlenecks\nconst sortedMetrics = Object.values(stats.metricStats)\n  .sort((a, b) => b.totalDuration - a.totalDuration);\n\nconsole.log(\"Slowest operations:\");\nsortedMetrics.slice(0, 3).forEach(m => {\n  console.log(`${m.metricType}: ${m.totalDuration.toFixed(2)}ms total`);\n});\n\nawait Performance.dump(\"BTCUSDT\", \"my-strategy\");\n```\n\n**Sources:** [types.d.ts:3982-4059]()\n\n---\n\n### Example 5: Portfolio Heatmap\n\n```typescript\nimport { Heat } from \"backtest-kit\";\n\n// Get portfolio-wide statistics\nconst heatmap = await Heat.getData(\"my-strategy\");\n\nconsole.log(`Total symbols: ${heatmap.totalSymbols}`);\nconsole.log(`Portfolio PNL: ${heatmap.portfolioTotalPnl}%`);\nconsole.log(`Portfolio Sharpe: ${heatmap.portfolioSharpeRatio}`);\n\n// Inspect per-symbol breakdown\nheatmap.symbols.forEach(row => {\n  console.log(`${row.symbol}: ${row.totalPnl}% PNL, ${row.sharpeRatio} Sharpe`);\n});\n\nawait Heat.dump(\"my-strategy\");\n// Saves to: ./dump/heatmap/my-strategy.md\n```\n\n**Sources:** [types.d.ts:4061-4154]()\n\n---\n\n## Service Dependencies\n\n```mermaid\ngraph TB\n    subgraph \"Core Dependencies\"\n        DI[\"Dependency Injection<br/>inject() from di\"]\n        LOGGER[\"LoggerService<br/>TYPES.loggerService\"]\n        TYPES[\"TYPES constants<br/>Symbol keys\"]\n    end\n    \n    subgraph \"Utility Libraries\"\n        FUNCTOOLS[\"functools-kit<br/>memoize<br/>singleshot<br/>queued<br/>str\"]\n        FS[\"Node.js fs/promises<br/>writeFile<br/>mkdir\"]\n        PATH[\"Node.js path<br/>join\"]\n    end\n    \n    subgraph \"Internal Dependencies\"\n        EMITTERS[\"Event Emitters<br/>signalBacktestEmitter<br/>signalLiveEmitter<br/>etc.\"]\n        INTERFACES[\"Type Interfaces<br/>IStrategyTickResult<br/>ISignalRow<br/>etc.\"]\n        HELPERS[\"Helper Functions<br/>toPlainString<br/>isUnsafe\"]\n        GLOBAL_CONFIG[\"GLOBAL_CONFIG<br/>CC_REPORT_SHOW_SIGNAL_NOTE\"]\n    end\n    \n    SERVICE[\"Markdown Service\"]\n    \n    SERVICE --> DI\n    SERVICE --> LOGGER\n    SERVICE --> TYPES\n    SERVICE --> FUNCTOOLS\n    SERVICE --> FS\n    SERVICE --> PATH\n    SERVICE --> EMITTERS\n    SERVICE --> INTERFACES\n    SERVICE --> HELPERS\n    SERVICE --> GLOBAL_CONFIG\n```\n\n### Dependency Details\n\n**functools-kit Integration**:\n- `memoize`: Cache storage instances by key\n- `singleshot`: Ensure init() runs once\n- `queued`: Used in event listeners (not directly in services)\n- `str`: Format numbers with patterns (used in HeatMarkdownService)\n\n**LoggerService**:\nAll markdown services inject `LoggerService` for structured logging:\n```typescript\nprivate readonly loggerService = inject<LoggerService>(TYPES.loggerService);\n```\n\n**Event Emitters**:\nServices subscribe to specific emitters based on their domain:\n- BacktestMarkdownService → `signalBacktestEmitter`\n- LiveMarkdownService → `signalLiveEmitter`\n- ScheduleMarkdownService → `signalEmitter`\n- WalkerMarkdownService → `walkerEmitter`\n- PerformanceMarkdownService → `performanceEmitter`\n- HeatMarkdownService → `signalEmitter`\n- PartialMarkdownService → `partialProfitSubject` + `partialLossSubject`\n- RiskMarkdownService → `riskSubject`\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:1-14](), [src/lib/services/markdown/LiveMarkdownService.ts:1-16](), [src/config/emitters.ts:1-133]()\n\n---\n\n## Error Handling and Edge Cases\n\n### Safe Math Implementation\n\nAll statistics calculations use `isUnsafe()` checks to prevent invalid values:\n\n```typescript\nfunction isUnsafe(value: number | null): boolean {\n  if (typeof value !== \"number\") return true;\n  if (isNaN(value)) return true;\n  if (!isFinite(value)) return true;\n  return false;\n}\n\n// Usage in statistics calculation\nwinRate: isUnsafe(winRate) ? null : winRate,\nsharpeRatio: isUnsafe(sharpeRatio) ? null : sharpeRatio,\n```\n\nThis ensures reports display `\"N/A\"` for undefined/invalid metrics rather than displaying `NaN` or `Infinity`.\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:37-48](), [src/lib/services/markdown/LiveMarkdownService.ts:24-35]()\n\n---\n\n### Empty Data Handling\n\nAll `getData()` methods return valid statistics interfaces even when no data exists:\n\n```typescript\nif (this._signalList.length === 0) {\n  return {\n    signalList: [],\n    totalSignals: 0,\n    winCount: 0,\n    lossCount: 0,\n    winRate: null,\n    avgPnl: null,\n    totalPnl: null,\n    stdDev: null,\n    sharpeRatio: null,\n    // ... all other metrics as null\n  };\n}\n```\n\nReports display informative messages when no data is available:\n\n```markdown\n# Backtest Report: my-strategy\n\nNo signals closed yet.\n```\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:228-243](), [src/lib/services/markdown/LiveMarkdownService.ts:410-426]()\n\n---\n\n### Memory Bounds Enforcement\n\nServices protect against memory leaks by enforcing MAX_EVENTS limits:\n\n```typescript\nconst MAX_EVENTS = 250;\n\npublic addSignal(data: IStrategyTickResultClosed) {\n  this._signalList.unshift(data);\n  \n  if (this._signalList.length > MAX_EVENTS) {\n    this._signalList.pop();  // Remove oldest event\n  }\n}\n```\n\n**Trade-off**: Older data is discarded when limit is reached. For complete historical analysis, use custom event listeners to store data externally.\n\n**Exceptions**: WalkerMarkdownService and RiskMarkdownService do not enforce bounds because they need complete aggregation.\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:197-219](), [src/lib/services/markdown/PerformanceMarkdownService.ts:199-220]()\n\n---\n\n### File System Error Handling\n\nAll `dump()` methods wrap filesystem operations in try-catch blocks:\n\n```typescript\npublic async dump(strategyName: string, path = \"./dump/backtest\"): Promise<void> {\n  const markdown = await this.getReport(strategyName);\n  \n  try {\n    const dir = join(process.cwd(), path);\n    await mkdir(dir, { recursive: true });\n    \n    const filename = `${strategyName}.md`;\n    const filepath = join(dir, filename);\n    \n    await writeFile(filepath, markdown, \"utf-8\");\n    console.log(`Backtest report saved: ${filepath}`);\n  } catch (error) {\n    console.error(`Failed to save markdown report:`, error);\n  }\n}\n```\n\nErrors are logged but do not crash the application.\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:348-366](), [src/lib/services/markdown/LiveMarkdownService.ts:545-563]()\n\n---\n\n## Performance Considerations\n\n### Memoization Benefits\n\nUsing `memoize` for `getStorage()` provides:\n1. **Instance Reuse**: Same storage instance returned for same key\n2. **Memory Efficiency**: Only one storage per `symbol:strategyName` pair\n3. **O(1) Lookup**: Hash-based key lookup\n\n### Singleshot Initialization\n\nUsing `singleshot` for `init()` ensures:\n1. **Event subscription happens once**: Prevents duplicate subscriptions\n2. **Lazy initialization**: Init only runs when first method is called\n3. **Thread-safe**: functools-kit guarantees single execution\n\n### Data Structure Choices\n\n**Array with unshift/pop**:\n- Fast insertion at front: O(1) amortized\n- Fast removal from back: O(1)\n- Trade-off: Array shifting may be slower than linked list for very large MAX_EVENTS\n\n**Alternative considered**: Circular buffer for better performance at high volumes.\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:404-407](), [src/lib/services/markdown/BacktestMarkdownService.ts:564-567]()\n\n---\n\n## Testing Considerations\n\n### Mocking Strategies\n\nTo test markdown services in isolation:\n\n1. **Mock Event Emitters**: Create test Subject instances\n2. **Inject Test Data**: Call `addSignal()` directly on storage\n3. **Assert Statistics**: Validate getData() output\n4. **Mock Filesystem**: Use in-memory filesystem or mock writeFile\n\n### Example Test Pattern\n\n```typescript\n// Create service instance\nconst service = new BacktestMarkdownService();\n\n// Get storage instance\nconst storage = service['getStorage'](\"BTCUSDT\", \"test-strategy\");\n\n// Inject test data\nstorage.addSignal({\n  action: \"closed\",\n  signal: { id: \"test-1\", symbol: \"BTCUSDT\", strategyName: \"test-strategy\", /* ... */ },\n  pnl: { pnlPercentage: 5.0 },\n  closeReason: \"take_profit\",\n  /* ... */\n});\n\n// Assert statistics\nconst stats = await service.getData(\"BTCUSDT\", \"test-strategy\");\nexpect(stats.totalSignals).toBe(1);\nexpect(stats.winCount).toBe(1);\n```\n\n### Clear Method for Test Cleanup\n\nAll services provide `clear()` method for test isolation:\n\n```typescript\nawait service.clear({ symbol: \"BTCUSDT\", strategyName: \"test-strategy\" });\n```\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:541-551](), [src/lib/services/markdown/LiveMarkdownService.ts:748-758]()"
                    },
                    {
                        "page_plan": {
                            "id": "8.2",
                            "title": "Performance Statistics"
                        },
                        "content": "# Performance Statistics\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [src/interfaces/Heatmap.interface.ts](src/interfaces/Heatmap.interface.ts)\n- [src/lib/services/markdown/BacktestMarkdownService.ts](src/lib/services/markdown/BacktestMarkdownService.ts)\n- [src/lib/services/markdown/HeatMarkdownService.ts](src/lib/services/markdown/HeatMarkdownService.ts)\n- [src/lib/services/markdown/LiveMarkdownService.ts](src/lib/services/markdown/LiveMarkdownService.ts)\n- [src/lib/services/markdown/PartialMarkdownService.ts](src/lib/services/markdown/PartialMarkdownService.ts)\n- [src/lib/services/markdown/PerformanceMarkdownService.ts](src/lib/services/markdown/PerformanceMarkdownService.ts)\n- [src/lib/services/markdown/ScheduleMarkdownService.ts](src/lib/services/markdown/ScheduleMarkdownService.ts)\n- [src/lib/services/markdown/WalkerMarkdownService.ts](src/lib/services/markdown/WalkerMarkdownService.ts)\n- [test/e2e/defend.test.mjs](test/e2e/defend.test.mjs)\n- [test/e2e/risk.test.mjs](test/e2e/risk.test.mjs)\n- [test/index.mjs](test/index.mjs)\n- [test/mock/getMockCandles.mjs](test/mock/getMockCandles.mjs)\n- [test/spec/heat.test.mjs](test/spec/heat.test.mjs)\n- [test/spec/list.test.mjs](test/spec/list.test.mjs)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\nThis page documents the statistical metrics calculated from trading results. The framework computes comprehensive performance analytics including win rates, Sharpe ratios, drawdowns, and risk-adjusted returns for both backtest and live trading modes.\n\nFor information about the markdown report system and how statistics are stored and generated, see [Markdown Report System](#8.1). For portfolio-wide heatmap statistics aggregated across symbols, see [Portfolio Heatmaps](#8.3).\n\n---\n\n## Statistics Interfaces Overview\n\nThe framework provides multiple statistics interfaces, each tailored to a specific execution mode or analysis type. All statistics calculations follow a consistent pattern: they aggregate signal data and compute derived metrics with safety checks for invalid values (NaN, Infinity).\n\n| Interface | Purpose | Location | Key Metrics |\n|-----------|---------|----------|-------------|\n| `BacktestStatistics` | Historical simulation results | [src/lib/services/markdown/BacktestMarkdownService.ts:70-106]() | Win rate, Sharpe ratio, PNL, drawdown |\n| `LiveStatistics` | Real-time trading results | [src/lib/services/markdown/LiveMarkdownService.ts:97-136]() | Same as backtest + event tracking |\n| `ScheduleStatistics` | Scheduled signal tracking | [src/lib/services/markdown/ScheduleMarkdownService.ts:72-99]() | Cancellation rate, activation rate |\n| `WalkerStatistics` | Strategy comparison | [src/lib/services/markdown/WalkerMarkdownService.ts:23-26]() | Best strategy, metric values |\n| `PerformanceStatistics` | Execution metrics | [src/lib/services/markdown/PerformanceMarkdownService.ts:60-75]() | Duration, percentiles, wait times |\n| `PartialStatistics` | Profit/loss milestones | [src/lib/services/markdown/PartialMarkdownService.ts:53-65]() | Event counts by type |\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:70-106](), [src/lib/services/markdown/LiveMarkdownService.ts:97-136](), [src/lib/services/markdown/ScheduleMarkdownService.ts:72-99](), [src/lib/services/markdown/WalkerMarkdownService.ts:23-26](), [src/lib/services/markdown/PerformanceMarkdownService.ts:60-75](), [src/lib/services/markdown/PartialMarkdownService.ts:53-65]()\n\n---\n\n## Statistics Calculation Flow\n\nThe following diagram shows how raw signal data flows through the system to produce aggregated statistics:\n\n```mermaid\ngraph TB\n    subgraph \"Signal Generation\"\n        SIGNALS[\"IStrategyTickResult<br/>closed signals\"]\n        BT_EMITTER[\"signalBacktestEmitter\"]\n        LIVE_EMITTER[\"signalLiveEmitter\"]\n    end\n    \n    subgraph \"Storage Layer\"\n        BT_STORAGE[\"ReportStorage<br/>(BacktestMarkdownService)\"]\n        LIVE_STORAGE[\"ReportStorage<br/>(LiveMarkdownService)\"]\n        \n        BT_LIST[\"_signalList: IStrategyTickResultClosed[]\"]\n        LIVE_LIST[\"_eventList: TickEvent[]\"]\n    end\n    \n    subgraph \"Aggregation\"\n        AGGREGATE[\"getData() method\"]\n        \n        BASIC[\"Basic Metrics<br/>totalSignals, winCount, lossCount\"]\n        RATES[\"Rates<br/>winRate, avgPnl, totalPnl\"]\n        VOLATILITY[\"Volatility<br/>stdDev (variance)\"]\n        RISK_ADJ[\"Risk-Adjusted<br/>sharpeRatio, annualizedSharpeRatio\"]\n        ADVANCED[\"Advanced<br/>certaintyRatio, expectedYearlyReturns\"]\n    end\n    \n    subgraph \"Safety Validation\"\n        IS_UNSAFE[\"isUnsafe(value)<br/>checks NaN, Infinity\"]\n        NULLIFY[\"Set to null if unsafe\"]\n    end\n    \n    subgraph \"Output\"\n        STATS[\"BacktestStatistics | LiveStatistics<br/>all metrics + signalList/eventList\"]\n    end\n    \n    SIGNALS --> BT_EMITTER\n    SIGNALS --> LIVE_EMITTER\n    \n    BT_EMITTER --> BT_STORAGE\n    LIVE_EMITTER --> LIVE_STORAGE\n    \n    BT_STORAGE --> BT_LIST\n    LIVE_STORAGE --> LIVE_LIST\n    \n    BT_LIST --> AGGREGATE\n    LIVE_LIST --> AGGREGATE\n    \n    AGGREGATE --> BASIC\n    BASIC --> RATES\n    RATES --> VOLATILITY\n    VOLATILITY --> RISK_ADJ\n    RISK_ADJ --> ADVANCED\n    \n    RATES --> IS_UNSAFE\n    VOLATILITY --> IS_UNSAFE\n    RISK_ADJ --> IS_UNSAFE\n    ADVANCED --> IS_UNSAFE\n    \n    IS_UNSAFE --> NULLIFY\n    \n    NULLIFY --> STATS\n```\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:227-295](), [src/lib/services/markdown/LiveMarkdownService.ts:409-492](), [src/lib/services/markdown/BacktestMarkdownService.ts:36-48]()\n\n---\n\n## Core Performance Metrics\n\n### Win Rate\n\nThe win rate represents the percentage of closed signals that resulted in profit (PNL > 0). This is a fundamental metric for evaluating strategy effectiveness.\n\n**Formula:**\n```\nwinRate = (winCount / totalSignals) × 100\nwhere:\n  winCount = signals with pnl.pnlPercentage > 0\n  totalSignals = all closed signals\n```\n\n**Interpretation:** Higher values indicate better strategy performance. A win rate above 50% means more winning trades than losing trades, but this must be considered alongside average win/loss sizes (see Certainty Ratio).\n\n**Calculation Code:**\n\n[src/lib/services/markdown/BacktestMarkdownService.ts:245-252]()\n```typescript\nconst totalSignals = this._signalList.length;\nconst winCount = this._signalList.filter((s) => s.pnl.pnlPercentage > 0).length;\nconst lossCount = this._signalList.filter((s) => s.pnl.pnlPercentage < 0).length;\n\n// Calculate basic statistics\nconst avgPnl = this._signalList.reduce((sum, s) => sum + s.pnl.pnlPercentage, 0) / totalSignals;\nconst totalPnl = this._signalList.reduce((sum, s) => sum + s.pnl.pnlPercentage, 0);\nconst winRate = (winCount / totalSignals) * 100;\n```\n\n**Output Format:** Returned as percentage (0-100) or `null` if unsafe. Display includes win/loss counts: `\"52.35% (10W / 9L)\"`.\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:245-252](), [src/lib/services/markdown/LiveMarkdownService.ts:438-439](), [src/lib/services/markdown/BacktestMarkdownService.ts:331]()\n\n---\n\n### Average PNL\n\nAverage profit/loss per closed signal, expressed as a percentage. This metric shows the expected return per trade.\n\n**Formula:**\n```\navgPnl = Σ(pnl.pnlPercentage) / totalSignals\n```\n\n**Interpretation:** Higher values are better. Positive values indicate profitable strategy, negative values indicate losses. Should be significantly larger than total costs (slippage + fees) to be economically viable.\n\n**Calculation Code:**\n\n[src/lib/services/markdown/BacktestMarkdownService.ts:250]()\n```typescript\nconst avgPnl = this._signalList.reduce((sum, s) => sum + s.pnl.pnlPercentage, 0) / totalSignals;\n```\n\n[src/lib/services/markdown/LiveMarkdownService.ts:434-436]()\n```typescript\nconst avgPnl = totalClosed > 0\n  ? closedEvents.reduce((sum, e) => sum + (e.pnl || 0), 0) / totalClosed\n  : 0;\n```\n\n**Safety:** Returns `null` if value is NaN, Infinity, or not a number (checked via `isUnsafe()`).\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:250](), [src/lib/services/markdown/LiveMarkdownService.ts:434-436](), [src/lib/services/markdown/BacktestMarkdownService.ts:287]()\n\n---\n\n### Total PNL\n\nCumulative profit/loss across all closed signals, expressed as a percentage. This represents the total return if all trades were executed with equal capital allocation.\n\n**Formula:**\n```\ntotalPnl = Σ(pnl.pnlPercentage)\n```\n\n**Interpretation:** Higher values are better. This metric shows absolute performance but doesn't account for risk or number of trades.\n\n**Calculation Code:**\n\n[src/lib/services/markdown/BacktestMarkdownService.ts:251]()\n```typescript\nconst totalPnl = this._signalList.reduce((sum, s) => sum + s.pnl.pnlPercentage, 0);\n```\n\n**Display Example:** `\"+12.45%\"` or `\"-5.23%\"` in reports.\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:251](), [src/lib/services/markdown/LiveMarkdownService.ts:437](), [src/lib/services/markdown/BacktestMarkdownService.ts:333]()\n\n---\n\n### Standard Deviation (Volatility)\n\nStandard deviation of returns measures the volatility or dispersion of trade results. This is a key component in risk-adjusted metrics.\n\n**Formula:**\n```\nvariance = Σ((pnl - avgPnl)²) / totalSignals\nstdDev = √variance\n```\n\n**Interpretation:** Lower values are better, indicating more consistent returns with less volatility. High standard deviation means returns are spread out over a wide range, indicating higher risk.\n\n**Calculation Code:**\n\n[src/lib/services/markdown/BacktestMarkdownService.ts:254-257]()\n```typescript\n// Calculate Sharpe Ratio (risk-free rate = 0)\nconst returns = this._signalList.map((s) => s.pnl.pnlPercentage);\nconst variance = returns.reduce((sum, r) => sum + Math.pow(r - avgPnl, 2), 0) / totalSignals;\nconst stdDev = Math.sqrt(variance);\n```\n\n[src/lib/services/markdown/LiveMarkdownService.ts:443-448]()\n```typescript\n// Calculate Sharpe Ratio (risk-free rate = 0)\nlet sharpeRatio = 0;\nlet stdDev = 0;\nif (totalClosed > 0) {\n  const returns = closedEvents.map((e) => e.pnl || 0);\n  const variance = returns.reduce((sum, r) => sum + Math.pow(r - avgPnl, 2), 0) / totalClosed;\n  stdDev = Math.sqrt(variance);\n  sharpeRatio = stdDev > 0 ? avgPnl / stdDev : 0;\n}\n```\n\n**Note:** The calculation assumes risk-free rate = 0 for simplicity. In practice, you might subtract risk-free rate from returns before calculating Sharpe ratio.\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:254-257](), [src/lib/services/markdown/LiveMarkdownService.ts:443-448](), [src/lib/services/markdown/BacktestMarkdownService.ts:334]()\n\n---\n\n### Sharpe Ratio\n\nThe Sharpe ratio measures risk-adjusted return by dividing average return by volatility (standard deviation). This is one of the most important metrics for evaluating strategy quality.\n\n**Formula:**\n```\nsharpeRatio = avgPnl / stdDev\n(assuming risk-free rate = 0)\n```\n\n**Interpretation:** Higher values are better. A Sharpe ratio above 1.0 is considered good, above 2.0 is very good, above 3.0 is excellent. Negative values indicate average losses exceed volatility, which is undesirable.\n\n**Calculation Code:**\n\n[src/lib/services/markdown/BacktestMarkdownService.ts:258]()\n```typescript\nconst sharpeRatio = stdDev > 0 ? avgPnl / stdDev : 0;\n```\n\n**Typical Values:**\n- `< 0`: Losing strategy\n- `0.0 - 1.0`: Acceptable risk-adjusted returns\n- `1.0 - 2.0`: Good risk-adjusted returns\n- `> 2.0`: Excellent risk-adjusted returns\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:258](), [src/lib/services/markdown/LiveMarkdownService.ts:447](), [src/lib/services/markdown/BacktestMarkdownService.ts:335]()\n\n---\n\n### Annualized Sharpe Ratio\n\nThe annualized Sharpe ratio scales the daily/per-trade Sharpe ratio to yearly terms for easier comparison with other investments.\n\n**Formula:**\n```\nannualizedSharpeRatio = sharpeRatio × √365\n```\n\n**Interpretation:** This assumes 365 trading days per year. The square root scaling is based on the assumption that returns are independent and identically distributed (IID). Higher values are better, with same thresholds as regular Sharpe ratio.\n\n**Calculation Code:**\n\n[src/lib/services/markdown/BacktestMarkdownService.ts:259]()\n```typescript\nconst annualizedSharpeRatio = sharpeRatio * Math.sqrt(365);\n```\n\n**Note:** The multiplier `√365` assumes daily trading frequency. For different frequencies, adjust accordingly (e.g., `√52` for weekly).\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:259](), [src/lib/services/markdown/LiveMarkdownService.ts:449](), [src/lib/services/markdown/BacktestMarkdownService.ts:336]()\n\n---\n\n### Certainty Ratio\n\nThe certainty ratio (also called risk/reward ratio) measures the relationship between average winning trades and average losing trades.\n\n**Formula:**\n```\ncertaintyRatio = avgWin / |avgLoss|\nwhere:\n  avgWin = average profit on winning trades\n  avgLoss = average loss on losing trades (negative value)\n```\n\n**Interpretation:** Higher values are better. A ratio above 1.0 means average wins are larger than average losses. A ratio of 2.0 means average wins are twice the size of average losses, which is generally considered good risk management.\n\n**Calculation Code:**\n\n[src/lib/services/markdown/BacktestMarkdownService.ts:262-270]()\n```typescript\n// Calculate Certainty Ratio\nconst wins = this._signalList.filter((s) => s.pnl.pnlPercentage > 0);\nconst losses = this._signalList.filter((s) => s.pnl.pnlPercentage < 0);\nconst avgWin = wins.length > 0\n  ? wins.reduce((sum, s) => sum + s.pnl.pnlPercentage, 0) / wins.length\n  : 0;\nconst avgLoss = losses.length > 0\n  ? losses.reduce((sum, s) => sum + s.pnl.pnlPercentage, 0) / losses.length\n  : 0;\nconst certaintyRatio = avgLoss < 0 ? avgWin / Math.abs(avgLoss) : 0;\n```\n\n**Example:** If `avgWin = 3.0%` and `avgLoss = -1.5%`, then `certaintyRatio = 3.0 / 1.5 = 2.0`.\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:262-270](), [src/lib/services/markdown/LiveMarkdownService.ts:452-463](), [src/lib/services/markdown/BacktestMarkdownService.ts:337]()\n\n---\n\n### Expected Yearly Returns\n\nExpected yearly returns project the strategy's performance over a full year based on average trade duration and average PNL.\n\n**Formula:**\n```\navgDurationDays = avgDurationMs / (1000 × 60 × 60 × 24)\ntradesPerYear = 365 / avgDurationDays\nexpectedYearlyReturns = avgPnl × tradesPerYear\n```\n\n**Interpretation:** Higher values are better. This metric assumes: (1) constant capital allocation per trade, (2) trades can be executed consecutively without gaps, (3) future performance matches historical average. It provides a rough estimate of annualized returns.\n\n**Calculation Code:**\n\n[src/lib/services/markdown/BacktestMarkdownService.ts:272-279]()\n```typescript\n// Calculate Expected Yearly Returns\nconst avgDurationMs = this._signalList.reduce(\n  (sum, s) => sum + (s.closeTimestamp - s.signal.pendingAt),\n  0\n) / totalSignals;\nconst avgDurationDays = avgDurationMs / (1000 * 60 * 60 * 24);\nconst tradesPerYear = avgDurationDays > 0 ? 365 / avgDurationDays : 0;\nconst expectedYearlyReturns = avgPnl * tradesPerYear;\n```\n\n**Example:** If `avgPnl = 2.5%` and average trade duration is 5 days, then `tradesPerYear = 73` and `expectedYearlyReturns = 2.5% × 73 = 182.5%`.\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:272-279](), [src/lib/services/markdown/LiveMarkdownService.ts:466-475](), [src/lib/services/markdown/BacktestMarkdownService.ts:338]()\n\n---\n\n## Advanced Portfolio Metrics\n\nThese metrics are calculated by `HeatMarkdownService` for portfolio-wide analysis across multiple symbols.\n\n### Profit Factor\n\nProfit factor compares the sum of all winning trades to the sum of all losing trades.\n\n**Formula:**\n```\nprofitFactor = Σ(winning trades) / |Σ(losing trades)|\n```\n\n**Interpretation:** Higher values are better. A profit factor above 1.0 means total profits exceed total losses. Values above 1.5 are considered good, above 2.0 are excellent.\n\n**Calculation Code:**\n\n[src/lib/services/markdown/HeatMarkdownService.ts:235-244]()\n```typescript\n// Calculate Profit Factor\nlet profitFactor: number | null = null;\nconst totalWins = wins.reduce((sum, s) => sum + s.pnl.pnlPercentage, 0);\nconst totalLosses = losses.reduce((sum, s) => sum + s.pnl.pnlPercentage, 0);\nif (totalLosses < 0) {\n  profitFactor = totalWins / Math.abs(totalLosses);\n} else if (totalWins > 0 && totalLosses === 0) {\n  profitFactor = Infinity; // All wins, no losses\n}\n```\n\n**Sources:** [src/lib/services/markdown/HeatMarkdownService.ts:235-244](), [src/interfaces/Heatmap.interface.ts:26-27]()\n\n---\n\n### Maximum Drawdown\n\nMaximum drawdown measures the largest peak-to-trough decline in cumulative PNL. This is a critical risk metric.\n\n**Formula:**\n```\nFor each point i in cumulative PNL:\n  peak = max cumulative PNL up to point i\n  drawdown[i] = (cumulative[i] - peak) / peak × 100\nmaxDrawdown = min(drawdown)\n```\n\n**Interpretation:** Lower absolute values are better (less risk). A drawdown of -20% means the portfolio declined 20% from its peak before recovering. Large drawdowns indicate higher risk and potential for significant losses.\n\n**Calculation Code:**\n\n[src/lib/services/markdown/HeatMarkdownService.ts:246-257]()\n```typescript\n// Calculate Maximum Drawdown\nlet maxDrawdown: number | null = null;\nlet peak = 0;\nlet maxDD = 0;\nlet cumulative = 0;\nfor (const signal of signals) {\n  cumulative += signal.pnl.pnlPercentage;\n  if (cumulative > peak) peak = cumulative;\n  const drawdown = cumulative - peak;\n  if (drawdown < maxDD) maxDD = drawdown;\n}\nmaxDrawdown = maxDD;\n```\n\n**Example:** If cumulative PNL reaches +30%, then drops to +10%, the drawdown is -20%.\n\n**Sources:** [src/lib/services/markdown/HeatMarkdownService.ts:246-257](), [src/interfaces/Heatmap.interface.ts:13]()\n\n---\n\n### Expectancy\n\nExpectancy represents the average expected profit per trade, weighted by win rate.\n\n**Formula:**\n```\nexpectancy = (winRate × avgWin) - ((1 - winRate) × |avgLoss|)\n```\n\n**Interpretation:** Positive values indicate a profitable strategy in the long run. This metric combines win rate, average win, and average loss into a single measure of expected profitability per trade.\n\n**Calculation Code:**\n\n[src/lib/services/markdown/HeatMarkdownService.ts:259-265]()\n```typescript\n// Calculate Expectancy\nlet expectancy: number | null = null;\nif (totalTrades > 0 && winRate !== null && avgWin !== null && avgLoss !== null) {\n  const lossRate = 1 - winRate / 100;\n  expectancy = (winRate / 100) * avgWin + lossRate * avgLoss;\n}\n```\n\n**Example:** If `winRate = 60%`, `avgWin = 5%`, `avgLoss = -3%`, then:\n```\nexpectancy = (0.60 × 5%) + (0.40 × -3%) = 3.0% - 1.2% = 1.8%\n```\n\n**Sources:** [src/lib/services/markdown/HeatMarkdownService.ts:259-265](), [src/interfaces/Heatmap.interface.ts:37]()\n\n---\n\n## Safety and Validation\n\nAll numeric statistics use the `isUnsafe()` function to validate values before returning them. Invalid values are replaced with `null` to prevent displaying misleading data.\n\n```mermaid\ngraph TB\n    CALC[\"Metric Calculation\"]\n    CHECK[\"isUnsafe(value)\"]\n    \n    TYPE_CHECK[\"typeof value !== 'number'\"]\n    NAN_CHECK[\"isNaN(value)\"]\n    FINITE_CHECK[\"!isFinite(value)\"]\n    \n    UNSAFE[\"return true<br/>(unsafe)\"]\n    SAFE[\"return false<br/>(safe)\"]\n    \n    NULL[\"Set metric to null\"]\n    VALUE[\"Keep calculated value\"]\n    \n    CALC --> CHECK\n    \n    CHECK --> TYPE_CHECK\n    CHECK --> NAN_CHECK\n    CHECK --> FINITE_CHECK\n    \n    TYPE_CHECK -->|true| UNSAFE\n    NAN_CHECK -->|true| UNSAFE\n    FINITE_CHECK -->|true| UNSAFE\n    \n    TYPE_CHECK -->|false| SAFE\n    NAN_CHECK -->|false| SAFE\n    FINITE_CHECK -->|false| SAFE\n    \n    UNSAFE --> NULL\n    SAFE --> VALUE\n```\n\n**Implementation:**\n\n[src/lib/services/markdown/BacktestMarkdownService.ts:37-48]()\n```typescript\nfunction isUnsafe(value: number | null): boolean {\n  if (typeof value !== \"number\") {\n    return true;\n  }\n  if (isNaN(value)) {\n    return true;\n  }\n  if (!isFinite(value)) {\n    return true;\n  }\n  return false;\n}\n```\n\n**Usage in Statistics:**\n\n[src/lib/services/markdown/BacktestMarkdownService.ts:286-293]()\n```typescript\nreturn {\n  signalList: this._signalList,\n  totalSignals,\n  winCount,\n  lossCount,\n  winRate: isUnsafe(winRate) ? null : winRate,\n  avgPnl: isUnsafe(avgPnl) ? null : avgPnl,\n  totalPnl: isUnsafe(totalPnl) ? null : totalPnl,\n  stdDev: isUnsafe(stdDev) ? null : stdDev,\n  sharpeRatio: isUnsafe(sharpeRatio) ? null : sharpeRatio,\n  annualizedSharpeRatio: isUnsafe(annualizedSharpeRatio) ? null : annualizedSharpeRatio,\n  certaintyRatio: isUnsafe(certaintyRatio) ? null : certaintyRatio,\n  expectedYearlyReturns: isUnsafe(expectedYearlyReturns) ? null : expectedYearlyReturns,\n};\n```\n\n**Safety Guarantees:**\n- Division by zero returns 0 (not NaN)\n- Empty datasets return `null` for all metrics\n- Infinity values (e.g., profit factor with no losses) are caught and nullified\n- Type checking prevents non-numeric values\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:37-48](), [src/lib/services/markdown/BacktestMarkdownService.ts:286-293](), [src/lib/services/markdown/LiveMarkdownService.ts:24-35]()\n\n---\n\n## Accessing Statistics\n\nEach markdown service provides a `getData()` method to retrieve statistics programmatically. These methods return the full statistics interface with all calculated metrics.\n\n```mermaid\ngraph LR\n    subgraph \"Public API\"\n        BT_API[\"Backtest.getData()\"]\n        LIVE_API[\"Live.getData()\"]\n        SCHED_API[\"Schedule.getData()\"]\n        HEAT_API[\"Heat.getData()\"]\n        PERF_API[\"Performance.getData()\"]\n        PARTIAL_API[\"Partial.getData()\"]\n    end\n    \n    subgraph \"Service Methods\"\n        BT_SVC[\"BacktestMarkdownService.getData()\"]\n        LIVE_SVC[\"LiveMarkdownService.getData()\"]\n        SCHED_SVC[\"ScheduleMarkdownService.getData()\"]\n        HEAT_SVC[\"HeatMarkdownService.getData()\"]\n        PERF_SVC[\"PerformanceMarkdownService.getData()\"]\n        PARTIAL_SVC[\"PartialMarkdownService.getData()\"]\n    end\n    \n    subgraph \"Storage\"\n        BT_STORAGE[\"ReportStorage.getData()\"]\n        LIVE_STORAGE[\"ReportStorage.getData()\"]\n        SCHED_STORAGE[\"ReportStorage.getData()\"]\n        HEAT_STORAGE[\"HeatmapStorage.getData()\"]\n        PERF_STORAGE[\"PerformanceStorage.getData()\"]\n        PARTIAL_STORAGE[\"ReportStorage.getData()\"]\n    end\n    \n    subgraph \"Output Types\"\n        BT_OUT[\"BacktestStatistics\"]\n        LIVE_OUT[\"LiveStatistics\"]\n        SCHED_OUT[\"ScheduleStatistics\"]\n        HEAT_OUT[\"IHeatmapStatistics\"]\n        PERF_OUT[\"PerformanceStatistics\"]\n        PARTIAL_OUT[\"PartialStatistics\"]\n    end\n    \n    BT_API --> BT_SVC\n    LIVE_API --> LIVE_SVC\n    SCHED_API --> SCHED_SVC\n    HEAT_API --> HEAT_SVC\n    PERF_API --> PERF_SVC\n    PARTIAL_API --> PARTIAL_SVC\n    \n    BT_SVC --> BT_STORAGE\n    LIVE_SVC --> LIVE_STORAGE\n    SCHED_SVC --> SCHED_STORAGE\n    HEAT_SVC --> HEAT_STORAGE\n    PERF_SVC --> PERF_STORAGE\n    PARTIAL_SVC --> PARTIAL_STORAGE\n    \n    BT_STORAGE --> BT_OUT\n    LIVE_STORAGE --> LIVE_OUT\n    SCHED_STORAGE --> SCHED_OUT\n    HEAT_STORAGE --> HEAT_OUT\n    PERF_STORAGE --> PERF_OUT\n    PARTIAL_STORAGE --> PARTIAL_OUT\n```\n\n**Backtest Statistics Example:**\n\n```typescript\nimport { Backtest } from \"backtest-kit\";\n\n// After running a backtest\nconst stats = await Backtest.getData(\"BTCUSDT\", \"my-strategy\");\n\nconsole.log(`Total signals: ${stats.totalSignals}`);\nconsole.log(`Win rate: ${stats.winRate?.toFixed(2)}%`);\nconsole.log(`Sharpe ratio: ${stats.sharpeRatio?.toFixed(3)}`);\nconsole.log(`Total PNL: ${stats.totalPnl?.toFixed(2)}%`);\n\n// Access raw signal data\nfor (const signal of stats.signalList) {\n  console.log(`Signal ${signal.signal.id}: ${signal.pnl.pnlPercentage}%`);\n}\n```\n\n**Live Statistics Example:**\n\n```typescript\nimport { Live } from \"backtest-kit\";\n\n// After running live trading\nconst stats = await Live.getData(\"BTCUSDT\", \"my-strategy\");\n\nconsole.log(`Total events: ${stats.totalEvents}`);\nconsole.log(`Closed signals: ${stats.totalClosed}`);\nconsole.log(`Expected yearly returns: ${stats.expectedYearlyReturns?.toFixed(2)}%`);\n\n// Access all events (idle, opened, active, closed)\nfor (const event of stats.eventList) {\n  if (event.action === \"closed\") {\n    console.log(`Closed: ${event.pnl}%`);\n  }\n}\n```\n\n**Heatmap Statistics Example:**\n\n```typescript\nimport { Heat } from \"backtest-kit\";\n\n// Get portfolio-wide statistics\nconst heatmap = await Heat.getData(\"my-strategy\");\n\nconsole.log(`Total symbols: ${heatmap.totalSymbols}`);\nconsole.log(`Portfolio PNL: ${heatmap.portfolioTotalPnl?.toFixed(2)}%`);\nconsole.log(`Portfolio Sharpe: ${heatmap.portfolioSharpeRatio?.toFixed(3)}`);\n\n// Analyze each symbol\nfor (const row of heatmap.symbols) {\n  console.log(`${row.symbol}:`);\n  console.log(`  Total PNL: ${row.totalPnl?.toFixed(2)}%`);\n  console.log(`  Max Drawdown: ${row.maxDrawdown?.toFixed(2)}%`);\n  console.log(`  Profit Factor: ${row.profitFactor?.toFixed(2)}`);\n}\n```\n\n**Sources:** [src/classes/Backtest.ts](), [src/classes/Live.ts](), [src/classes/Heat.ts](), [src/lib/services/markdown/BacktestMarkdownService.ts:456-463](), [src/lib/services/markdown/LiveMarkdownService.ts:663-670](), [src/lib/services/markdown/HeatMarkdownService.ts:320-326]()\n\n---\n\n## Statistics by Service\n\nThe following table maps which metrics are available in each statistics interface:\n\n| Metric | Backtest | Live | Schedule | Walker | Performance | Heat |\n|--------|----------|------|----------|--------|-------------|------|\n| **signalList / eventList** | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |\n| **totalSignals / totalEvents** | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |\n| **winCount** | ✓ | ✓ | - | - | - | ✓ |\n| **lossCount** | ✓ | ✓ | - | - | - | ✓ |\n| **winRate** | ✓ | ✓ | - | - | - | ✓ |\n| **avgPnl** | ✓ | ✓ | - | - | - | ✓ |\n| **totalPnl** | ✓ | ✓ | - | - | - | ✓ |\n| **stdDev** | ✓ | ✓ | - | - | ✓ | ✓ |\n| **sharpeRatio** | ✓ | ✓ | - | - | - | ✓ |\n| **annualizedSharpeRatio** | ✓ | ✓ | - | - | - | - |\n| **certaintyRatio** | ✓ | ✓ | - | - | - | - |\n| **expectedYearlyReturns** | ✓ | ✓ | - | - | - | - |\n| **profitFactor** | - | - | - | - | - | ✓ |\n| **maxDrawdown** | - | - | - | - | - | ✓ |\n| **expectancy** | - | - | - | - | - | ✓ |\n| **cancellationRate** | - | - | ✓ | - | - | - |\n| **activationRate** | - | - | ✓ | - | - | - |\n| **avgDuration** | - | - | - | - | ✓ | - |\n| **median / p95 / p99** | - | - | - | - | ✓ | - |\n| **bestStrategy / bestMetric** | - | - | - | ✓ | - | - |\n\n**Notes:**\n- `BacktestStatistics` and `LiveStatistics` have identical metrics\n- `ScheduleStatistics` focuses on scheduled signal lifecycle (activation/cancellation)\n- `PerformanceStatistics` measures execution timing (durations, percentiles, wait times)\n- `HeatMarkdownService` includes advanced portfolio metrics (profit factor, max drawdown, expectancy)\n- `WalkerStatistics` compares multiple strategies and identifies the best performer\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:70-106](), [src/lib/services/markdown/LiveMarkdownService.ts:97-136](), [src/lib/services/markdown/ScheduleMarkdownService.ts:72-99](), [src/lib/services/markdown/WalkerMarkdownService.ts:23-26](), [src/lib/services/markdown/PerformanceMarkdownService.ts:60-75](), [src/lib/services/markdown/HeatMarkdownService.ts:1-56]()\n\n---\n\n## Null Value Handling\n\nAll calculated metrics can be `null` if:\n1. No data available (empty signal list)\n2. Division by zero (e.g., Sharpe ratio when stdDev = 0)\n3. Invalid calculation result (NaN, Infinity)\n4. Insufficient data for calculation\n\n**Display Pattern in Reports:**\n\n[src/lib/services/markdown/BacktestMarkdownService.ts:331-338]()\n```typescript\n`**Win rate:** ${stats.winRate === null ? \"N/A\" : `${stats.winRate.toFixed(2)}% (${stats.winCount}W / ${stats.lossCount}L) (higher is better)`}`,\n`**Average PNL:** ${stats.avgPnl === null ? \"N/A\" : `${stats.avgPnl > 0 ? \"+\" : \"\"}${stats.avgPnl.toFixed(2)}% (higher is better)`}`,\n`**Total PNL:** ${stats.totalPnl === null ? \"N/A\" : `${stats.totalPnl > 0 ? \"+\" : \"\"}${stats.totalPnl.toFixed(2)}% (higher is better)`}`,\n`**Standard Deviation:** ${stats.stdDev === null ? \"N/A\" : `${stats.stdDev.toFixed(3)}% (lower is better)`}`,\n`**Sharpe Ratio:** ${stats.sharpeRatio === null ? \"N/A\" : `${stats.sharpeRatio.toFixed(3)} (higher is better)`}`,\n`**Annualized Sharpe Ratio:** ${stats.annualizedSharpeRatio === null ? \"N/A\" : `${stats.annualizedSharpeRatio.toFixed(3)} (higher is better)`}`,\n`**Certainty Ratio:** ${stats.certaintyRatio === null ? \"N/A\" : `${stats.certaintyRatio.toFixed(3)} (higher is better)`}`,\n`**Expected Yearly Returns:** ${stats.expectedYearlyReturns === null ? \"N/A\" : `${stats.expectedYearlyReturns > 0 ? \"+\" : \"\"}${stats.expectedYearlyReturns.toFixed(2)}% (higher is better)`}`,\n```\n\nThis pattern ensures reports always display meaningful information, even when calculations fail or data is insufficient.\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:331-338](), [src/lib/services/markdown/LiveMarkdownService.ts:528-536]()"
                    },
                    {
                        "page_plan": {
                            "id": "8.3",
                            "title": "Portfolio Heatmaps"
                        },
                        "content": "# Portfolio Heatmaps\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [src/interfaces/Heatmap.interface.ts](src/interfaces/Heatmap.interface.ts)\n- [src/lib/services/markdown/BacktestMarkdownService.ts](src/lib/services/markdown/BacktestMarkdownService.ts)\n- [src/lib/services/markdown/HeatMarkdownService.ts](src/lib/services/markdown/HeatMarkdownService.ts)\n- [src/lib/services/markdown/LiveMarkdownService.ts](src/lib/services/markdown/LiveMarkdownService.ts)\n- [src/lib/services/markdown/PartialMarkdownService.ts](src/lib/services/markdown/PartialMarkdownService.ts)\n- [src/lib/services/markdown/PerformanceMarkdownService.ts](src/lib/services/markdown/PerformanceMarkdownService.ts)\n- [src/lib/services/markdown/ScheduleMarkdownService.ts](src/lib/services/markdown/ScheduleMarkdownService.ts)\n- [src/lib/services/markdown/WalkerMarkdownService.ts](src/lib/services/markdown/WalkerMarkdownService.ts)\n- [test/e2e/defend.test.mjs](test/e2e/defend.test.mjs)\n- [test/e2e/risk.test.mjs](test/e2e/risk.test.mjs)\n- [test/index.mjs](test/index.mjs)\n- [test/mock/getMockCandles.mjs](test/mock/getMockCandles.mjs)\n- [test/spec/heat.test.mjs](test/spec/heat.test.mjs)\n- [test/spec/list.test.mjs](test/spec/list.test.mjs)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\nPortfolio heatmaps provide symbol-level performance analysis across all trading strategies. This system aggregates closed signals by trading pair (symbol) and calculates comprehensive statistics for each symbol, enabling portfolio-wide comparison and risk assessment. Unlike per-strategy reports (see [Performance Statistics](#8.2)), heatmaps focus on symbol-level aggregation, answering questions like \"Which symbols perform best across all strategies?\" and \"What is the portfolio's total exposure per symbol?\".\n\nFor individual strategy performance metrics, see [Performance Statistics](#8.2). For live trading reports, see [Reporting and Analytics](#8).\n\n**Sources**: [src/lib/services/markdown/HeatMarkdownService.ts:1-596]()\n\n---\n\n## Heatmap Data Structure\n\nThe heatmap system uses two primary interfaces: `IHeatmapRow` for per-symbol statistics and `IHeatmapStatistics` for portfolio-wide aggregation.\n\n### Per-Symbol Statistics (IHeatmapRow)\n\nEach symbol in the portfolio is represented by an `IHeatmapRow` containing 17 metrics:\n\n| Metric | Type | Description | Interpretation |\n|--------|------|-------------|----------------|\n| `symbol` | `string` | Trading pair identifier (e.g., \"BTCUSDT\") | Primary key for grouping |\n| `totalPnl` | `number \\| null` | Cumulative profit/loss percentage | Higher is better |\n| `sharpeRatio` | `number \\| null` | Risk-adjusted return (avgPnl / stdDev) | Higher is better |\n| `maxDrawdown` | `number \\| null` | Largest peak-to-trough decline | Lower is better |\n| `totalTrades` | `number` | Number of closed trades | Volume indicator |\n| `winCount` | `number` | Number of winning trades | Win frequency |\n| `lossCount` | `number` | Number of losing trades | Loss frequency |\n| `winRate` | `number \\| null` | Percentage of winning trades (0-100) | Higher is better |\n| `avgPnl` | `number \\| null` | Average profit/loss per trade | Higher is better |\n| `stdDev` | `number \\| null` | Standard deviation of returns | Volatility measure |\n| `profitFactor` | `number \\| null` | Sum of wins / sum of losses | >1 is profitable |\n| `avgWin` | `number \\| null` | Average profit on winning trades | Upside magnitude |\n| `avgLoss` | `number \\| null` | Average loss on losing trades | Downside magnitude |\n| `maxWinStreak` | `number` | Maximum consecutive wins | Best streak |\n| `maxLossStreak` | `number` | Maximum consecutive losses | Worst streak |\n| `expectancy` | `number \\| null` | (winRate × avgWin) - (lossRate × avgLoss) | Expected return per trade |\n\nAll percentage-based metrics can be `null` if calculation is unsafe (division by zero, NaN, Infinity).\n\n### Portfolio-Wide Statistics (IHeatmapStatistics)\n\nPortfolio aggregation combines all symbols into summary metrics:\n\n```typescript\ninterface IHeatmapStatistics {\n  symbols: IHeatmapRow[];           // Array of all symbol statistics\n  totalSymbols: number;             // Count of unique symbols\n  portfolioTotalPnl: number | null; // Sum of all symbol PNLs\n  portfolioSharpeRatio: number | null; // Portfolio-wide Sharpe ratio\n  portfolioTotalTrades: number;     // Total trades across all symbols\n}\n```\n\n**Sources**: [src/interfaces/Heatmap.interface.ts:1-56](), [src/lib/services/markdown/HeatMarkdownService.ts:180-212]()\n\n---\n\n## HeatMarkdownService Architecture\n\nThe `HeatMarkdownService` class implements the heatmap generation pipeline using the ReportStorage pattern.\n\n### Component Overview\n\n```mermaid\ngraph TB\n    signalEmitter[\"signalEmitter<br/>(functools-kit Subject)\"]\n    HeatService[\"HeatMarkdownService<br/>Main orchestrator\"]\n    HeatStorage[\"HeatmapStorage<br/>Per-strategy data store\"]\n    \n    signalEmitter -->|\"subscribe(tick)\"| HeatService\n    HeatService -->|\"getStorage(strategyName)\"| HeatStorage\n    \n    HeatStorage -->|\"symbolData: Map&lt;symbol, signals[]&gt;\"| SymbolMap[\"Per-Symbol Storage\"]\n    \n    SymbolMap --> CalcStats[\"calculateSymbolStats()<br/>Compute IHeatmapRow\"]\n    CalcStats --> Aggregation[\"Portfolio Aggregation<br/>Sum PNLs, Sharpe, etc.\"]\n    \n    Aggregation --> HeatStats[\"IHeatmapStatistics\"]\n    \n    HeatService --> PublicAPI[\"Heat Facade<br/>getData/getReport/dump\"]\n    PublicAPI --> HeatStats\n    \n    style HeatService fill:#e1f5ff\n    style HeatStorage fill:#fff4e1\n    style PublicAPI fill:#e8f5e9\n```\n\n### Key Classes and Methods\n\n#### HeatMarkdownService\n\nLocated at [src/lib/services/markdown/HeatMarkdownService.ts:442-596](), this service:\n\n- **Subscribes to events**: `signalEmitter.subscribe(this.tick)` at [line 582]()\n- **Memoizes storage**: `getStorage = memoize<(strategyName: string) => HeatmapStorage>` at [line 460]()\n- **Filters closed signals**: Only processes `action === \"closed\"` at [line 475]()\n- **Provides public API**: `getData()`, `getReport()`, `dump()`, `clear()` methods\n\n#### HeatmapStorage\n\nLocated at [src/lib/services/markdown/HeatMarkdownService.ts:147-442](), this class:\n\n- **Stores signals per symbol**: `symbolData: Map<string, IStrategyTickResultClosed[]>` at [line 149]()\n- **Enforces MAX_EVENTS**: Limits to 250 signals per symbol at [line 141, 165-170]()\n- **Calculates symbol stats**: `calculateSymbolStats()` at [line 180-296]()\n- **Aggregates portfolio**: `getData()` at [line 305-442]()\n\n**Sources**: [src/lib/services/markdown/HeatMarkdownService.ts:142-596]()\n\n---\n\n## Data Flow: Signal to Heatmap\n\nThe following diagram shows how closed signals are processed into portfolio heatmap statistics:\n\n```mermaid\ngraph TB\n    subgraph \"Signal Generation\"\n        BacktestRun[\"Backtest.run()<br/>Historical execution\"]\n        LiveRun[\"Live.run()<br/>Real-time execution\"]\n        ClientStrategy[\"ClientStrategy.backtest()<br/>Signal closure\"]\n    end\n    \n    subgraph \"Event Emission\"\n        signalEmitter[\"signalEmitter.next()<br/>IStrategyTickResultClosed\"]\n        signalBacktestEmitter[\"signalBacktestEmitter\"]\n        signalLiveEmitter[\"signalLiveEmitter\"]\n    end\n    \n    subgraph \"HeatMarkdownService Processing\"\n        TickHandler[\"tick(data: IStrategyTickResult)<br/>Filter action === 'closed'\"]\n        GetStorage[\"getStorage(strategyName)<br/>Memoized per-strategy\"]\n        AddSignal[\"HeatmapStorage.addSignal()<br/>Group by symbol\"]\n    end\n    \n    subgraph \"HeatmapStorage State\"\n        SymbolDataMap[\"symbolData: Map&lt;symbol, signals[]&gt;<br/>BTCUSDT: [sig1, sig2, ...]<br/>ETHUSDT: [sig3, sig4, ...]\"]\n        MaxEventsCheck[\"MAX_EVENTS = 250<br/>Trim old signals per symbol\"]\n    end\n    \n    subgraph \"Statistics Calculation\"\n        CalcSymbol[\"calculateSymbolStats(symbol, signals)<br/>Per-symbol metrics\"]\n        \n        CalcMetrics[\"Calculate:<br/>- totalPnl = sum(pnl)<br/>- winRate = wins/total<br/>- sharpeRatio = avgPnl/stdDev<br/>- profitFactor = sumWins/sumLosses<br/>- maxDrawdown = max decline<br/>- expectancy = winRate×avgWin - lossRate×avgLoss\"]\n        \n        CalcSymbol --> CalcMetrics\n    end\n    \n    subgraph \"Portfolio Aggregation\"\n        AggregateLoop[\"Loop over all symbols\"]\n        SumPortfolio[\"portfolioTotalPnl = Σ(symbol.totalPnl)<br/>portfolioTotalTrades = Σ(symbol.totalTrades)\"]\n        \n        CalcPortfolioSharpe[\"portfolioSharpeRatio:<br/>1. Collect all PNL values<br/>2. Calculate portfolio stdDev<br/>3. Sharpe = avgPnl / stdDev\"]\n        \n        AggregateLoop --> SumPortfolio\n        AggregateLoop --> CalcPortfolioSharpe\n    end\n    \n    subgraph \"Output\"\n        HeatStats[\"IHeatmapStatistics<br/>symbols: IHeatmapRow[]<br/>totalSymbols<br/>portfolioTotalPnl<br/>portfolioSharpeRatio<br/>portfolioTotalTrades\"]\n        \n        MarkdownReport[\"Markdown Report<br/>- Symbol comparison table<br/>- Portfolio summary<br/>- Sorted by totalPnl\"]\n    end\n    \n    BacktestRun --> ClientStrategy\n    LiveRun --> ClientStrategy\n    ClientStrategy --> signalEmitter\n    signalEmitter --> signalBacktestEmitter\n    signalEmitter --> signalLiveEmitter\n    \n    signalEmitter --> TickHandler\n    TickHandler --> GetStorage\n    GetStorage --> AddSignal\n    \n    AddSignal --> SymbolDataMap\n    SymbolDataMap --> MaxEventsCheck\n    \n    MaxEventsCheck --> CalcSymbol\n    CalcMetrics --> AggregateLoop\n    \n    SumPortfolio --> HeatStats\n    CalcPortfolioSharpe --> HeatStats\n    \n    HeatStats --> MarkdownReport\n    \n    style TickHandler fill:#e1f5ff\n    style CalcMetrics fill:#fff4e1\n    style HeatStats fill:#e8f5e9\n```\n\n**Sources**: [src/lib/services/markdown/HeatMarkdownService.ts:470-494](), [src/lib/services/markdown/HeatMarkdownService.ts:155-170](), [src/lib/services/markdown/HeatMarkdownService.ts:180-296]()\n\n---\n\n## Metric Calculation Details\n\n### Per-Symbol Metrics\n\nThe `calculateSymbolStats()` method at [src/lib/services/markdown/HeatMarkdownService.ts:180-296]() computes all 17 metrics for a single symbol:\n\n#### Basic Counts\n```\ntotalTrades = signals.length\nwinCount = signals.filter(s => s.pnl.pnlPercentage > 0).length\nlossCount = signals.filter(s => s.pnl.pnlPercentage < 0).length\n```\n\n#### Win Rate and PNL\n```\nwinRate = (winCount / totalTrades) × 100\ntotalPnl = sum(signals.map(s => s.pnl.pnlPercentage))\navgPnl = totalPnl / totalTrades\n```\n\n#### Risk Metrics\n```\nvariance = sum((pnl - avgPnl)²) / totalTrades\nstdDev = sqrt(variance)\nsharpeRatio = avgPnl / stdDev  (if stdDev > 0)\n```\n\n#### Profit Factor\n```\nsumWins = sum(winning trades PNL)\nsumLosses = sum(losing trades PNL)  // Negative value\nprofitFactor = sumWins / abs(sumLosses)  (if sumLosses < 0)\n```\n\n#### Drawdown Calculation\n\nMaximum drawdown tracks the largest peak-to-trough decline:\n\n```\npeakEquity = 0\ncurrentEquity = 0\nmaxDrawdown = 0\n\nfor each signal in chronological order:\n  currentEquity += signal.pnl.pnlPercentage\n  if currentEquity > peakEquity:\n    peakEquity = currentEquity\n  drawdown = peakEquity - currentEquity\n  if drawdown > maxDrawdown:\n    maxDrawdown = drawdown\n```\n\nImplemented at [src/lib/services/markdown/HeatMarkdownService.ts:248-262]().\n\n#### Win/Loss Streaks\n\nConsecutive win/loss tracking:\n\n```\ncurrentWinStreak = 0\ncurrentLossStreak = 0\nmaxWinStreak = 0\nmaxLossStreak = 0\n\nfor each signal:\n  if signal.pnl > 0:\n    currentWinStreak++\n    currentLossStreak = 0\n    maxWinStreak = max(maxWinStreak, currentWinStreak)\n  else if signal.pnl < 0:\n    currentLossStreak++\n    currentWinStreak = 0\n    maxLossStreak = max(maxLossStreak, currentLossStreak)\n```\n\nImplemented at [src/lib/services/markdown/HeatMarkdownService.ts:264-281]().\n\n#### Expectancy\n\nExpected return per trade:\n\n```\nlossRate = 100 - winRate\nexpectancy = (winRate / 100) × avgWin - (lossRate / 100) × abs(avgLoss)\n```\n\nImplemented at [src/lib/services/markdown/HeatMarkdownService.ts:283-291]().\n\n**Sources**: [src/lib/services/markdown/HeatMarkdownService.ts:180-296]()\n\n### Portfolio-Wide Metrics\n\nThe `getData()` method at [src/lib/services/markdown/HeatMarkdownService.ts:305-442]() aggregates symbol statistics into portfolio metrics:\n\n#### Portfolio Total PNL\n\nSum of all symbol PNLs:\n\n```\nportfolioTotalPnl = symbols.reduce((sum, row) => \n  sum + (row.totalPnl ?? 0), 0\n)\n```\n\nImplemented at [src/lib/services/markdown/HeatMarkdownService.ts:373-379]().\n\n#### Portfolio Sharpe Ratio\n\nPortfolio-level risk-adjusted return:\n\n```\n// Collect all individual trade PNLs across all symbols\nallPnls = []\nfor each symbol:\n  for each signal in symbol:\n    allPnls.push(signal.pnl.pnlPercentage)\n\n// Calculate portfolio-level statistics\nportfolioAvgPnl = sum(allPnls) / allPnls.length\nportfolioVariance = sum((pnl - portfolioAvgPnl)²) / allPnls.length\nportfolioStdDev = sqrt(portfolioVariance)\nportfolioSharpeRatio = portfolioAvgPnl / portfolioStdDev\n```\n\nImplemented at [src/lib/services/markdown/HeatMarkdownService.ts:381-407]().\n\n#### Portfolio Total Trades\n\nCount of all closed trades:\n\n```\nportfolioTotalTrades = symbols.reduce((sum, row) => \n  sum + row.totalTrades, 0\n)\n```\n\nImplemented at [src/lib/services/markdown/HeatMarkdownService.ts:410-411]().\n\n**Sources**: [src/lib/services/markdown/HeatMarkdownService.ts:305-442]()\n\n---\n\n## Heat Facade API\n\nThe `Heat` class at [src/classes/Heat.ts]() provides a simplified public API for accessing heatmap data. All methods delegate to `HeatMarkdownService` via dependency injection.\n\n### API Methods\n\n```mermaid\ngraph LR\n    subgraph \"Heat Facade (src/classes/Heat.ts)\"\n        getData[\"Heat.getData(strategyName)<br/>Returns IHeatmapStatistics\"]\n        getReport[\"Heat.getReport(strategyName)<br/>Returns markdown string\"]\n        dump[\"Heat.dump(strategyName, path?)<br/>Writes to ./dump/heat/\"]\n        clear[\"Heat.clear(strategyName?)<br/>Clears storage\"]\n    end\n    \n    subgraph \"HeatMarkdownService\"\n        ServiceGetData[\"heatMarkdownService.getData(strategyName)\"]\n        ServiceGetReport[\"heatMarkdownService.getReport(strategyName)\"]\n        ServiceDump[\"heatMarkdownService.dump(strategyName, path)\"]\n        ServiceClear[\"heatMarkdownService.clear(strategyName)\"]\n    end\n    \n    getData --> ServiceGetData\n    getReport --> ServiceGetReport\n    dump --> ServiceDump\n    clear --> ServiceClear\n    \n    ServiceGetData --> Return1[\"IHeatmapStatistics<br/>Programmatic access\"]\n    ServiceGetReport --> Return2[\"Markdown string<br/>Report text\"]\n    ServiceDump --> Return3[\"File write<br/>.md file saved\"]\n    ServiceClear --> Return4[\"void<br/>Storage cleared\"]\n    \n    style getData fill:#e1f5ff\n    style Return1 fill:#e8f5e9\n```\n\n### Method Details\n\n#### getData(strategyName: string): Promise\\<IHeatmapStatistics\\>\n\nReturns raw heatmap statistics for programmatic access. Useful for custom analysis or visualization.\n\n```typescript\nconst stats = await Heat.getData(\"my-strategy\");\n\nconsole.log(`Portfolio total PNL: ${stats.portfolioTotalPnl}%`);\nconsole.log(`Portfolio Sharpe: ${stats.portfolioSharpeRatio}`);\nconsole.log(`Symbols tracked: ${stats.totalSymbols}`);\n\n// Find best performing symbol\nconst bestSymbol = stats.symbols.reduce((best, current) => \n  (current.totalPnl ?? -Infinity) > (best.totalPnl ?? -Infinity) ? current : best\n);\nconsole.log(`Best symbol: ${bestSymbol.symbol} (${bestSymbol.totalPnl}%)`);\n```\n\nImplemented at [src/lib/services/markdown/HeatMarkdownService.ts:505-531]().\n\n#### getReport(strategyName: string): Promise\\<string\\>\n\nGenerates a markdown-formatted report with two tables:\n1. **Symbol Comparison Table**: All symbols sorted by totalPnl (descending)\n2. **Portfolio Summary**: Aggregated metrics\n\n```typescript\nconst markdown = await Heat.getReport(\"my-strategy\");\nconsole.log(markdown);\n```\n\nReport format at [src/lib/services/markdown/HeatMarkdownService.ts:345-442]():\n- Header with strategy name\n- Symbol comparison table with 12 columns\n- Portfolio summary section\n- Bottom notes explaining metrics\n\n#### dump(strategyName: string, path?: string): Promise\\<void\\>\n\nSaves the markdown report to disk. Default path: `./dump/heat/{strategyName}.md`.\n\n```typescript\n// Save to default location\nawait Heat.dump(\"my-strategy\");\n// Saved to: ./dump/heat/my-strategy.md\n\n// Save to custom location\nawait Heat.dump(\"my-strategy\", \"./reports/portfolio\");\n// Saved to: ./reports/portfolio/my-strategy.md\n```\n\nImplemented at [src/lib/services/markdown/HeatMarkdownService.ts:543-569]().\n\n#### clear(strategyName?: string): Promise\\<void\\>\n\nClears accumulated data from memory. If `strategyName` provided, clears only that strategy's data. Otherwise, clears all strategies.\n\n```typescript\n// Clear specific strategy\nawait Heat.clear(\"my-strategy\");\n\n// Clear all strategies\nawait Heat.clear();\n```\n\nImplemented at [src/lib/services/markdown/HeatMarkdownService.ts:571-578]().\n\n**Sources**: [src/classes/Heat.ts](), [src/lib/services/markdown/HeatMarkdownService.ts:505-578]()\n\n---\n\n## Report Format\n\nThe markdown report generated by `getReport()` includes a symbol comparison table and portfolio summary.\n\n### Symbol Comparison Table\n\nColumns (12 total):\n\n| Column | Label | Format | Source |\n|--------|-------|--------|--------|\n| Symbol | \"Symbol\" | `symbol` | [line 59-62]() |\n| Total PNL | \"Total PNL\" | `+X.XX%` or `N/A` | [line 64-68]() |\n| Sharpe | \"Sharpe\" | `X.XX` or `N/A` | [line 70-75]() |\n| PF | \"PF\" | `X.XX` or `N/A` | [line 77-82]() |\n| Expect | \"Expect\" | `+X.XX%` or `N/A` | [line 84-89]() |\n| WR | \"WR\" | `XX.X%` or `N/A` | [line 91-96]() |\n| Avg Win | \"Avg Win\" | `+X.XX%` or `N/A` | [line 98-103]() |\n| Avg Loss | \"Avg Loss\" | `-X.XX%` or `N/A` | [line 105-110]() |\n| Max DD | \"Max DD\" | `XX.XX%` or `N/A` | [line 112-117]() |\n| W Streak | \"W Streak\" | `N` | [line 119-124]() |\n| L Streak | \"L Streak\" | `N` | [line 126-131]() |\n| Trades | \"Trades\" | `N` | [line 133-138]() |\n\nSorting: Symbols are sorted by `totalPnl` in descending order (best first) at [line 423]().\n\n### Portfolio Summary Section\n\nAppears after the table at [line 432-436]():\n\n```\n**Total Symbols:** 5\n**Portfolio Total PNL:** +42.50%\n**Portfolio Sharpe Ratio:** 1.85\n**Portfolio Total Trades:** 127\n```\n\n**Sources**: [src/lib/services/markdown/HeatMarkdownService.ts:57-138](), [src/lib/services/markdown/HeatMarkdownService.ts:345-442]()\n\n---\n\n## Usage Examples\n\n### Basic Backtest Heatmap\n\nRun multiple backtests on different symbols, then view portfolio heatmap:\n\n```typescript\nimport { addStrategy, addExchange, addFrame, Backtest, Heat } from \"backtest-kit\";\n\n// Register strategy, exchange, frame (omitted for brevity)\n// ...\n\n// Run backtests on multiple symbols\nfor await (const _ of Backtest.run(\"BTCUSDT\", {\n  strategyName: \"trend-follow\",\n  exchangeName: \"binance\",\n  frameName: \"30d-test\"\n})) {}\n\nfor await (const _ of Backtest.run(\"ETHUSDT\", {\n  strategyName: \"trend-follow\",\n  exchangeName: \"binance\",\n  frameName: \"30d-test\"\n})) {}\n\n// Get heatmap data\nconst stats = await Heat.getData(\"trend-follow\");\n\nconsole.log(`Portfolio: ${stats.portfolioTotalPnl}% PNL`);\nconsole.log(`Best symbol: ${stats.symbols[0].symbol}`);\n\n// Save report\nawait Heat.dump(\"trend-follow\");\n```\n\n**Sources**: [test/spec/heat.test.mjs:14-84]()\n\n### Multi-Symbol Portfolio Analysis\n\nAnalyze portfolio distribution and risk:\n\n```typescript\nconst stats = await Heat.getData(\"my-portfolio-strategy\");\n\n// Find high-risk symbols (high std dev, low Sharpe)\nconst riskySymbols = stats.symbols.filter(row => \n  (row.sharpeRatio ?? 0) < 1.0 && \n  (row.stdDev ?? 0) > 5.0\n);\n\nconsole.log(\"High-risk symbols:\", riskySymbols.map(s => s.symbol));\n\n// Find symbols with large drawdowns\nconst highDrawdown = stats.symbols.filter(row =>\n  (row.maxDrawdown ?? 0) > 10.0\n);\n\nconsole.log(\"Symbols with >10% drawdown:\", \n  highDrawdown.map(s => `${s.symbol}: ${s.maxDrawdown}%`)\n);\n\n// Calculate portfolio concentration\nstats.symbols.forEach(row => {\n  const concentration = (row.totalTrades / stats.portfolioTotalTrades) * 100;\n  console.log(`${row.symbol}: ${concentration.toFixed(1)}% of trades`);\n});\n```\n\n**Sources**: [test/spec/heat.test.mjs:86-161]()\n\n### Live Trading Portfolio Monitoring\n\nTrack portfolio performance in real-time:\n\n```typescript\nimport { Live, Heat, listenDoneLive } from \"backtest-kit\";\n\n// Start live trading on multiple symbols\nLive.background(\"BTCUSDT\", {\n  strategyName: \"live-strategy\",\n  exchangeName: \"binance\"\n});\n\nLive.background(\"ETHUSDT\", {\n  strategyName: \"live-strategy\",\n  exchangeName: \"binance\"\n});\n\n// Periodically check portfolio health\nsetInterval(async () => {\n  const stats = await Heat.getData(\"live-strategy\");\n  \n  if ((stats.portfolioSharpeRatio ?? 0) < 0.5) {\n    console.warn(\"Portfolio Sharpe ratio degraded!\");\n  }\n  \n  // Save snapshot\n  await Heat.dump(\"live-strategy\", \"./live-reports\");\n}, 60000); // Every minute\n```\n\n**Sources**: [src/lib/services/markdown/HeatMarkdownService.ts:1-596]()\n\n### Comparing Strategies by Symbol Performance\n\nUse heatmaps to compare which strategy performs best per symbol:\n\n```typescript\nconst strategy1 = await Heat.getData(\"momentum-strategy\");\nconst strategy2 = await Heat.getData(\"mean-reversion-strategy\");\n\n// Compare BTCUSDT performance\nconst btc1 = strategy1.symbols.find(s => s.symbol === \"BTCUSDT\");\nconst btc2 = strategy2.symbols.find(s => s.symbol === \"BTCUSDT\");\n\nconsole.log(`BTCUSDT Momentum: ${btc1?.totalPnl}% PNL, ${btc1?.sharpeRatio} Sharpe`);\nconsole.log(`BTCUSDT Mean-Rev: ${btc2?.totalPnl}% PNL, ${btc2?.sharpeRatio} Sharpe`);\n\n// Find symbols where strategy1 outperforms\nconst strategy1Wins = strategy1.symbols.filter(row1 => {\n  const row2 = strategy2.symbols.find(r => r.symbol === row1.symbol);\n  return (row1.totalPnl ?? 0) > (row2?.totalPnl ?? 0);\n});\n\nconsole.log(`Strategy 1 wins on: ${strategy1Wins.map(s => s.symbol)}`);\n```\n\n**Sources**: [test/spec/heat.test.mjs:86-280]()\n\n---\n\n## Integration with Event System\n\nThe heatmap service subscribes to the global `signalEmitter` at initialization, capturing all closed signals from both backtest and live modes.\n\n### Event Subscription Flow\n\n```mermaid\ngraph TB\n    subgraph \"Signal Generation Sources\"\n        BacktestLogic[\"BacktestLogicPrivateService<br/>Backtest execution\"]\n        LiveLogic[\"LiveLogicPrivateService<br/>Live execution\"]\n        ClientStrategy[\"ClientStrategy.backtest()<br/>Signal closure detection\"]\n    end\n    \n    subgraph \"Event Emission\"\n        EmitClosed[\"signalEmitter.next()<br/>IStrategyTickResultClosed\"]\n        EmitBacktest[\"signalBacktestEmitter.next()\"]\n        EmitLive[\"signalLiveEmitter.next()\"]\n    end\n    \n    subgraph \"HeatMarkdownService Subscription\"\n        Init[\"HeatMarkdownService.init()<br/>singleshot initialization\"]\n        Subscribe[\"signalEmitter.subscribe(this.tick)\"]\n        TickFilter[\"tick(data)<br/>Filter: action === 'closed'\"]\n    end\n    \n    subgraph \"Storage Update\"\n        GetStorage[\"getStorage(data.strategyName)<br/>Memoized per strategy\"]\n        AddSignal[\"HeatmapStorage.addSignal(data)<br/>Group by symbol\"]\n        UpdateMap[\"symbolData.get(symbol).unshift(data)\"]\n    end\n    \n    ClientStrategy --> EmitClosed\n    EmitClosed --> EmitBacktest\n    EmitClosed --> EmitLive\n    \n    EmitClosed --> Subscribe\n    \n    Init --> Subscribe\n    Subscribe --> TickFilter\n    TickFilter --> GetStorage\n    GetStorage --> AddSignal\n    AddSignal --> UpdateMap\n    \n    BacktestLogic --> ClientStrategy\n    LiveLogic --> ClientStrategy\n    \n    style Init fill:#e1f5ff\n    style TickFilter fill:#fff4e1\n    style UpdateMap fill:#e8f5e9\n```\n\n### Initialization\n\nThe service uses the `singleshot` pattern to ensure subscription happens only once:\n\n```typescript\nprotected init = singleshot(async () => {\n  this.loggerService.log(\"heatMarkdownService init\");\n  signalEmitter.subscribe(this.tick);\n});\n```\n\nAt [src/lib/services/markdown/HeatMarkdownService.ts:580-584]().\n\nThis `init()` method is automatically called on first access to any public method (getData, getReport, dump) via the service pattern.\n\n### Tick Processing\n\nThe `tick()` method filters for closed signals only:\n\n```typescript\nprivate tick = async (data: IStrategyTickResult) => {\n  this.loggerService.log(\"heatMarkdownService tick\", { data });\n  \n  if (data.action !== \"closed\") {\n    return; // Ignore idle, opened, active, scheduled, cancelled\n  }\n  \n  const storage = this.getStorage(data.strategyName);\n  storage.addSignal(data);\n};\n```\n\nAt [src/lib/services/markdown/HeatMarkdownService.ts:470-494]().\n\n**Sources**: [src/lib/services/markdown/HeatMarkdownService.ts:470-494](), [src/lib/services/markdown/HeatMarkdownService.ts:580-584](), [src/config/emitters.ts:16-19]()\n\n---\n\n## Memory Management\n\nThe heatmap service implements bounded storage to prevent memory leaks in long-running processes.\n\n### MAX_EVENTS Limit\n\nEach symbol is limited to 250 closed signals:\n\n```typescript\nconst MAX_EVENTS = 250; // At line 141\n\npublic addSignal(data: IStrategyTickResultClosed) {\n  const { symbol } = data;\n  \n  if (!this.symbolData.has(symbol)) {\n    this.symbolData.set(symbol, []);\n  }\n  \n  const signals = this.symbolData.get(symbol)!;\n  signals.unshift(data); // Add to front\n  \n  // Trim queue if exceeded MAX_EVENTS per symbol\n  if (signals.length > MAX_EVENTS) {\n    signals.pop(); // Remove oldest\n  }\n}\n```\n\nAt [src/lib/services/markdown/HeatMarkdownService.ts:155-170]().\n\n### Storage Clearing\n\nThe `clear()` method allows manual memory management:\n\n```typescript\n// Clear specific strategy\nconst key = `${strategyName}`;\nthis.getStorage.clear(key); // Removes memoized instance\n\n// Clear all strategies\nthis.getStorage.clear(); // Removes all memoized instances\n```\n\nAt [src/lib/services/markdown/HeatMarkdownService.ts:571-578]().\n\n### Memoization Key\n\nThe `getStorage` function uses strategy name as the memoization key:\n\n```typescript\nprivate getStorage = memoize<(strategyName: string) => HeatmapStorage>(\n  (strategyName) => strategyName, // Key function\n  (strategyName) => new HeatmapStorage() // Factory function\n);\n```\n\nAt [src/lib/services/markdown/HeatMarkdownService.ts:460-463]().\n\nThis ensures each strategy gets its own isolated `HeatmapStorage` instance, preventing cross-contamination of data.\n\n**Sources**: [src/lib/services/markdown/HeatMarkdownService.ts:141](), [src/lib/services/markdown/HeatMarkdownService.ts:155-170](), [src/lib/services/markdown/HeatMarkdownService.ts:460-463](), [src/lib/services/markdown/HeatMarkdownService.ts:571-578]()"
                    },
                    {
                        "page_plan": {
                            "id": "9",
                            "title": "Advanced Features"
                        },
                        "content": "# Advanced Features\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [assets/uml.svg](assets/uml.svg)\n- [docs/classes/WalkerCommandService.md](docs/classes/WalkerCommandService.md)\n- [docs/interfaces/BacktestStatistics.md](docs/interfaces/BacktestStatistics.md)\n- [docs/interfaces/IStrategyCallbacks.md](docs/interfaces/IStrategyCallbacks.md)\n- [docs/interfaces/LiveStatistics.md](docs/interfaces/LiveStatistics.md)\n- [docs/internals.md](docs/internals.md)\n- [docs/types/IStrategyTickResult.md](docs/types/IStrategyTickResult.md)\n- [docs/uml.puml](docs/uml.puml)\n- [scripts/uml.mjs](scripts/uml.mjs)\n- [src/client/ClientStrategy.ts](src/client/ClientStrategy.ts)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [src/interfaces/Strategy.interface.ts](src/interfaces/Strategy.interface.ts)\n- [src/lib/services/connection/StrategyConnectionService.ts](src/lib/services/connection/StrategyConnectionService.ts)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\nThis document covers advanced capabilities of the backtest-kit framework that extend beyond basic strategy execution. These features enable production-ready live trading, comprehensive monitoring, and sophisticated profit/loss tracking. For basic strategy definition, see [Strategy System](#4). For execution modes, see [Execution Modes (Detailed)](#5).\n\nThe three advanced features covered are:\n1. **Crash Recovery and Persistence**: Atomic state storage with automatic recovery for live trading resilience\n2. **Event Listeners and Monitoring**: Comprehensive pub/sub event system for real-time tracking and alerting\n3. **Partial Profit and Loss**: Milestone-based tracking of unrealized profits and losses during active trades\n\n---\n\n## Crash Recovery and Persistence Architecture\n\nThe framework implements a crash-safe persistence system that enables live trading processes to recover from unexpected termination. All critical state is written atomically to JSON files, allowing processes to resume exactly where they left off.\n\n### Persistence Layer Overview\n\n```mermaid\ngraph TB\n    subgraph \"Abstract Base\"\n        PersistBase[\"PersistBase&lt;TEntity&gt;<br/>Abstract persistence adapter<br/>Generic entity storage\"]\n    end\n    \n    subgraph \"Concrete Adapters\"\n        PersistSignalAdapter[\"PersistSignalAdapter<br/>Signal state persistence<br/>./dump/signal_{symbol}_{strategy}.json\"]\n        PersistScheduleAdapter[\"PersistScheduleAdapter<br/>Scheduled signal persistence<br/>./dump/schedule_{symbol}_{strategy}.json\"]\n        PersistRiskAdapter[\"PersistRiskAdapter<br/>Risk state persistence<br/>./dump/risk_{symbol}_{risk}.json\"]\n        PersistPartialAdapter[\"PersistPartialAdapter<br/>Partial P/L persistence<br/>./dump/partial_{symbol}.json\"]\n    end\n    \n    subgraph \"Client Layer Consumers\"\n        ClientStrategy[\"ClientStrategy<br/>Uses Signal + Schedule adapters<br/>waitForInit recovery\"]\n        ClientRisk[\"ClientRisk<br/>Uses Risk adapter<br/>Position tracking\"]\n        ClientPartial[\"ClientPartial<br/>Uses Partial adapter<br/>Milestone cache\"]\n    end\n    \n    subgraph \"Persistence Operations\"\n        Write[\"write(entity)<br/>Atomic file write<br/>JSON.stringify\"]\n        Read[\"read()<br/>File read + parse<br/>JSON.parse\"]\n        Remove[\"remove()<br/>File deletion<br/>State cleanup\"]\n    end\n    \n    PersistBase --> PersistSignalAdapter\n    PersistBase --> PersistScheduleAdapter\n    PersistBase --> PersistRiskAdapter\n    PersistBase --> PersistPartialAdapter\n    \n    PersistSignalAdapter --> ClientStrategy\n    PersistScheduleAdapter --> ClientStrategy\n    PersistRiskAdapter --> ClientRisk\n    PersistPartialAdapter --> ClientPartial\n    \n    PersistSignalAdapter --> Write\n    PersistSignalAdapter --> Read\n    PersistSignalAdapter --> Remove\n    \n    Write -.->|\"Atomic operation\"| FS[\"File System<br/>./dump/ directory<br/>JSON files\"]\n    Read -.->|\"On init\"| FS\n    Remove -.->|\"On close\"| FS\n```\n\n**Sources**: [types.d.ts:163-176](), [src/client/ClientStrategy.ts:491-552](), Diagram 1 (Overall System Architecture)\n\n### PersistBase Abstract Class\n\n`PersistBase<TEntity>` provides the foundation for all persistence adapters with generic type-safe operations. Adapters extend this class and implement entity-specific file path logic.\n\n**Key Methods**:\n- `write(entity: TEntity | null)`: Atomic write to JSON file\n- `read(): Promise<TEntity | null>`: Read and parse JSON file\n- `remove()`: Delete persisted state\n\n**File Naming Pattern**: `./dump/{type}_{identifier}.json`\n\n**Sources**: [types.d.ts:163-176]()\n\n### Signal and Schedule Persistence\n\n`ClientStrategy` uses two persistence adapters to maintain state across restarts:\n\n| Adapter | Purpose | File Pattern | Data Type |\n|---------|---------|--------------|-----------|\n| `PersistSignalAdapter` | Active pending signals | `signal_{symbol}_{strategy}.json` | `ISignalRow` |\n| `PersistScheduleAdapter` | Scheduled signals awaiting activation | `schedule_{symbol}_{strategy}.json` | `IScheduledSignalRow` |\n\n**Recovery Flow**:\n\n```mermaid\nsequenceDiagram\n    participant Live as Live.run()\n    participant Strategy as ClientStrategy\n    participant SigAdapter as PersistSignalAdapter\n    participant SchAdapter as PersistScheduleAdapter\n    participant FS as File System\n    \n    Live->>Strategy: tick() first call\n    Strategy->>Strategy: waitForInit() (singleshot)\n    \n    alt Backtest Mode\n        Strategy->>Strategy: Skip persistence\n    else Live Mode\n        Strategy->>SigAdapter: readSignalData(symbol, strategy)\n        SigAdapter->>FS: Read signal_{symbol}_{strategy}.json\n        FS-->>SigAdapter: ISignalRow or null\n        SigAdapter-->>Strategy: Restored pending signal\n        \n        Strategy->>SchAdapter: readScheduleData(symbol, strategy)\n        SchAdapter->>FS: Read schedule_{symbol}_{strategy}.json\n        FS-->>SchAdapter: IScheduledSignalRow or null\n        SchAdapter-->>Strategy: Restored scheduled signal\n        \n        alt Signal Restored\n            Strategy->>Strategy: Set _pendingSignal\n            Strategy->>Strategy: Call onActive callback\n        end\n        \n        alt Scheduled Signal Restored\n            Strategy->>Strategy: Set _scheduledSignal\n            Strategy->>Strategy: Call onSchedule callback\n        end\n    end\n```\n\n**Sources**: [src/client/ClientStrategy.ts:491-552](), [types.d.ts:163-176]()\n\n### Atomic Write Pattern\n\nAll persistence adapters implement atomic writes to prevent data corruption during crashes:\n\n1. **Serialize**: Convert entity to JSON string\n2. **Write Atomic**: Write to file system with atomic guarantees\n3. **Validate**: Ensure write succeeded before continuing\n\nThis ensures that persisted state is always either the complete previous version or the complete new version—never a partial write.\n\n**Key Implementation**: Each `ClientStrategy` method that modifies signal state calls `setPendingSignal()` or `setScheduledSignal()`, which internally triggers `PersistSignalAdapter.write()` or `PersistScheduleAdapter.write()`.\n\n**Sources**: [src/client/ClientStrategy.ts:491-552]()\n\n### Singleshot Initialization Pattern\n\n`ClientStrategy.waitForInit()` uses the `singleshot` pattern from `functools-kit` to ensure persistence recovery happens exactly once per strategy instance:\n\n```typescript\n// First call: executes recovery logic and caches promise\nawait strategy.waitForInit();\n\n// Subsequent calls: return cached promise (no-op)\nawait strategy.waitForInit();\n```\n\nThis prevents duplicate recovery attempts and ensures consistent initialization across multiple ticks.\n\n**Sources**: [src/client/ClientStrategy.ts:491-552](), [docs/internals.md:49]()\n\n### Risk State Persistence\n\n`ClientRisk` uses `PersistRiskAdapter` to track active positions across process restarts. This is critical for portfolio-level risk management that must survive crashes.\n\n**Persisted Data**:\n- Active position count\n- List of active positions with signal details\n- Risk validation state\n\n**File Pattern**: `./dump/risk_{symbol}_{riskName}.json`\n\n**Sources**: [types.d.ts:163-176](), Diagram 1 (Overall System Architecture)\n\n### Partial State Persistence\n\n`ClientPartial` uses `PersistPartialAdapter` to maintain partial profit/loss milestone tracking across restarts. This ensures milestone events aren't duplicated after recovery.\n\n**Persisted Data**:\n- Signal ID to partial state mapping\n- Reached profit levels (Set serialized as array)\n- Reached loss levels (Set serialized as array)\n\n**File Pattern**: `./dump/partial_{symbol}.json`\n\n**Sources**: [types.d.ts:707-724](), [types.d.ts:163-176]()\n\n---\n\n## Event Listeners and Monitoring System\n\nThe framework provides a comprehensive pub/sub event system for monitoring strategy execution, handling errors, and tracking progress. All events use `functools-kit` Subject for type-safe event emission and subscription.\n\n### Event Emitter Architecture\n\n```mermaid\ngraph TB\n    subgraph \"Event Producers\"\n        CS[\"ClientStrategy<br/>tick(), backtest()<br/>Signal lifecycle\"]\n        CE[\"ClientExchange<br/>getCandles()<br/>Data fetching\"]\n        CR[\"ClientRisk<br/>checkSignal()<br/>Risk rejections\"]\n        CP[\"ClientPartial<br/>profit(), loss()<br/>Milestone tracking\"]\n        Logic[\"Logic Services<br/>Progress, completion<br/>Performance metrics\"]\n    end\n    \n    subgraph \"Core Emitters - functools-kit Subject\"\n        SE[\"signalEmitter<br/>All signals<br/>IStrategyTickResult\"]\n        SLE[\"signalLiveEmitter<br/>Live only<br/>IStrategyTickResult\"]\n        SBE[\"signalBacktestEmitter<br/>Backtest only<br/>IStrategyTickResult\"]\n        EE[\"errorEmitter<br/>Recoverable errors<br/>Error\"]\n        ExE[\"exitEmitter<br/>Fatal errors<br/>Error\"]\n        DLS[\"doneLiveSubject<br/>Live completion<br/>DoneContract\"]\n        DBS[\"doneBacktestSubject<br/>Backtest completion<br/>DoneContract\"]\n        DWS[\"doneWalkerSubject<br/>Walker completion<br/>DoneContract\"]\n        PBE[\"progressBacktestEmitter<br/>Backtest progress<br/>ProgressBacktestContract\"]\n        PWE[\"progressWalkerEmitter<br/>Walker progress<br/>ProgressWalkerContract\"]\n        POE[\"progressOptimizerEmitter<br/>Optimizer progress<br/>ProgressOptimizerContract\"]\n        PE[\"performanceEmitter<br/>Performance metrics<br/>PerformanceContract\"]\n        WE[\"walkerEmitter<br/>Strategy results<br/>WalkerContract\"]\n        WCS[\"walkerCompleteSubject<br/>Final results<br/>IWalkerResults\"]\n        WSS[\"walkerStopSubject<br/>Stop signals<br/>WalkerStopContract\"]\n        VS[\"validationSubject<br/>Validation errors<br/>Error\"]\n        PPS[\"partialProfitSubject<br/>Profit milestones<br/>PartialProfitContract\"]\n        PLS[\"partialLossSubject<br/>Loss milestones<br/>PartialLossContract\"]\n        RS[\"riskSubject<br/>Risk rejections<br/>RiskContract\"]\n    end\n    \n    subgraph \"Public Listeners - Queued Processing\"\n        LS[\"listenSignal()<br/>queued async<br/>All signals\"]\n        LSO[\"listenSignalOnce()<br/>filter + once<br/>Conditional\"]\n        LSLV[\"listenSignalLive()<br/>queued async<br/>Live only\"]\n        LSLVO[\"listenSignalLiveOnce()<br/>filter + once<br/>Conditional\"]\n        LSBT[\"listenSignalBacktest()<br/>queued async<br/>Backtest only\"]\n        LSBTO[\"listenSignalBacktestOnce()<br/>filter + once<br/>Conditional\"]\n        LE[\"listenError()<br/>queued async<br/>Error handling\"]\n        LEx[\"listenExit()<br/>queued async<br/>Fatal errors\"]\n        LDL[\"listenDoneLive()<br/>queued async<br/>Live completion\"]\n        LDLO[\"listenDoneLiveOnce()<br/>filter + once<br/>Conditional\"]\n        LDB[\"listenDoneBacktest()<br/>queued async<br/>Backtest completion\"]\n        LDBO[\"listenDoneBacktestOnce()<br/>filter + once<br/>Conditional\"]\n        LDW[\"listenDoneWalker()<br/>queued async<br/>Walker completion\"]\n        LDWO[\"listenDoneWalkerOnce()<br/>filter + once<br/>Conditional\"]\n        LBP[\"listenBacktestProgress()<br/>queued async<br/>Progress updates\"]\n        LWP[\"listenWalkerProgress()<br/>queued async<br/>Progress updates\"]\n        LOP[\"listenOptimizerProgress()<br/>queued async<br/>Progress updates\"]\n        LP[\"listenPerformance()<br/>queued async<br/>Metrics tracking\"]\n        LW[\"listenWalker()<br/>queued async<br/>Strategy results\"]\n        LWO[\"listenWalkerOnce()<br/>filter + once<br/>Conditional\"]\n        LWC[\"listenWalkerComplete()<br/>queued async<br/>Final results\"]\n        LV[\"listenValidation()<br/>queued async<br/>Validation errors\"]\n        LPP[\"listenPartialProfit()<br/>queued async<br/>Profit milestones\"]\n        LPPO[\"listenPartialProfitOnce()<br/>filter + once<br/>Conditional\"]\n        LPL[\"listenPartialLoss()<br/>queued async<br/>Loss milestones\"]\n        LPLO[\"listenPartialLossOnce()<br/>filter + once<br/>Conditional\"]\n        LR[\"listenRisk()<br/>queued async<br/>Risk rejections\"]\n        LRO[\"listenRiskOnce()<br/>filter + once<br/>Conditional\"]\n    end\n    \n    CS --> SE\n    CS --> SLE\n    CS --> SBE\n    CR --> RS\n    CP --> PPS\n    CP --> PLS\n    Logic --> PBE\n    Logic --> PWE\n    Logic --> POE\n    Logic --> DLS\n    Logic --> DBS\n    Logic --> DWS\n    Logic --> PE\n    Logic --> WE\n    Logic --> WCS\n    Logic --> EE\n    Logic --> ExE\n    \n    SE -.->|subscribe| LS\n    SE -.->|filter + once| LSO\n    SLE -.->|subscribe| LSLV\n    SLE -.->|filter + once| LSLVO\n    SBE -.->|subscribe| LSBT\n    SBE -.->|filter + once| LSBTO\n    EE -.->|subscribe| LE\n    ExE -.->|subscribe| LEx\n    DLS -.->|subscribe| LDL\n    DLS -.->|filter + once| LDLO\n    DBS -.->|subscribe| LDB\n    DBS -.->|filter + once| LDBO\n    DWS -.->|subscribe| LDW\n    DWS -.->|filter + once| LDWO\n    PBE -.->|subscribe| LBP\n    PWE -.->|subscribe| LWP\n    POE -.->|subscribe| LOP\n    PE -.->|subscribe| LP\n    WE -.->|subscribe| LW\n    WE -.->|filter + once| LWO\n    WCS -.->|subscribe| LWC\n    VS -.->|subscribe| LV\n    PPS -.->|subscribe| LPP\n    PPS -.->|filter + once| LPPO\n    PLS -.->|subscribe| LPL\n    PLS -.->|filter + once| LPLO\n    RS -.->|subscribe| LR\n    RS -.->|filter + once| LRO\n```\n\n**Sources**: [src/config/emitters.ts:1-133](), [src/function/event.ts:1-564](), Diagram 4 (Event System and Communication Flow)\n\n### Signal Event Listeners\n\nSignal events track the complete lifecycle of trading signals from generation through closure:\n\n| Function | Mode | Processing | Description |\n|----------|------|------------|-------------|\n| `listenSignal()` | All | Queued | All signal events (idle, opened, active, closed) |\n| `listenSignalOnce()` | All | Queued + Filter | Single filtered event, auto-unsubscribe |\n| `listenSignalLive()` | Live | Queued | Live-only signal events |\n| `listenSignalLiveOnce()` | Live | Queued + Filter | Single filtered live event |\n| `listenSignalBacktest()` | Backtest | Queued | Backtest-only signal events |\n| `listenSignalBacktestOnce()` | Backtest | Queued + Filter | Single filtered backtest event |\n\n**Event Payload**: `IStrategyTickResult` (discriminated union with `action` field)\n\n**Action Types**:\n- `\"idle\"`: No active signal\n- `\"scheduled\"`: Scheduled signal created, awaiting activation\n- `\"opened\"`: New signal opened after validation\n- `\"active\"`: Signal being monitored (TP/SL checks)\n- `\"closed\"`: Signal completed (TP/SL/time_expired)\n- `\"cancelled\"`: Scheduled signal cancelled without activation\n\n**Sources**: [src/function/event.ts:70-221](), [types.d.ts:854-953]()\n\n### Queued Processing Pattern\n\nAll listener functions wrap callbacks with `queued()` from `functools-kit` to ensure sequential processing:\n\n```typescript\nexport function listenSignal(fn: (event: IStrategyTickResult) => void) {\n  return signalEmitter.subscribe(queued(async (event) => fn(event)));\n}\n```\n\n**Benefits**:\n- Events processed in order received\n- Async callbacks don't cause race conditions\n- Prevents concurrent execution conflicts\n\nEven if callback contains `await`, next event waits for current callback to complete.\n\n**Sources**: [src/function/event.ts:70-73](), [docs/internals.md:52]()\n\n### Filter Predicates with Once Variants\n\n\"Once\" listener variants accept a filter predicate for conditional triggering:\n\n```typescript\nlistenSignalOnce(\n  (event) => event.action === \"closed\" && event.closeReason === \"take_profit\",\n  (event) => {\n    console.log(\"Take profit hit:\", event.pnl.pnlPercentage);\n  }\n);\n```\n\nAfter first matching event:\n1. Filter predicate evaluated\n2. If true, callback executed\n3. Subscription automatically cancelled\n\n**Use Case**: Wait for specific condition during backtest/live execution without manual unsubscribe.\n\n**Sources**: [src/function/event.ts:107-113](), [src/function/event.ts:161-167]()\n\n### Completion Event Listeners\n\nCompletion events signal the end of background execution:\n\n| Function | Mode | Emitter | Contract |\n|----------|------|---------|----------|\n| `listenDoneLive()` | Live | `doneLiveSubject` | `DoneContract` |\n| `listenDoneLiveOnce()` | Live | `doneLiveSubject` | `DoneContract` |\n| `listenDoneBacktest()` | Backtest | `doneBacktestSubject` | `DoneContract` |\n| `listenDoneBacktestOnce()` | Backtest | `doneBacktestSubject` | `DoneContract` |\n| `listenDoneWalker()` | Walker | `doneWalkerSubject` | `DoneContract` |\n| `listenDoneWalkerOnce()` | Walker | `doneWalkerSubject` | `DoneContract` |\n\n**DoneContract Payload**:\n```typescript\n{\n  backtest: boolean;      // Execution mode\n  symbol: string;         // Trading pair\n  strategyName: string;   // Strategy identifier\n  exchangeName: string;   // Exchange identifier\n  frameName?: string;     // Frame identifier (backtest only)\n}\n```\n\n**Sources**: [src/function/event.ts:308-413](), [src/config/emitters.ts:50-62]()\n\n### Progress Event Listeners\n\nProgress events track execution advancement during long-running operations:\n\n| Function | Emitter | Contract | Tracks |\n|----------|---------|----------|--------|\n| `listenBacktestProgress()` | `progressBacktestEmitter` | `ProgressBacktestContract` | Timeframe iteration |\n| `listenWalkerProgress()` | `progressWalkerEmitter` | `ProgressWalkerContract` | Strategy completion |\n| `listenOptimizerProgress()` | `progressOptimizerEmitter` | `ProgressOptimizerContract` | Data source fetching |\n\n**Progress Contracts** include:\n- Current index/count\n- Total count\n- Percentage completion\n- Context information (symbol, strategy, etc.)\n\n**Sources**: [src/function/event.ts:464-532](), [src/config/emitters.ts:68-80]()\n\n### Error Event Listeners\n\nError events distinguish between recoverable and fatal errors:\n\n| Function | Emitter | Severity | Behavior |\n|----------|---------|----------|----------|\n| `listenError()` | `errorEmitter` | Recoverable | Execution continues |\n| `listenExit()` | `exitEmitter` | Fatal | Execution terminates |\n\n**Error Types**:\n- **Recoverable**: API failures, validation errors, retry-able operations\n- **Fatal**: Unrecoverable failures requiring process restart\n\n**Sources**: [src/function/event.ts:247-279](), [src/config/emitters.ts:37-44]()\n\n### Walker Event Listeners\n\nWalker events track multi-strategy comparison progress and results:\n\n| Function | Emitter | Contract | Purpose |\n|----------|---------|----------|---------|\n| `listenWalker()` | `walkerEmitter` | `WalkerContract` | Each strategy completion |\n| `listenWalkerOnce()` | `walkerEmitter` | `WalkerContract` | Filtered strategy result |\n| `listenWalkerComplete()` | `walkerCompleteSubject` | `IWalkerResults` | Final comparison results |\n| `listenWalkerProgress()` | `progressWalkerEmitter` | `ProgressWalkerContract` | Strategy iteration progress |\n\n**Sources**: [src/function/event.ts:415-462](), [src/config/emitters.ts:92-106]()\n\n### Validation and Risk Event Listeners\n\nSpecialized listeners for risk management and validation errors:\n\n| Function | Emitter | Contract | Tracks |\n|----------|---------|----------|--------|\n| `listenValidation()` | `validationSubject` | `Error` | Schema/config validation errors |\n| `listenRisk()` | `riskSubject` | `RiskContract` | Risk check rejections only |\n| `listenRiskOnce()` | `riskSubject` | `RiskContract` | Filtered risk rejection |\n\n**Important**: `riskSubject` emits only when signals are **rejected** by risk checks. Allowed signals do not emit events (prevents spam).\n\n**Sources**: [src/function/event.ts:534-564](), [src/config/emitters.ts:112-131]()\n\n### Performance Event Listener\n\n`listenPerformance()` tracks execution timing for bottleneck identification:\n\n**PerformanceContract** includes:\n- Metric type (enum)\n- Duration in milliseconds\n- Context information\n- Timestamp\n\n**Metric Types**:\n- Strategy execution time\n- Exchange data fetch time\n- Risk validation time\n- Persistence write time\n\n**Sources**: [src/function/event.ts:464-476](), [src/config/emitters.ts:86]()\n\n---\n\n## Partial Profit and Loss Tracking\n\nThe framework tracks unrealized profit and loss milestones during active trades, emitting events when positions reach 10%, 20%, 30%, etc. profit or loss thresholds. This enables real-time monitoring and alert systems without closing positions.\n\n### Partial Tracking Architecture\n\n```mermaid\ngraph TB\n    subgraph \"Client Implementation\"\n        ClientPartial[\"ClientPartial<br/>Milestone tracking logic<br/>Set-based deduplication\"]\n    end\n    \n    subgraph \"State Management\"\n        PartialState[\"IPartialState (in-memory)<br/>Map&lt;signalId, state&gt;<br/>profitLevels: Set&lt;PartialLevel&gt;<br/>lossLevels: Set&lt;PartialLevel&gt;\"]\n        PartialData[\"IPartialData (serialized)<br/>profitLevels: PartialLevel[]<br/>lossLevels: PartialLevel[]<br/>JSON persistence\"]\n    end\n    \n    subgraph \"Persistence\"\n        PersistPartialAdapter[\"PersistPartialAdapter<br/>./dump/partial_{symbol}.json<br/>Atomic writes\"]\n    end\n    \n    subgraph \"Event Emission\"\n        PartialProfitSubject[\"partialProfitSubject<br/>Profit milestone events<br/>PartialProfitContract\"]\n        PartialLossSubject[\"partialLossSubject<br/>Loss milestone events<br/>PartialLossContract\"]\n    end\n    \n    subgraph \"Public API Listeners\"\n        ListenPartialProfit[\"listenPartialProfit()<br/>Queued processing<br/>All profit milestones\"]\n        ListenPartialProfitOnce[\"listenPartialProfitOnce()<br/>Filter + once<br/>Conditional\"]\n        ListenPartialLoss[\"listenPartialLoss()<br/>Queued processing<br/>All loss milestones\"]\n        ListenPartialLossOnce[\"listenPartialLossOnce()<br/>Filter + once<br/>Conditional\"]\n    end\n    \n    subgraph \"Milestone Calculation\"\n        CalcProfit[\"Calculate revenuePercent<br/>Compare to PartialLevel<br/>10, 20, 30, 40, 50, 60, 70, 80, 90, 100\"]\n        CalcLoss[\"Calculate lossPercent<br/>Compare to PartialLevel<br/>10, 20, 30, 40, 50, 60, 70, 80, 90, 100\"]\n    end\n    \n    subgraph \"Strategy Integration\"\n        ClientStrategy[\"ClientStrategy.tick()<br/>Monitor active signal<br/>Call partial.profit() or partial.loss()\"]\n    end\n    \n    ClientStrategy -->|\"revenuePercent &gt; 0\"| ClientPartial\n    ClientStrategy -->|\"revenuePercent &lt; 0\"| ClientPartial\n    \n    ClientPartial -->|profit| CalcProfit\n    ClientPartial -->|loss| CalcLoss\n    \n    CalcProfit -->|\"New milestone\"| PartialState\n    CalcLoss -->|\"New milestone\"| PartialState\n    \n    PartialState -->|\"Add to Set\"| PartialState\n    PartialState -->|Serialize| PartialData\n    PartialData --> PersistPartialAdapter\n    \n    CalcProfit -->|\"Emit event\"| PartialProfitSubject\n    CalcLoss -->|\"Emit event\"| PartialLossSubject\n    \n    PartialProfitSubject -.->|subscribe| ListenPartialProfit\n    PartialProfitSubject -.->|filter + once| ListenPartialProfitOnce\n    PartialLossSubject -.->|subscribe| ListenPartialLoss\n    PartialLossSubject -.->|filter + once| ListenPartialLossOnce\n    \n    ClientStrategy -->|\"Signal closes\"| ClientPartial\n    ClientPartial -->|clear| PartialState\n    PartialState -->|\"Remove signalId\"| PersistPartialAdapter\n```\n\n**Sources**: [types.d.ts:705-847](), Diagram 4 (Event System and Communication Flow)\n\n### PartialLevel Type\n\nProfit and loss milestones are defined as discrete percentage thresholds:\n\n```typescript\ntype PartialLevel = 10 | 20 | 30 | 40 | 50 | 60 | 70 | 80 | 90 | 100;\n```\n\nEach `PartialLevel` represents a percentage point milestone. When a signal reaches 10% profit, the `10` level is emitted. When it reaches 25% profit, levels `10` and `20` have been reached, but only `20` is emitted (deduplication via Set).\n\n**Sources**: [types.d.ts:705]()\n\n### IPartial Interface\n\n`ClientPartial` implements the `IPartial` interface with three core methods:\n\n| Method | Purpose | Called When |\n|--------|---------|-------------|\n| `profit(symbol, data, currentPrice, revenuePercent, backtest, when)` | Track profit milestones | `revenuePercent > 0` in active signal |\n| `loss(symbol, data, currentPrice, lossPercent, backtest, when)` | Track loss milestones | `revenuePercent < 0` in active signal |\n| `clear(symbol, data, priceClose, backtest)` | Clear tracking state | Signal closes (TP/SL/time_expired) |\n\n**Sources**: [types.d.ts:756-847]()\n\n### Set-Based Deduplication\n\nEach signal's partial state maintains two Sets for deduplication:\n\n```typescript\ninterface IPartialState {\n  profitLevels: Set<PartialLevel>;  // In-memory\n  lossLevels: Set<PartialLevel>;    // In-memory\n}\n```\n\n**Deduplication Logic**:\n1. Calculate which levels have been reached\n2. Check if level already in Set\n3. If new, add to Set and emit event\n4. If already in Set, skip (no duplicate event)\n\nThis ensures each milestone emits exactly once per signal, even across process restarts (state persisted).\n\n**Sources**: [types.d.ts:707-724]()\n\n### Profit Tracking Flow\n\n```mermaid\nsequenceDiagram\n    participant Strategy as ClientStrategy\n    participant Partial as ClientPartial\n    participant State as IPartialState (in-memory)\n    participant Adapter as PersistPartialAdapter\n    participant Emitter as partialProfitSubject\n    participant Listener as User Callback\n    \n    Strategy->>Strategy: tick() - active signal\n    Strategy->>Strategy: Calculate revenuePercent\n    \n    alt revenuePercent > 0\n        Strategy->>Partial: profit(symbol, data, currentPrice, revenuePercent, backtest, when)\n        \n        loop For each PartialLevel [10, 20, 30, ...]\n            Partial->>Partial: Check if revenuePercent >= level\n            \n            alt Level reached AND not in profitLevels Set\n                Partial->>State: Add level to profitLevels Set\n                Partial->>Adapter: write(serialized state)\n                Adapter->>FS: Atomic write to ./dump/partial_{symbol}.json\n                \n                Partial->>Emitter: next(PartialProfitContract)\n                Emitter->>Listener: Queued callback execution\n                \n                Note over Listener: User handles profit milestone<br/>(e.g., send Telegram alert)\n            else Level already in Set\n                Partial->>Partial: Skip (deduplication)\n            end\n        end\n    end\n```\n\n**Sources**: [types.d.ts:765-789](), [src/client/ClientStrategy.ts:900-950]()\n\n### Loss Tracking Flow\n\nLoss tracking follows the same pattern as profit tracking, but uses negative percentage values:\n\n**Key Differences**:\n- Input: `lossPercent` (negative value, e.g., -15.5)\n- Comparison: `Math.abs(lossPercent) >= level`\n- Storage: `lossLevels` Set\n- Emission: `partialLossSubject`\n\n**Sources**: [types.d.ts:792-823]()\n\n### Clear Operation\n\nWhen a signal closes, `ClientPartial.clear()` removes the tracking state:\n\n1. Delete `signalId` from in-memory Map\n2. Serialize remaining state (other active signals)\n3. Write updated state to disk (atomic)\n4. Memoized `ClientPartial` instance cleared from `PartialConnectionService`\n\n**Important**: Clear operation does NOT emit events—it only cleans up state.\n\n**Sources**: [types.d.ts:826-846]()\n\n### Partial Event Listeners\n\nFour listener functions provide access to partial profit/loss events:\n\n| Function | Emitter | Processing | Purpose |\n|----------|---------|------------|---------|\n| `listenPartialProfit()` | `partialProfitSubject` | Queued | All profit milestones |\n| `listenPartialProfitOnce()` | `partialProfitSubject` | Queued + Filter | Single filtered profit event |\n| `listenPartialLoss()` | `partialLossSubject` | Queued | All loss milestones |\n| `listenPartialLossOnce()` | `partialLossSubject` | Queued + Filter | Single filtered loss event |\n\n**PartialProfitContract Payload**:\n```typescript\n{\n  symbol: string;\n  data: ISignalRow;\n  currentPrice: number;\n  level: PartialLevel;        // 10, 20, 30, etc.\n  revenuePercent: number;     // Actual profit percentage\n  backtest: boolean;\n  timestamp: number;\n}\n```\n\n**PartialLossContract Payload**: Same structure, but with `lossPercent` instead of `revenuePercent`.\n\n**Sources**: [src/function/event.ts:534-564](), [src/config/emitters.ts:118-124]()\n\n### Strategy Callback Integration\n\n`IStrategySchema` includes two callbacks for partial profit/loss:\n\n```typescript\ncallbacks: {\n  onPartialProfit: (symbol, data, currentPrice, revenuePercent, backtest) => void;\n  onPartialLoss: (symbol, data, currentPrice, lossPercent, backtest) => void;\n}\n```\n\nThese callbacks fire on **every tick** while signal is in profit or loss, NOT just at milestones. For milestone-specific logic, use event listeners instead.\n\n**Use Case**: Strategy callbacks for real-time UI updates; event listeners for discrete alerts.\n\n**Sources**: [types.d.ts:910-931](), [docs/interfaces/IStrategyCallbacks.md:78-92]()\n\n### Persistence Across Restarts\n\n`PersistPartialAdapter` ensures milestone state survives process crashes:\n\n**Serialization**:\n```typescript\n// In-memory (Sets)\n{ profitLevels: Set(10, 20), lossLevels: Set(10) }\n\n// Persisted (Arrays)\n{ profitLevels: [10, 20], lossLevels: [10] }\n```\n\n**On Recovery**:\n1. Load JSON file\n2. Convert arrays back to Sets\n3. Restore state in `ClientPartial`\n4. Continue tracking from saved milestone state\n\nThis prevents duplicate milestone events after crashes.\n\n**Sources**: [types.d.ts:707-724](), [types.d.ts:163-176]()\n\n---\n\n## Summary\n\nThe three advanced features work together to create a production-ready trading system:\n\n1. **Crash Recovery**: Atomic persistence enables process restarts without state loss\n2. **Event Monitoring**: Comprehensive pub/sub system tracks all execution aspects\n3. **Partial Tracking**: Milestone-based monitoring provides real-time unrealized P/L insights\n\nThese features are optional—strategies can run without custom event listeners or partial tracking—but they're essential for professional live trading deployments.\n\n**Sources**: [docs/internals.md:1-132](), All sections above"
                    },
                    {
                        "page_plan": {
                            "id": "9.1",
                            "title": "Crash Recovery and Persistence"
                        },
                        "content": "# Crash Recovery and Persistence\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [assets/uml.svg](assets/uml.svg)\n- [docs/classes/WalkerCommandService.md](docs/classes/WalkerCommandService.md)\n- [docs/interfaces/BacktestStatistics.md](docs/interfaces/BacktestStatistics.md)\n- [docs/interfaces/IStrategyCallbacks.md](docs/interfaces/IStrategyCallbacks.md)\n- [docs/interfaces/LiveStatistics.md](docs/interfaces/LiveStatistics.md)\n- [docs/internals.md](docs/internals.md)\n- [docs/types/IStrategyTickResult.md](docs/types/IStrategyTickResult.md)\n- [docs/uml.puml](docs/uml.puml)\n- [scripts/uml.mjs](scripts/uml.mjs)\n- [src/client/ClientStrategy.ts](src/client/ClientStrategy.ts)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [src/interfaces/Strategy.interface.ts](src/interfaces/Strategy.interface.ts)\n- [src/lib/services/connection/StrategyConnectionService.ts](src/lib/services/connection/StrategyConnectionService.ts)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis document describes the crash recovery and persistence system that enables crash-safe live trading in backtest-kit. The persistence layer ensures that active trading signals, scheduled signals, risk state, and partial profit/loss tracking survive process crashes and restarts. For information about live trading execution modes, see [5.2 Live Trading Mode](#5.2). For details on risk management state, see [4.3 Risk Management](#4.3).\n\nThe persistence system uses atomic file writes to guarantee data consistency and a `waitForInit()` pattern for state recovery on startup. All persistence adapters extend `PersistBase` and can be replaced with custom implementations for alternative storage backends (Redis, MongoDB, etc.).\n\n---\n\n## Crash Recovery Architecture\n\nThe crash recovery system follows a **persist-and-restart** architecture where the process is stateless and all critical state is written to disk immediately after each state change. This ensures that if the process crashes at any moment, the state can be fully recovered on restart.\n\n**Key Design Principles:**\n\n| Principle | Implementation | Benefit |\n|-----------|---------------|---------|\n| **Stateless Process** | All state written to disk immediately | Process can crash and restart without data loss |\n| **Atomic Writes** | Write to temp file, then rename | File system guarantees consistency |\n| **Singleshot Init** | `waitForInit()` runs exactly once per strategy | State loaded once, cached in memory |\n| **JSON Serialization** | Human-readable files in `./dump/` | Easy debugging and manual recovery |\n| **Per-Symbol-Strategy Isolation** | Separate files per symbol:strategy pair | Independent recovery per trading pair |\n\n**Sources:** [docs/internals.md:26](), [docs/internals.md:38](), [docs/internals.md:50]()\n\n---\n\n## Persistence Layer Architecture\n\n```mermaid\ngraph TB\n    subgraph \"Live Trading Execution\"\n        CS[\"ClientStrategy<br/>tick() + backtest()\"]\n        CSI[\"ClientStrategy<br/>waitForInit()\"]\n    end\n    \n    subgraph \"Persistence Adapters\"\n        PSA[\"PersistSignalAdapter<br/>ISignalRow state\"]\n        PSchA[\"PersistScheduleAdapter<br/>IScheduledSignalRow state\"]\n        PRA[\"PersistRiskAdapter<br/>Active positions\"]\n        PPA[\"PersistPartialAdapter<br/>Profit/loss milestones\"]\n    end\n    \n    subgraph \"Base Class\"\n        PBase[\"PersistBase<br/>EntityId type<br/>Atomic write logic\"]\n    end\n    \n    subgraph \"File System\"\n        FS[\"./dump/<br/>JSON files<br/>Per-entity storage\"]\n    end\n    \n    CSI -->|\"readSignalData()\"| PSA\n    CSI -->|\"readScheduleData()\"| PSchA\n    \n    CS -->|\"writeSignalData()\"| PSA\n    CS -->|\"writeScheduleData()\"| PSchA\n    \n    PSA --> PBase\n    PSchA --> PBase\n    PRA --> PBase\n    PPA --> PBase\n    \n    PBase -->|\"Atomic writes\"| FS\n    PBase -->|\"Reads\"| FS\n```\n\n**Persistence Flow:**\n1. **On Startup:** `ClientStrategy.waitForInit()` calls `readSignalData()` and `readScheduleData()` to load persisted state\n2. **On State Change:** `setPendingSignal()` and `setScheduledSignal()` call `writeSignalData()` and `writeScheduleData()`\n3. **Atomic Write:** `PersistBase` writes to temp file, then atomically renames to final filename\n4. **Recovery:** On restart, `waitForInit()` loads last known state from disk\n\n**Sources:** [src/client/ClientStrategy.ts:28](), [src/client/ClientStrategy.ts:491-552](), [types.d.ts:163-176]()\n\n---\n\n## Persistence Adapters\n\nThe framework includes four persistence adapters for different state types:\n\n| Adapter | Entity Type | Purpose | File Pattern |\n|---------|-------------|---------|--------------|\n| **PersistSignalAdapter** | `SignalData` (ISignalRow) | Active pending signal per symbol:strategy | `signal_{symbol}_{strategyName}.json` |\n| **PersistScheduleAdapter** | `ScheduleData` (IScheduledSignalRow) | Scheduled signal awaiting activation | `schedule_{symbol}_{strategyName}.json` |\n| **PersistRiskAdapter** | `RiskData` (active positions) | Risk state for position tracking | `risk_{symbol}_{riskName}.json` |\n| **PersistPartialAdapter** | `PartialData` (profit/loss levels) | Partial milestone tracking per signal | `partial_{symbol}.json` |\n\n**Key Characteristics:**\n- All adapters extend `PersistBase<TEntityId, TData>`\n- Use `EntityId` helper type for type-safe identifiers\n- Store data as JSON for human-readable debugging\n- Support `null` data to represent \"no active state\"\n\n**Sources:** [types.d.ts:163-176](), [src/index.ts:162-176]()\n\n---\n\n## PersistBase Base Class\n\nAll persistence adapters extend `PersistBase`, which provides the core atomic write functionality and file system abstraction.\n\n**Generic Type Parameters:**\n- `TEntityId`: Type for entity identifier (e.g., `{ symbol: string, strategyName: string }`)\n- `TData`: Type for persisted data structure (e.g., `ISignalRow | null`)\n\n**Core Methods:**\n\n| Method | Purpose | Behavior |\n|--------|---------|----------|\n| `readData(entityId)` | Load persisted state | Returns `null` if file doesn't exist |\n| `writeData(entityId, data)` | Save state atomically | Writes to temp file, then renames |\n| `getFilePath(entityId)` | Generate file path | Abstract method for subclass implementation |\n\n**Atomic Write Implementation:**\n1. Serialize data to JSON string\n2. Write JSON to temporary file (`path.tmp`)\n3. Atomically rename temp file to final path\n4. File system guarantees rename is atomic (crash-safe)\n\n**Sources:** [types.d.ts:166-167](), [src/index.ts:165-167]()\n\n---\n\n## State Recovery with waitForInit\n\nThe `waitForInit()` method is called once per `ClientStrategy` instance before any tick operations. It uses the **singleshot pattern** from `functools-kit` to ensure initialization happens exactly once, even if called multiple times.\n\n### waitForInit Implementation\n\n```mermaid\nsequenceDiagram\n    participant SC as StrategyConnectionService\n    participant CS as ClientStrategy\n    participant PSA as PersistSignalAdapter\n    participant PSchA as PersistScheduleAdapter\n    participant FS as File System\n    \n    SC->>CS: waitForInit()\n    Note over CS: Singleshot: runs once\n    \n    alt Backtest Mode\n        CS->>CS: return immediately\n        Note over CS: No persistence in backtest\n    end\n    \n    alt Live Mode\n        CS->>PSA: readSignalData(symbol, strategyName)\n        PSA->>FS: Read signal_{symbol}_{strategyName}.json\n        FS-->>PSA: ISignalRow | null\n        PSA-->>CS: pendingSignal\n        \n        CS->>PSchA: readScheduleData(symbol, strategyName)\n        PSchA->>FS: Read schedule_{symbol}_{strategyName}.json\n        FS-->>PSchA: IScheduledSignalRow | null\n        PSchA-->>CS: scheduledSignal\n        \n        alt Signal exists\n            CS->>CS: Set _pendingSignal\n            CS->>CS: Call onActive callback\n        end\n        \n        alt Schedule exists\n            CS->>CS: Set _scheduledSignal\n            CS->>CS: Call onSchedule callback\n        end\n    end\n    \n    SC->>CS: tick()\n    Note over CS: Proceeds with loaded state\n```\n\n**Key Implementation Details:**\n\n[src/client/ClientStrategy.ts:491-552]()\n\n```typescript\nconst WAIT_FOR_INIT_FN = async (self: ClientStrategy) => {\n  self.params.logger.debug(\"ClientStrategy waitForInit\");\n  if (self.params.execution.context.backtest) {\n    return;  // No persistence in backtest mode\n  }\n\n  // Restore pending signal\n  const pendingSignal = await PersistSignalAdapter.readSignalData(\n    self.params.execution.context.symbol,\n    self.params.strategyName,\n  );\n  if (pendingSignal) {\n    // Validate schema names match\n    if (pendingSignal.exchangeName !== self.params.method.context.exchangeName) {\n      return;\n    }\n    if (pendingSignal.strategyName !== self.params.method.context.strategyName) {\n      return;\n    }\n    self._pendingSignal = pendingSignal;\n\n    // Call onActive callback for restored signal\n    if (self.params.callbacks?.onActive) {\n      const currentPrice = await self.params.exchange.getAveragePrice(\n        self.params.execution.context.symbol\n      );\n      self.params.callbacks.onActive(\n        self.params.execution.context.symbol,\n        pendingSignal,\n        currentPrice,\n        self.params.execution.context.backtest\n      );\n    }\n  }\n\n  // Restore scheduled signal\n  const scheduledSignal = await PersistScheduleAdapter.readScheduleData(\n    self.params.execution.context.symbol,\n    self.params.strategyName,\n  );\n  // Similar validation and restoration logic...\n};\n```\n\n**Validation Checks:**\n- `exchangeName` must match current strategy configuration\n- `strategyName` must match current strategy configuration\n- Prevents loading state from different strategy configurations\n\n**Sources:** [src/client/ClientStrategy.ts:491-552](), [src/lib/services/connection/StrategyConnectionService.ts:216](), [src/lib/services/connection/StrategyConnectionService.ts:252]()\n\n---\n\n## Signal State Persistence Flow\n\n```mermaid\nstateDiagram-v2\n    [*] --> ProcessStart\n    \n    ProcessStart --> waitForInit: Live.run() called\n    \n    waitForInit --> LoadSignal: readSignalData()\n    LoadSignal --> LoadSchedule: readScheduleData()\n    \n    LoadSchedule --> Idle: No persisted state\n    LoadSchedule --> Active: Pending signal loaded\n    LoadSchedule --> Scheduled: Scheduled signal loaded\n    \n    Idle --> GenerateSignal: tick() - interval elapsed\n    GenerateSignal --> ValidateRisk: getSignal() returns ISignalDto\n    ValidateRisk --> WriteSignal: Risk check passed\n    WriteSignal --> Active: writeSignalData()\n    \n    Active --> MonitorTP: tick() - check TP/SL\n    MonitorTP --> WriteClose: Take profit hit\n    MonitorTP --> WriteClose: Stop loss hit\n    MonitorTP --> WriteClose: Time expired\n    WriteClose --> Idle: writeSignalData(null)\n    \n    Scheduled --> CheckActivation: tick() - check priceOpen\n    CheckActivation --> WriteActivation: priceOpen reached\n    WriteActivation --> Active: writeSignalData()\n    CheckActivation --> WriteCancel: StopLoss hit before activation\n    WriteCancel --> Idle: writeScheduleData(null)\n    \n    Idle --> ProcessCrash: ❌ Crash\n    Active --> ProcessCrash: ❌ Crash\n    Scheduled --> ProcessCrash: ❌ Crash\n    \n    ProcessCrash --> ProcessRestart: Restart process\n    ProcessRestart --> waitForInit: Live.run() called again\n    \n    note right of WriteSignal\n        Atomic write to\n        signal_{symbol}_{strategy}.json\n    end note\n    \n    note right of WriteClose\n        Atomic write null\n        (deletes state)\n    end note\n```\n\n**Persistence Triggers:**\n\n| Event | Method Call | Persisted State | File Operation |\n|-------|-------------|-----------------|----------------|\n| **Signal opened** | `setPendingSignal(signal)` | `ISignalRow` | Write `signal_*.json` |\n| **Signal closed** | `setPendingSignal(null)` | `null` | Delete file |\n| **Scheduled created** | `setScheduledSignal(signal)` | `IScheduledSignalRow` | Write `schedule_*.json` |\n| **Scheduled activated** | `setScheduledSignal(null)` | `null` | Delete file |\n| **Scheduled cancelled** | `setScheduledSignal(null)` | `null` | Delete file |\n\n**Sources:** [src/client/ClientStrategy.ts:28](), [src/client/ClientStrategy.ts:498-552]()\n\n---\n\n## File System Structure\n\nPersistence files are stored in the `./dump/` directory relative to the process working directory. Each file is named using a pattern that uniquely identifies the entity.\n\n### File Naming Patterns\n\n| Adapter | File Pattern | Example |\n|---------|--------------|---------|\n| **PersistSignalAdapter** | `signal_{symbol}_{strategyName}.json` | `signal_BTCUSDT_my-strategy.json` |\n| **PersistScheduleAdapter** | `schedule_{symbol}_{strategyName}.json` | `schedule_BTCUSDT_my-strategy.json` |\n| **PersistRiskAdapter** | `risk_{symbol}_{riskName}.json` | `risk_BTCUSDT_max-3-positions.json` |\n| **PersistPartialAdapter** | `partial_{symbol}.json` | `partial_BTCUSDT.json` |\n\n### Directory Structure Example\n\n```\n./dump/\n├── signal_BTCUSDT_ma-crossover.json\n├── signal_ETHUSDT_ma-crossover.json\n├── schedule_BTCUSDT_limit-entry.json\n├── risk_BTCUSDT_portfolio-risk.json\n├── partial_BTCUSDT.json\n└── partial_ETHUSDT.json\n```\n\n### Signal File Format\n\n**Active Signal Example:**\n```json\n{\n  \"id\": \"a1b2c3d4-e5f6-7890-abcd-ef1234567890\",\n  \"symbol\": \"BTCUSDT\",\n  \"strategyName\": \"ma-crossover\",\n  \"exchangeName\": \"binance\",\n  \"position\": \"long\",\n  \"priceOpen\": 50000.00,\n  \"priceTakeProfit\": 52000.00,\n  \"priceStopLoss\": 49000.00,\n  \"minuteEstimatedTime\": 1440,\n  \"scheduledAt\": 1704067200000,\n  \"pendingAt\": 1704067200000,\n  \"_isScheduled\": false,\n  \"note\": \"MA crossover detected\"\n}\n```\n\n**Null State (No Active Signal):**\n- File is deleted when signal closes\n- `readSignalData()` returns `null` if file doesn't exist\n\n**Sources:** [src/client/ClientStrategy.ts:498-552]()\n\n---\n\n## Atomic Write Pattern\n\nThe atomic write pattern ensures that persistence files are never corrupted, even if the process crashes during a write operation.\n\n### Atomic Write Sequence\n\n```mermaid\nsequenceDiagram\n    participant CS as ClientStrategy\n    participant PBase as PersistBase\n    participant FS as File System\n    \n    CS->>PBase: writeData(entityId, data)\n    \n    PBase->>PBase: Serialize data to JSON\n    Note over PBase: JSON.stringify(data)\n    \n    PBase->>FS: Write to temp file\n    Note over FS: {path}.tmp\n    \n    alt Write fails\n        FS-->>PBase: Error\n        PBase-->>CS: Throw error\n    end\n    \n    PBase->>FS: Atomic rename\n    Note over FS: rename({path}.tmp, {path})\n    \n    alt Rename fails\n        FS-->>PBase: Error\n        Note over PBase: Temp file remains\n        PBase-->>CS: Throw error\n    end\n    \n    FS-->>PBase: Success\n    PBase-->>CS: Success\n    \n    Note over CS,FS: File system guarantees<br/>rename is atomic\n```\n\n**Why Atomic Renames Are Crash-Safe:**\n\n| Scenario | File System Behavior | Result |\n|----------|---------------------|--------|\n| **Crash during JSON write** | Temp file incomplete | Original file untouched, old state preserved |\n| **Crash during rename** | Rename completes or fails atomically | Either old or new state, never corrupted |\n| **Crash after rename** | Rename already completed | New state persisted successfully |\n\n**File System Guarantees:**\n- POSIX `rename()` is atomic on the same file system\n- Either the old filename or new filename exists, never both\n- No partial writes visible to readers\n- Crash at any point leaves file system in consistent state\n\n**Sources:** [docs/internals.md:38](), [docs/internals.md:50]()\n\n---\n\n## Integration with Live Mode\n\nThe persistence system is tightly integrated with Live mode execution to ensure crash-safe trading.\n\n### Live Mode Execution with Persistence\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Live as Live.run()\n    participant LLP as LiveLogicPrivateService\n    participant SC as StrategyConnectionService\n    participant CS as ClientStrategy\n    participant PSA as PersistSignalAdapter\n    \n    User->>Live: Live.run(\"BTCUSDT\", {...})\n    Live->>LLP: run(symbol, context)\n    \n    loop Infinite: while(true)\n        LLP->>SC: tick(symbol, strategyName)\n        SC->>CS: waitForInit()\n        Note over CS: Singleshot: runs once\n        CS->>PSA: readSignalData()\n        PSA-->>CS: Load persisted state\n        \n        SC->>CS: tick(symbol, strategyName)\n        \n        alt No Active Signal\n            CS->>CS: Check getSignal() interval\n            CS->>CS: Generate new signal\n            CS->>PSA: writeSignalData(signal)\n            Note over PSA: Atomic write\n        end\n        \n        alt Active Signal\n            CS->>CS: Monitor TP/SL/time\n            alt Signal closes\n                CS->>PSA: writeSignalData(null)\n                Note over PSA: Delete file\n            end\n        end\n        \n        CS-->>SC: IStrategyTickResult\n        SC-->>LLP: yield result\n        \n        LLP->>LLP: sleep(61 seconds)\n    end\n    \n    Note over Live,PSA: Process crash at any point<br/>State recoverable on restart\n```\n\n**Crash Recovery Scenarios:**\n\n| Crash Point | Persisted State | Recovery Behavior |\n|-------------|-----------------|-------------------|\n| **Before signal open** | No active signal | Starts idle, waits for next signal |\n| **After signal open** | `ISignalRow` persisted | Loads active signal, continues monitoring |\n| **During TP/SL check** | Active signal preserved | Resumes monitoring from last tick |\n| **After signal close** | `null` (file deleted) | Starts idle, ready for new signal |\n| **Scheduled signal waiting** | `IScheduledSignalRow` persisted | Continues waiting for activation |\n\n**Sleep Interval and Persistence:**\n- Live mode sleeps 61 seconds between ticks (`TICK_TTL`)\n- Persistence happens **before** sleep, ensuring state is saved\n- If crash occurs during sleep, state already persisted\n- On restart, `waitForInit()` loads last known state\n\n**Sources:** [src/client/ClientStrategy.ts:491-552](), [src/lib/services/connection/StrategyConnectionService.ts:216](), [docs/internals.md:68-81]()\n\n---\n\n## Extending with Custom Storage Backends\n\nThe persistence system is designed to be extensible. All adapters extend `PersistBase`, which can be subclassed for custom storage implementations.\n\n### Custom Adapter Implementation\n\nTo implement a custom persistence backend (e.g., Redis, MongoDB, PostgreSQL):\n\n1. **Extend PersistBase:**\n   - Implement `getFilePath()` for entity identification\n   - Override `readData()` and `writeData()` for custom storage logic\n\n2. **Example: Redis Adapter**\n\n```typescript\n// Custom Redis-based persistence adapter\nclass PersistSignalRedisAdapter extends PersistBase<\n  { symbol: string; strategyName: string },\n  SignalData\n> {\n  private redis: Redis;\n  \n  constructor(redis: Redis) {\n    super();\n    this.redis = redis;\n  }\n  \n  // Generate Redis key instead of file path\n  protected getFilePath(entityId: { symbol: string; strategyName: string }): string {\n    return `signal:${entityId.symbol}:${entityId.strategyName}`;\n  }\n  \n  // Override to use Redis GET\n  async readData(entityId: { symbol: string; strategyName: string }): Promise<SignalData | null> {\n    const key = this.getFilePath(entityId);\n    const json = await this.redis.get(key);\n    if (!json) return null;\n    return JSON.parse(json);\n  }\n  \n  // Override to use Redis SET\n  async writeData(\n    entityId: { symbol: string; strategyName: string },\n    data: SignalData | null\n  ): Promise<void> {\n    const key = this.getFilePath(entityId);\n    if (data === null) {\n      await this.redis.del(key);\n    } else {\n      await this.redis.set(key, JSON.stringify(data));\n    }\n  }\n}\n```\n\n3. **Replace Default Adapter:**\n   - Import custom adapter in strategy configuration\n   - Use custom adapter methods instead of default `PersistSignalAdapter`\n\n**Custom Backend Considerations:**\n\n| Backend | Atomicity | Durability | Latency | Use Case |\n|---------|-----------|------------|---------|----------|\n| **File System** | ✅ Atomic rename | ✅ Disk-backed | Low | Default, simple setup |\n| **Redis** | ✅ Single-op atomic | ⚠️ Optional persistence | Very low | High-frequency trading |\n| **MongoDB** | ✅ Single-doc atomic | ✅ Replicated | Medium | Multi-region deployments |\n| **PostgreSQL** | ✅ ACID transactions | ✅ ACID | Medium | Complex queries, auditing |\n\n**Sources:** [types.d.ts:166-167](), [src/index.ts:165-167]()\n\n---\n\n## Singleshot Initialization Pattern\n\nThe `waitForInit()` method uses the **singleshot pattern** from `functools-kit` to ensure initialization runs exactly once per instance, even if called multiple times.\n\n### Singleshot Behavior\n\n```mermaid\nsequenceDiagram\n    participant SC as StrategyConnectionService\n    participant CS as ClientStrategy\n    participant Init as waitForInit()\n    participant FS as File System\n    \n    Note over CS: First call\n    SC->>CS: tick()\n    CS->>Init: waitForInit()\n    Note over Init: Not yet initialized\n    Init->>FS: Load persisted state\n    FS-->>Init: Data loaded\n    Init->>Init: Set _initialized flag\n    Init-->>CS: Complete\n    CS->>CS: Process tick\n    \n    Note over CS: Second call\n    SC->>CS: tick()\n    CS->>Init: waitForInit()\n    Note over Init: Already initialized\n    Init-->>CS: Return immediately\n    CS->>CS: Process tick\n    \n    Note over CS: Third call\n    SC->>CS: backtest()\n    CS->>Init: waitForInit()\n    Note over Init: Already initialized\n    Init-->>CS: Return immediately\n    CS->>CS: Process backtest\n```\n\n**Implementation Pattern:**\n- `waitForInit()` wrapped with `singleshot()` from `functools-kit`\n- First call executes full initialization\n- Subsequent calls return cached result immediately\n- No race conditions even with concurrent calls\n- Memory efficient: state loaded once, reused\n\n**Benefits:**\n\n| Benefit | Description |\n|---------|-------------|\n| **Performance** | Avoid repeated file I/O operations |\n| **Consistency** | State loaded once, immutable across execution |\n| **Thread Safety** | `singleshot()` handles concurrent calls safely |\n| **Memory Efficiency** | Single copy of state in memory |\n\n**Sources:** [src/client/ClientStrategy.ts:491-552](), [docs/internals.md:49]()\n\n---\n\n## Best Practices\n\n### Persistence Best Practices\n\n1. **Always Use Atomic Writes:**\n   - Never write directly to final file path\n   - Always write to temp file, then rename\n   - Prevents corrupted state on crash\n\n2. **Validate Loaded State:**\n   - Check `exchangeName` and `strategyName` match current config\n   - Ignore state from different strategies\n   - Prevents loading incompatible state\n\n3. **Handle Null State:**\n   - `null` means \"no active state\"\n   - Don't throw errors on missing files\n   - Treat missing file as `null` state\n\n4. **Monitor Disk Space:**\n   - Each symbol:strategy pair creates files\n   - Clean up old files periodically\n   - Implement file rotation for long-running systems\n\n5. **Test Crash Scenarios:**\n   - Simulate crashes at different execution points\n   - Verify state recovers correctly\n   - Test with concurrent symbol:strategy pairs\n\n### Recovery Best Practices\n\n1. **Graceful Shutdown:**\n   - Use `Live.background()` with cancellation\n   - Wait for `doneLiveSubject` event\n   - Ensures final state persisted before exit\n\n2. **Monitor Recovery:**\n   - Log `waitForInit()` results\n   - Track which signals are recovered\n   - Alert on unexpected state changes\n\n3. **Version State Format:**\n   - Include version field in persisted data\n   - Handle migration on format changes\n   - Maintain backward compatibility\n\n**Sources:** [src/client/ClientStrategy.ts:491-552](), [docs/internals.md:26]()"
                    },
                    {
                        "page_plan": {
                            "id": "9.2",
                            "title": "Event Listeners and Monitoring"
                        },
                        "content": "# Event Listeners and Monitoring\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [assets/uml.svg](assets/uml.svg)\n- [docs/classes/WalkerCommandService.md](docs/classes/WalkerCommandService.md)\n- [docs/interfaces/BacktestStatistics.md](docs/interfaces/BacktestStatistics.md)\n- [docs/interfaces/IStrategyCallbacks.md](docs/interfaces/IStrategyCallbacks.md)\n- [docs/interfaces/LiveStatistics.md](docs/interfaces/LiveStatistics.md)\n- [docs/internals.md](docs/internals.md)\n- [docs/types/IStrategyTickResult.md](docs/types/IStrategyTickResult.md)\n- [docs/uml.puml](docs/uml.puml)\n- [scripts/uml.mjs](scripts/uml.mjs)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [src/interfaces/Heatmap.interface.ts](src/interfaces/Heatmap.interface.ts)\n- [test/e2e/defend.test.mjs](test/e2e/defend.test.mjs)\n- [test/e2e/risk.test.mjs](test/e2e/risk.test.mjs)\n- [test/index.mjs](test/index.mjs)\n- [test/mock/getMockCandles.mjs](test/mock/getMockCandles.mjs)\n- [test/spec/heat.test.mjs](test/spec/heat.test.mjs)\n- [test/spec/list.test.mjs](test/spec/list.test.mjs)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\nThis document covers the event listener system for monitoring strategy execution, progress tracking, error handling, and performance metrics. The framework provides 18 event emitters and corresponding listener functions for real-time observation of backtest and live trading operations.\n\nFor information about event-driven architecture principles, see [Event-Driven Architecture](#2.3). For crash recovery and persistence, see [Crash Recovery and Persistence](#9.1).\n\n---\n\n## Event System Architecture\n\nThe event system implements a publish-subscribe pattern using `functools-kit` Subject for decoupled communication between components.\n\n### Event Flow Diagram\n\n```mermaid\ngraph TB\n    subgraph Producers[\"Event Producers\"]\n        CS[\"ClientStrategy<br/>(signal lifecycle)\"]\n        CR[\"ClientRisk<br/>(rejections)\"]\n        CP[\"ClientPartial<br/>(P/L milestones)\"]\n        LOGIC[\"Logic Services<br/>(progress/completion)\"]\n    end\n    \n    subgraph Emitters[\"Core Emitters<br/>(src/config/emitters.ts)\"]\n        SIGNAL[\"signalEmitter\"]\n        SIGNAL_LIVE[\"signalLiveEmitter\"]\n        SIGNAL_BT[\"signalBacktestEmitter\"]\n        ERROR[\"errorEmitter\"]\n        EXIT[\"exitEmitter\"]\n        DONE[\"doneLiveSubject<br/>doneBacktestSubject<br/>doneWalkerSubject\"]\n        PROGRESS[\"progressBacktestEmitter<br/>progressWalkerEmitter<br/>progressOptimizerEmitter\"]\n        WALKER[\"walkerEmitter<br/>walkerCompleteSubject\"]\n        PARTIAL[\"partialProfitSubject<br/>partialLossSubject\"]\n        RISK[\"riskSubject\"]\n        PERF[\"performanceEmitter\"]\n        VALID[\"validationSubject\"]\n    end\n    \n    subgraph Listeners[\"Public Listeners<br/>(src/function/event.ts)\"]\n        L_SIGNAL[\"listenSignal<br/>listenSignalOnce\"]\n        L_SIGNAL_LIVE[\"listenSignalLive<br/>listenSignalLiveOnce\"]\n        L_SIGNAL_BT[\"listenSignalBacktest<br/>listenSignalBacktestOnce\"]\n        L_ERROR[\"listenError\"]\n        L_EXIT[\"listenExit\"]\n        L_DONE[\"listenDoneLive<br/>listenDoneBacktest<br/>listenDoneWalker<br/>(+ Once variants)\"]\n        L_PROGRESS[\"listenBacktestProgress<br/>listenWalkerProgress<br/>listenOptimizerProgress\"]\n        L_WALKER[\"listenWalker<br/>listenWalkerOnce<br/>listenWalkerComplete\"]\n        L_PARTIAL[\"listenPartialProfit<br/>listenPartialLoss<br/>(+ Once variants)\"]\n        L_RISK[\"listenRisk<br/>listenRiskOnce\"]\n        L_PERF[\"listenPerformance\"]\n        L_VALID[\"listenValidation\"]\n    end\n    \n    subgraph Consumers[\"Internal Consumers\"]\n        MD[\"Markdown Services<br/>(bounded queues)\"]\n    end\n    \n    CS --> SIGNAL\n    CS --> SIGNAL_LIVE\n    CS --> SIGNAL_BT\n    CR --> RISK\n    CP --> PARTIAL\n    LOGIC --> DONE\n    LOGIC --> PROGRESS\n    LOGIC --> WALKER\n    LOGIC --> ERROR\n    LOGIC --> EXIT\n    LOGIC --> PERF\n    \n    SIGNAL --> L_SIGNAL\n    SIGNAL_LIVE --> L_SIGNAL_LIVE\n    SIGNAL_BT --> L_SIGNAL_BT\n    ERROR --> L_ERROR\n    EXIT --> L_EXIT\n    DONE --> L_DONE\n    PROGRESS --> L_PROGRESS\n    WALKER --> L_WALKER\n    PARTIAL --> L_PARTIAL\n    RISK --> L_RISK\n    PERF --> L_PERF\n    VALID --> L_VALID\n    \n    SIGNAL --> MD\n    SIGNAL_BT --> MD\n    SIGNAL_LIVE --> MD\n    WALKER --> MD\n    PARTIAL --> MD\n    RISK --> MD\n    PERF --> MD\n```\n\n**Sources:** [src/config/emitters.ts:1-133](), [src/function/event.ts:1-720]()\n\n---\n\n## Core Event Emitters\n\nThe framework defines 18 event emitters organized by domain:\n\n### Signal Emitters\n\n| Emitter | Purpose | Filters |\n|---------|---------|---------|\n| `signalEmitter` | All signals (live + backtest) | None |\n| `signalLiveEmitter` | Live signals only | Backtest excluded |\n| `signalBacktestEmitter` | Backtest signals only | Live excluded |\n\n### Completion Emitters\n\n| Emitter | Purpose | Execution Mode |\n|---------|---------|----------------|\n| `doneLiveSubject` | Live background completion | Live.background() |\n| `doneBacktestSubject` | Backtest background completion | Backtest.background() |\n| `doneWalkerSubject` | Walker background completion | Walker.background() |\n\n### Progress Emitters\n\n| Emitter | Purpose | Payload |\n|---------|---------|---------|\n| `progressBacktestEmitter` | Backtest timeframe progress | `ProgressBacktestContract` |\n| `progressWalkerEmitter` | Walker strategy progress | `ProgressWalkerContract` |\n| `progressOptimizerEmitter` | Optimizer source progress | `ProgressOptimizerContract` |\n\n### Error and Validation Emitters\n\n| Emitter | Purpose | Severity |\n|---------|---------|----------|\n| `errorEmitter` | Recoverable errors | Warning |\n| `exitEmitter` | Fatal errors | Critical |\n| `validationSubject` | Risk validation errors | Warning |\n\n### Domain-Specific Emitters\n\n| Emitter | Purpose | Event Type |\n|---------|---------|------------|\n| `walkerEmitter` | Strategy comparison progress | Intermediate results |\n| `walkerCompleteSubject` | Walker final results | Best strategy |\n| `partialProfitSubject` | Profit milestones (10%, 20%...) | Milestone events |\n| `partialLossSubject` | Loss milestones (10%, 20%...) | Milestone events |\n| `riskSubject` | Risk rejections | Validation failures |\n| `performanceEmitter` | Execution metrics | Performance data |\n\n**Sources:** [src/config/emitters.ts:15-132]()\n\n---\n\n## Queued Processing Pattern\n\nAll listener functions use the `queued` wrapper from `functools-kit` to ensure **sequential async execution**. This prevents race conditions when callbacks perform asynchronous operations.\n\n```mermaid\ngraph LR\n    E1[\"Event 1\"] --> Q[\"Queued Processor\"]\n    E2[\"Event 2\"] --> Q\n    E3[\"Event 3\"] --> Q\n    Q --> CB1[\"Callback 1<br/>(async)\"]\n    CB1 --> CB2[\"Callback 2<br/>(async)\"]\n    CB2 --> CB3[\"Callback 3<br/>(async)\"]\n```\n\n### Implementation Pattern\n\n```typescript\n// All listeners follow this pattern:\nexport function listenSignal(fn: (event: IStrategyTickResult) => void) {\n  backtest.loggerService.log(LISTEN_SIGNAL_METHOD_NAME);\n  return signalEmitter.subscribe(queued(async (event) => fn(event)));\n}\n```\n\nThe `queued` wrapper ensures that even if `fn()` is async, events are processed one-by-one in order received.\n\n**Sources:** [src/function/event.ts:70-73](), [functools-kit documentation]\n\n---\n\n## Signal Listeners\n\nSignal listeners monitor trading signal state changes throughout the signal lifecycle.\n\n### Listener Functions\n\n| Function | Filter | Use Case |\n|----------|--------|----------|\n| `listenSignal()` | All signals | Complete monitoring |\n| `listenSignalLive()` | Live only | Live trading alerts |\n| `listenSignalBacktest()` | Backtest only | Backtest analysis |\n| `listenSignalOnce()` | Custom filter, once | Await specific signal |\n| `listenSignalLiveOnce()` | Live filter, once | Await live condition |\n| `listenSignalBacktestOnce()` | Backtest filter, once | Await backtest condition |\n\n### Event Payload Structure\n\n```mermaid\ngraph TB\n    ROOT[\"IStrategyTickResult<br/>(Discriminated Union)\"]\n    \n    ROOT --> IDLE[\"action: 'idle'<br/>signal: null\"]\n    ROOT --> SCHED[\"action: 'scheduled'<br/>signal: IScheduledSignalRow\"]\n    ROOT --> OPEN[\"action: 'opened'<br/>signal: ISignalRow\"]\n    ROOT --> ACTIVE[\"action: 'active'<br/>signal: ISignalRow\"]\n    ROOT --> CLOSED[\"action: 'closed'<br/>signal: ISignalRow<br/>closeReason: 'take_profit' | 'stop_loss' | 'time_expired'<br/>pnl: IStrategyPnL\"]\n    ROOT --> CANCEL[\"action: 'cancelled'<br/>signal: IScheduledSignalRow\"]\n```\n\n### Usage Examples\n\n#### Monitor All Signals\n\n```typescript\nconst unsubscribe = listenSignal((event) => {\n  if (event.action === \"opened\") {\n    console.log(`Signal opened: ${event.signal.id}`);\n  } else if (event.action === \"closed\") {\n    console.log(`Signal closed: ${event.pnl.pnlPercentage.toFixed(2)}%`);\n  }\n});\n```\n\n#### Await Specific Condition\n\n```typescript\n// Wait for first take profit hit\nlistenSignalOnce(\n  (event) => event.action === \"closed\" && event.closeReason === \"take_profit\",\n  (event) => {\n    console.log(`Take profit hit! PNL: ${event.pnl.pnlPercentage}%`);\n  }\n);\n```\n\n#### Live Trading Alerts\n\n```typescript\nlistenSignalLive((event) => {\n  if (event.action === \"opened\") {\n    sendTelegramAlert(`New position: ${event.signal.position}`);\n  } else if (event.action === \"closed\" && event.pnl.pnlPercentage < -2) {\n    sendTelegramAlert(`Loss detected: ${event.pnl.pnlPercentage}%`);\n  }\n});\n```\n\n**Sources:** [src/function/event.ts:45-221](), [types.d.ts:976-1076]()\n\n---\n\n## Completion Listeners\n\nCompletion listeners track when background execution finishes.\n\n### Listener Functions\n\n| Function | Execution Mode | Payload |\n|----------|----------------|---------|\n| `listenDoneLive()` | Live.background() | `DoneContract` |\n| `listenDoneBacktest()` | Backtest.background() | `DoneContract` |\n| `listenDoneWalker()` | Walker.background() | `DoneContract` |\n| `listenDoneLiveOnce()` | Live (filtered, once) | `DoneContract` |\n| `listenDoneBacktestOnce()` | Backtest (filtered, once) | `DoneContract` |\n| `listenDoneWalkerOnce()` | Walker (filtered, once) | `DoneContract` |\n\n### DoneContract Structure\n\n```typescript\ninterface DoneContract {\n  symbol: string;\n  strategyName: string;\n  exchangeName: string;\n  backtest: boolean; // true for Backtest, false for Live\n}\n```\n\n### Usage Examples\n\n#### Generate Report After Backtest\n\n```typescript\nlistenDoneBacktest(async (event) => {\n  console.log(`Backtest completed: ${event.symbol} - ${event.strategyName}`);\n  await Backtest.dump(event.symbol, event.strategyName);\n});\n\nBacktest.background(\"BTCUSDT\", {\n  strategyName: \"my-strategy\",\n  exchangeName: \"binance\",\n  frameName: \"1d-backtest\"\n});\n```\n\n#### Await Specific Symbol Completion\n\n```typescript\nlistenDoneBacktestOnce(\n  (event) => event.symbol === \"ETHUSDT\",\n  (event) => {\n    console.log(\"ETHUSDT backtest completed\");\n  }\n);\n```\n\n**Sources:** [src/function/event.ts:281-477](), [types.d.ts:1152-1168]()\n\n---\n\n## Progress Listeners\n\nProgress listeners provide real-time updates during long-running operations.\n\n### Listener Functions\n\n| Function | Operation | Update Frequency |\n|----------|-----------|------------------|\n| `listenBacktestProgress()` | Backtest execution | Per timeframe |\n| `listenWalkerProgress()` | Walker comparison | Per strategy |\n| `listenOptimizerProgress()` | Optimizer execution | Per data source |\n\n### Progress Contract Structures\n\n#### ProgressBacktestContract\n\n```typescript\ninterface ProgressBacktestContract {\n  symbol: string;\n  strategyName: string;\n  exchangeName: string;\n  frameName: string;\n  processedFrames: number;\n  totalFrames: number;\n  progress: number; // 0.0 to 1.0\n}\n```\n\n#### ProgressWalkerContract\n\n```typescript\ninterface ProgressWalkerContract {\n  symbol: string;\n  walkerName: string;\n  processedStrategies: number;\n  totalStrategies: number;\n  progress: number; // 0.0 to 1.0\n}\n```\n\n### Usage Examples\n\n#### Display Backtest Progress\n\n```typescript\nlistenBacktestProgress((event) => {\n  const percent = (event.progress * 100).toFixed(2);\n  console.log(`Progress: ${percent}% (${event.processedFrames}/${event.totalFrames} frames)`);\n});\n```\n\n#### Walker Progress Tracking\n\n```typescript\nlistenWalkerProgress((event) => {\n  console.log(`Testing strategy ${event.processedStrategies}/${event.totalStrategies}`);\n});\n```\n\n**Sources:** [src/function/event.ts:479-576](), [types.d.ts:1223-1263]()\n\n---\n\n## Error and Validation Listeners\n\nError listeners handle recoverable and fatal errors, plus validation failures.\n\n### Listener Functions\n\n| Function | Error Type | Behavior |\n|----------|------------|----------|\n| `listenError()` | Recoverable | Execution continues |\n| `listenExit()` | Fatal | Execution terminates |\n| `listenValidation()` | Risk validation | Signal rejected |\n\n### Usage Examples\n\n#### Error Logging\n\n```typescript\nlistenError((error) => {\n  console.error(\"Recoverable error:\", error.message);\n  // Log to monitoring service, send alerts, etc.\n});\n```\n\n#### Fatal Error Handling\n\n```typescript\nlistenExit((error) => {\n  console.error(\"FATAL ERROR:\", error.message);\n  // Emergency shutdown procedures\n  sendCriticalAlert(error);\n  process.exit(1);\n});\n```\n\n#### Validation Error Tracking\n\n```typescript\nlistenValidation((error) => {\n  console.warn(\"Validation failed:\", error.message);\n  // Track validation failures for strategy improvement\n});\n```\n\n**Sources:** [src/function/event.ts:223-280](), [src/config/emitters.ts:34-44,109-112]()\n\n---\n\n## Risk and Partial Listeners\n\nSpecialized listeners for risk management and profit/loss milestone tracking.\n\n### Risk Listeners\n\n| Function | Purpose | When Emitted |\n|----------|---------|--------------|\n| `listenRisk()` | Risk rejections | Signal rejected by risk validation |\n| `listenRiskOnce()` | Risk rejection (filtered, once) | First matching rejection |\n\n#### RiskContract Structure\n\n```typescript\ninterface RiskContract {\n  symbol: string;\n  strategyName: string;\n  exchangeName: string;\n  activePositionCount: number;\n  comment: string; // Rejection reason\n  timestamp: number;\n}\n```\n\n### Partial P/L Listeners\n\n| Function | Purpose | Milestones |\n|----------|---------|------------|\n| `listenPartialProfit()` | Profit milestones | 10%, 20%, 30%... 100% |\n| `listenPartialLoss()` | Loss milestones | -10%, -20%, -30%... -100% |\n| `listenPartialProfitOnce()` | Profit (filtered, once) | Single milestone |\n| `listenPartialLossOnce()` | Loss (filtered, once) | Single milestone |\n\n#### Partial Contract Structures\n\n```typescript\ninterface PartialProfitContract {\n  symbol: string;\n  signal: ISignalRow;\n  currentPrice: number;\n  level: PartialLevel; // 10 | 20 | 30 | ... | 100\n  backtest: boolean;\n  timestamp: number;\n}\n\ninterface PartialLossContract {\n  symbol: string;\n  signal: ISignalRow;\n  currentPrice: number;\n  level: PartialLevel; // 10 | 20 | 30 | ... | 100\n  backtest: boolean;\n  timestamp: number;\n}\n```\n\n### Usage Examples\n\n#### Risk Rejection Alerts\n\n```typescript\nlistenRisk((event) => {\n  console.warn(`Signal rejected: ${event.comment}`);\n  console.log(`Active positions: ${event.activePositionCount}`);\n});\n```\n\n#### Partial Profit Notifications\n\n```typescript\nlistenPartialProfit((event) => {\n  console.log(`Signal ${event.signal.id} reached ${event.level}% profit at $${event.currentPrice}`);\n  \n  // Take partial profit at 50% milestone\n  if (event.level === 50) {\n    executeTakeProfit(event.signal.id, 0.5); // Close 50% of position\n  }\n});\n```\n\n#### Stop Loss Trailing\n\n```typescript\nlistenPartialLoss((event) => {\n  console.warn(`Signal ${event.signal.id} reached ${event.level}% loss`);\n  \n  // Implement trailing stop loss\n  if (event.level >= 20) {\n    updateStopLoss(event.signal.id, event.currentPrice * 0.95);\n  }\n});\n```\n\n**Sources:** [src/function/event.ts:645-720](), [types.d.ts:1189-1221,694-705]()\n\n---\n\n## Once Variants and Filter Predicates\n\nOnce variants automatically unsubscribe after first execution. Filter predicates determine which events trigger callbacks.\n\n### Filter Predicate Pattern\n\n```typescript\ntype FilterFn<T> = (event: T) => boolean;\n```\n\n### Common Filter Examples\n\n#### Symbol-Based Filtering\n\n```typescript\nlistenSignalOnce(\n  (event) => event.signal?.symbol === \"BTCUSDT\" && event.action === \"closed\",\n  (event) => console.log(\"BTCUSDT signal closed\")\n);\n```\n\n#### Close Reason Filtering\n\n```typescript\nlistenSignalBacktestOnce(\n  (event) => event.action === \"closed\" && event.closeReason === \"stop_loss\",\n  (event) => console.log(\"First stop loss hit:\", event.pnl.pnlPercentage)\n);\n```\n\n#### Multi-Condition Filtering\n\n```typescript\nlistenWalkerOnce(\n  (event) => event.strategiesTested >= 10 && event.bestMetric > 1.5,\n  (event) => console.log(\"Found promising strategy:\", event.bestStrategy)\n);\n```\n\n#### Threshold-Based Filtering\n\n```typescript\nlistenPartialProfitOnce(\n  (event) => event.level >= 50 && event.signal.position === \"long\",\n  (event) => console.log(\"Long position reached 50% profit\")\n);\n```\n\n**Sources:** [src/function/event.ts:75-113,139-167]()\n\n---\n\n## Performance Listeners\n\nPerformance listeners track execution timing metrics for profiling and optimization.\n\n### Listener Function\n\n```typescript\nlistenPerformance(fn: (event: PerformanceContract) => void)\n```\n\n### PerformanceContract Structure\n\n```typescript\ninterface PerformanceContract {\n  metricType: PerformanceMetricType;\n  duration: number; // milliseconds\n  strategyName?: string;\n  exchangeName?: string;\n  symbol?: string;\n}\n\ntype PerformanceMetricType =\n  | \"getSignal\"\n  | \"tick\"\n  | \"backtest\"\n  | \"getCandles\"\n  | \"getAveragePrice\";\n```\n\n### Usage Example\n\n```typescript\nlistenPerformance((event) => {\n  console.log(`${event.metricType}: ${event.duration.toFixed(2)}ms`);\n  \n  // Alert on slow operations\n  if (event.duration > 100) {\n    console.warn(`Slow operation detected: ${event.metricType}`);\n  }\n  \n  // Track performance metrics\n  metrics.record(event.metricType, event.duration);\n});\n```\n\n**Sources:** [src/function/event.ts:578-613](), [types.d.ts:1265-1282]()\n\n---\n\n## Walker Listeners\n\nWalker listeners track strategy comparison progress and results.\n\n### Listener Functions\n\n| Function | Purpose | When Emitted |\n|----------|---------|--------------|\n| `listenWalker()` | Strategy completion | After each strategy test |\n| `listenWalkerOnce()` | Strategy completion (filtered, once) | First matching result |\n| `listenWalkerComplete()` | Final results | After all strategies tested |\n\n### WalkerContract Structure\n\n```typescript\ninterface WalkerContract {\n  symbol: string;\n  walkerName: string;\n  strategyName: string; // Current strategy\n  metricValue: number; // Current strategy's metric\n  bestStrategy: string; // Best so far\n  bestMetric: number; // Best metric so far\n  strategiesTested: number;\n  totalStrategies: number;\n}\n```\n\n### Usage Examples\n\n#### Track Best Strategy\n\n```typescript\nlistenWalker((event) => {\n  console.log(`Tested: ${event.strategyName} (${event.metricValue.toFixed(2)})`);\n  console.log(`Best: ${event.bestStrategy} (${event.bestMetric.toFixed(2)})`);\n  console.log(`Progress: ${event.strategiesTested}/${event.totalStrategies}`);\n});\n```\n\n#### Final Results\n\n```typescript\nlistenWalkerComplete((results) => {\n  console.log(\"Walker completed!\");\n  console.log(`Best strategy: ${results.bestStrategy}`);\n  console.log(`Metric value: ${results.bestMetricValue}`);\n  \n  // Export results\n  await Walker.dump(results.symbol, results.walkerName);\n});\n```\n\n**Sources:** [src/function/event.ts:615-664](), [types.d.ts:1170-1187]()\n\n---\n\n## Unsubscribing from Events\n\nAll listener functions return an unsubscribe function for cleanup.\n\n### Unsubscribe Pattern\n\n```typescript\n// Subscribe and get unsubscribe function\nconst unsubscribe = listenSignal((event) => {\n  console.log(event);\n});\n\n// Later: stop listening\nunsubscribe();\n```\n\n### Automatic Cleanup with Once Variants\n\nOnce variants automatically unsubscribe after execution:\n\n```typescript\n// No manual cleanup needed - auto-unsubscribes after first match\nlistenSignalOnce(\n  (event) => event.action === \"closed\",\n  (event) => console.log(\"First signal closed\")\n);\n```\n\n### Conditional Unsubscribe\n\n```typescript\nlet count = 0;\nconst unsubscribe = listenSignal((event) => {\n  if (event.action === \"closed\") {\n    count++;\n    if (count >= 10) {\n      unsubscribe(); // Stop after 10 closed signals\n    }\n  }\n});\n```\n\n**Sources:** [src/function/event.ts:70-73]()\n\n---\n\n## Practical Usage Patterns\n\n### Pattern 1: Telegram Bot Integration\n\n```typescript\nimport { listenSignalLive, listenError, listenPartialProfit } from \"backtest-kit\";\n\n// Signal notifications\nlistenSignalLive(async (event) => {\n  if (event.action === \"opened\") {\n    await sendTelegram(`📈 Opened ${event.signal.position} position on ${event.symbol}`);\n  } else if (event.action === \"closed\") {\n    const emoji = event.pnl.pnlPercentage > 0 ? \"✅\" : \"❌\";\n    await sendTelegram(`${emoji} Closed: ${event.pnl.pnlPercentage.toFixed(2)}%`);\n  }\n});\n\n// Milestone alerts\nlistenPartialProfit((event) => {\n  if (event.level % 20 === 0) { // Alert at 20%, 40%, 60%, 80%, 100%\n    sendTelegram(`🎯 ${event.signal.symbol}: ${event.level}% profit reached`);\n  }\n});\n\n// Error alerts\nlistenError((error) => {\n  sendTelegram(`⚠️ Error: ${error.message}`);\n});\n```\n\n### Pattern 2: Real-Time Dashboard\n\n```typescript\nimport { \n  listenSignalLive, \n  listenBacktestProgress, \n  listenPerformance \n} from \"backtest-kit\";\n\n// Live signal feed\nlistenSignalLive((event) => {\n  dashboard.updateSignalFeed(event);\n  \n  if (event.action === \"active\") {\n    dashboard.updateActivePositions(event.signal);\n  } else if (event.action === \"closed\") {\n    dashboard.updatePnLChart(event.pnl.pnlPercentage);\n  }\n});\n\n// Progress bar\nlistenBacktestProgress((event) => {\n  dashboard.updateProgressBar(event.progress, event.strategyName);\n});\n\n// Performance metrics\nlistenPerformance((event) => {\n  dashboard.updatePerformanceChart(event.metricType, event.duration);\n});\n```\n\n### Pattern 3: Strategy Comparison Workflow\n\n```typescript\nimport { \n  listenWalker, \n  listenWalkerComplete, \n  Walker \n} from \"backtest-kit\";\n\n// Track progress\nconst results = [];\nlistenWalker((event) => {\n  results.push({\n    strategy: event.strategyName,\n    metric: event.metricValue\n  });\n  console.log(`Progress: ${event.strategiesTested}/${event.totalStrategies}`);\n});\n\n// Generate report when complete\nlistenWalkerComplete(async (finalResults) => {\n  console.log(\"Comparison complete!\");\n  \n  // Export results\n  await Walker.dump(finalResults.symbol, finalResults.walkerName);\n  \n  // Deploy best strategy\n  if (finalResults.bestMetricValue > threshold) {\n    deployStrategy(finalResults.bestStrategy);\n  }\n});\n\n// Start comparison\nWalker.background(\"BTCUSDT\", { walkerName: \"compare-ma-strategies\" });\n```\n\n### Pattern 4: Risk Monitoring\n\n```typescript\nimport { listenRisk, listenValidation, Risk } from \"backtest-kit\";\n\n// Track risk rejections\nconst rejections = new Map();\nlistenRisk((event) => {\n  const key = event.strategyName;\n  rejections.set(key, (rejections.get(key) || 0) + 1);\n  \n  console.warn(`Risk rejection: ${event.comment}`);\n  console.log(`Active positions: ${event.activePositionCount}`);\n  \n  // Alert if too many rejections\n  if (rejections.get(key) > 10) {\n    sendAlert(`Strategy ${key} has excessive rejections`);\n  }\n});\n\n// Track validation errors\nlistenValidation((error) => {\n  logValidationError(error);\n});\n\n// Generate risk report\nsetInterval(async () => {\n  const report = await Risk.getReport(\"my-risk-profile\");\n  console.log(report);\n}, 60000);\n```\n\n**Sources:** [src/function/event.ts:1-720](), [README.md:168-171]()\n\n---\n\n## Event Payload Reference Table\n\n| Listener | Payload Type | Key Fields |\n|----------|--------------|------------|\n| `listenSignal*` | `IStrategyTickResult` | `action`, `signal`, `pnl?`, `closeReason?` |\n| `listenDone*` | `DoneContract` | `symbol`, `strategyName`, `exchangeName`, `backtest` |\n| `listenBacktestProgress` | `ProgressBacktestContract` | `processedFrames`, `totalFrames`, `progress` |\n| `listenWalkerProgress` | `ProgressWalkerContract` | `processedStrategies`, `totalStrategies`, `progress` |\n| `listenOptimizerProgress` | `ProgressOptimizerContract` | `processedSources`, `totalSources`, `progress` |\n| `listenWalker` | `WalkerContract` | `strategyName`, `metricValue`, `bestStrategy` |\n| `listenWalkerComplete` | `IWalkerResults` | `bestStrategy`, `bestMetricValue`, `results[]` |\n| `listenPartialProfit` | `PartialProfitContract` | `signal`, `level`, `currentPrice` |\n| `listenPartialLoss` | `PartialLossContract` | `signal`, `level`, `currentPrice` |\n| `listenRisk` | `RiskContract` | `activePositionCount`, `comment`, `timestamp` |\n| `listenPerformance` | `PerformanceContract` | `metricType`, `duration` |\n| `listenError` | `Error` | `message`, `stack` |\n| `listenValidation` | `Error` | `message`, `stack` |\n\n**Sources:** [types.d.ts:976-1282]()\n\n---\n\n## Summary\n\nThe event listener system provides comprehensive monitoring capabilities for strategy execution:\n\n- **18 event emitters** organized by domain (signals, completion, progress, errors, risk, partial P/L)\n- **Queued processing** ensures sequential async execution preventing race conditions\n- **Once variants** with filter predicates for conditional, one-time event handling\n- **Type-safe payloads** via discriminated unions and contract interfaces\n- **Unsubscribe functions** for cleanup and resource management\n- **Production-ready patterns** for Telegram bots, dashboards, risk monitoring\n\nAll listeners use the same pattern: subscribe to emitter, receive events via queued callback, unsubscribe when done. This consistency makes the API easy to learn and maintain.\n\n**Sources:** [src/config/emitters.ts:1-133](), [src/function/event.ts:1-720](), [types.d.ts:976-1282]()"
                    },
                    {
                        "page_plan": {
                            "id": "9.3",
                            "title": "Partial Profit and Loss"
                        },
                        "content": "# Partial Profit and Loss\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [src/client/ClientStrategy.ts](src/client/ClientStrategy.ts)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [src/interfaces/Strategy.interface.ts](src/interfaces/Strategy.interface.ts)\n- [src/lib/services/connection/StrategyConnectionService.ts](src/lib/services/connection/StrategyConnectionService.ts)\n- [src/lib/services/markdown/BacktestMarkdownService.ts](src/lib/services/markdown/BacktestMarkdownService.ts)\n- [src/lib/services/markdown/HeatMarkdownService.ts](src/lib/services/markdown/HeatMarkdownService.ts)\n- [src/lib/services/markdown/LiveMarkdownService.ts](src/lib/services/markdown/LiveMarkdownService.ts)\n- [src/lib/services/markdown/PartialMarkdownService.ts](src/lib/services/markdown/PartialMarkdownService.ts)\n- [src/lib/services/markdown/PerformanceMarkdownService.ts](src/lib/services/markdown/PerformanceMarkdownService.ts)\n- [src/lib/services/markdown/ScheduleMarkdownService.ts](src/lib/services/markdown/ScheduleMarkdownService.ts)\n- [src/lib/services/markdown/WalkerMarkdownService.ts](src/lib/services/markdown/WalkerMarkdownService.ts)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\nThis page documents the partial profit/loss tracking system, which monitors intermediate milestone levels (10%, 20%, 30%, etc.) as trading signals move toward their take profit or stop loss targets. The system emits events when signals reach these thresholds, enabling real-time monitoring and analytics for unrealized gains/losses.\n\nFor information about final profit/loss calculation when signals close, see [Signal Lifecycle and State Machine](#2.1). For event subscription patterns, see [Event Listeners and Monitoring](#9.2).\n\n---\n\n## System Purpose and Architecture\n\nThe partial profit/loss system tracks milestone levels for active signals without closing positions. When a signal's unrealized profit or loss crosses a 10% threshold (10%, 20%, 30%, up to 100%), the system:\n\n1. Emits an event via `partialProfitSubject` or `partialLossSubject`\n2. Records the milestone in persistent storage for crash recovery\n3. Ensures each level is only reported once per signal (Set-based deduplication)\n4. Provides markdown reports aggregating milestone events\n\nThis differs from the final PNL calculated when signals close - partial tracking monitors intermediate states during active signal monitoring.\n\n**Sources**: [types.d.ts:693-847](), [src/interfaces/Partial.interface.ts:1-50]()\n\n---\n\n## Component Architecture\n\n```mermaid\ngraph TB\n    subgraph \"Strategy Execution Layer\"\n        CS[\"ClientStrategy<br/>[src/client/ClientStrategy.ts]\"]\n        TICK[\"tick() method<br/>Signal monitoring\"]\n        BACKTEST[\"backtest() method<br/>Candle processing\"]\n    end\n    \n    subgraph \"Partial Tracking Layer\"\n        PC[\"PartialConnectionService<br/>[src/lib/services/connection/PartialConnectionService.ts]<br/>Memoized factory\"]\n        CP[\"ClientPartial<br/>[src/client/ClientPartial.ts]<br/>Milestone logic\"]\n        \n        PROFIT[\"profit() method<br/>Check profit levels\"]\n        LOSS[\"loss() method<br/>Check loss levels\"]\n        CLEAR[\"clear() method<br/>Remove on close\"]\n    end\n    \n    subgraph \"State Management\"\n        STATE[\"_states Map<br/>symbol → IPartialState\"]\n        PSTATE[\"IPartialState<br/>profitLevels: Set<PartialLevel><br/>lossLevels: Set<PartialLevel>\"]\n        \n        PPA[\"PersistPartialAdapter<br/>[src/classes/Persist.ts]<br/>JSON persistence\"]\n        PDATA[\"IPartialData<br/>Serialized arrays\"]\n    end\n    \n    subgraph \"Event Emission\"\n        PPE[\"partialProfitSubject<br/>[src/config/emitters.ts:118]\"]\n        PLE[\"partialLossSubject<br/>[src/config/emitters.ts:124]\"]\n        \n        PPCONTRACT[\"PartialProfitContract<br/>symbol, data, level, price\"]\n        PLCONTRACT[\"PartialLossContract<br/>symbol, data, level, price\"]\n    end\n    \n    subgraph \"Reporting Layer\"\n        PMS[\"PartialMarkdownService<br/>[src/lib/services/markdown/PartialMarkdownService.ts]\"]\n        STORAGE[\"ReportStorage<br/>_eventList: PartialEvent[]\"]\n        STATS[\"PartialStatistics<br/>totalProfit/totalLoss\"]\n    end\n    \n    CS --> PC\n    PC --> CP\n    \n    TICK --> PROFIT\n    TICK --> LOSS\n    BACKTEST --> PROFIT\n    BACKTEST --> LOSS\n    \n    PROFIT --> STATE\n    LOSS --> STATE\n    CLEAR --> STATE\n    \n    STATE --> PSTATE\n    PSTATE --> PPA\n    PPA --> PDATA\n    \n    PROFIT --> PPE\n    LOSS --> PLE\n    \n    PPE --> PPCONTRACT\n    PLE --> PLCONTRACT\n    \n    PPE --> PMS\n    PLE --> PMS\n    PMS --> STORAGE\n    STORAGE --> STATS\n    \n    style CP fill:#e1f5ff,stroke:#333,stroke-width:3px\n    style STATE fill:#fff4e1,stroke:#333,stroke-width:2px\n    style PPE fill:#e8f5e9,stroke:#333,stroke-width:2px\n    style PLE fill:#ffe1e1,stroke:#333,stroke-width:2px\n```\n\n**Component Flow**: `ClientStrategy` invokes `ClientPartial` methods during signal monitoring. `ClientPartial` maintains in-memory Sets tracking which levels have been reached, persists state via `PersistPartialAdapter`, and emits events through `partialProfitSubject`/`partialLossSubject`. `PartialMarkdownService` subscribes to these subjects for reporting.\n\n**Sources**: [src/client/ClientStrategy.ts:1-50](), [src/config/emitters.ts:115-124](), [src/lib/services/markdown/PartialMarkdownService.ts:1-50]()\n\n---\n\n## Milestone Level Enumeration\n\nThe `PartialLevel` type defines discrete milestone thresholds:\n\n```typescript\ntype PartialLevel = 10 | 20 | 30 | 40 | 50 | 60 | 70 | 80 | 90 | 100;\n```\n\nWhen a signal's unrealized profit or loss percentage crosses one of these thresholds, the corresponding level is added to the tracking Set and an event is emitted. For example:\n\n- Signal opens at $50,000\n- Price moves to $55,500 → 11% profit → `profit(symbol, data, 55500, 11.0, false, now)` called → Level 10 emitted\n- Price moves to $61,000 → 22% profit → `profit(symbol, data, 61000, 22.0, false, now)` called → Level 20 emitted\n- Level 10 is NOT re-emitted (Set deduplication)\n\n**Sources**: [types.d.ts:704-705](), [src/interfaces/Partial.interface.ts:10-15]()\n\n---\n\n## IPartial Interface and Methods\n\n```mermaid\ngraph LR\n    subgraph \"IPartial Interface\"\n        PROFIT[\"profit(symbol, data, currentPrice,<br/>revenuePercent, backtest, when)<br/>→ Promise<void>\"]\n        LOSS[\"loss(symbol, data, currentPrice,<br/>lossPercent, backtest, when)<br/>→ Promise<void>\"]\n        CLEAR[\"clear(symbol, data, priceClose,<br/>backtest)<br/>→ Promise<void>\"]\n    end\n    \n    subgraph \"Method Behavior\"\n        P_CHECK[\"Check revenuePercent<br/>Determine levels reached\"]\n        P_EMIT[\"Emit new levels only<br/>via partialProfitSubject\"]\n        P_PERSIST[\"Update _states Map<br/>Call persist()\"]\n        \n        L_CHECK[\"Check lossPercent<br/>Determine levels reached\"]\n        L_EMIT[\"Emit new levels only<br/>via partialLossSubject\"]\n        L_PERSIST[\"Update _states Map<br/>Call persist()\"]\n        \n        C_DELETE[\"Delete from _states Map\"]\n        C_PERSIST[\"Write updated state\"]\n        C_CLEAR_MEMO[\"Clear memoized instance<br/>in PartialConnectionService\"]\n    end\n    \n    PROFIT --> P_CHECK\n    P_CHECK --> P_EMIT\n    P_EMIT --> P_PERSIST\n    \n    LOSS --> L_CHECK\n    L_CHECK --> L_EMIT\n    L_EMIT --> L_PERSIST\n    \n    CLEAR --> C_DELETE\n    C_DELETE --> C_PERSIST\n    C_PERSIST --> C_CLEAR_MEMO\n    \n    style PROFIT fill:#e8f5e9,stroke:#333,stroke-width:2px\n    style LOSS fill:#ffe1e1,stroke:#333,stroke-width:2px\n    style CLEAR fill:#fff4e1,stroke:#333,stroke-width:2px\n```\n\n**Method Contracts**:\n\n| Method | Parameters | Purpose | Side Effects |\n|--------|-----------|---------|--------------|\n| `profit()` | `symbol`, `data: ISignalRow`, `currentPrice`, `revenuePercent`, `backtest`, `when` | Process profit state and emit events for new profit levels | Updates `_states` Map, persists to disk, emits via `partialProfitSubject` |\n| `loss()` | `symbol`, `data: ISignalRow`, `currentPrice`, `lossPercent`, `backtest`, `when` | Process loss state and emit events for new loss levels | Updates `_states` Map, persists to disk, emits via `partialLossSubject` |\n| `clear()` | `symbol`, `data: ISignalRow`, `priceClose`, `backtest` | Clear partial state when signal closes | Deletes from `_states` Map, persists updated state, clears memoized instance |\n\n**Sources**: [types.d.ts:756-847](), [src/client/ClientPartial.ts:1-300]()\n\n---\n\n## State Management and Persistence\n\n### IPartialState Internal Structure\n\n```typescript\ninterface IPartialState {\n  profitLevels: Set<PartialLevel>;  // In-memory deduplication\n  lossLevels: Set<PartialLevel>;    // In-memory deduplication\n}\n```\n\nThe `_states` Map in `ClientPartial` uses signal IDs as keys:\n\n```\n_states: Map<string, IPartialState>\n  \"signal-uuid-1\" → { profitLevels: Set(10, 20), lossLevels: Set() }\n  \"signal-uuid-2\" → { profitLevels: Set(), lossLevels: Set(10) }\n```\n\n### Serialization via IPartialData\n\nFor persistence to disk, Sets are converted to arrays:\n\n```typescript\ninterface IPartialData {\n  profitLevels: PartialLevel[];  // Serializable form\n  lossLevels: PartialLevel[];    // Serializable form\n}\n```\n\n**Persistence Pattern**:\n1. `ClientPartial._states` (in-memory Map with Sets) \n2. → Convert Sets to arrays → `IPartialData`\n3. → `PersistPartialAdapter.persist()` → Write to `./dump/partial/{symbol}_partial.json`\n4. On crash recovery: `waitForInit()` loads JSON → Convert arrays to Sets → Restore `_states`\n\n**Sources**: [types.d.ts:707-724](), [src/classes/Persist.ts:1-100]()\n\n---\n\n## Integration with ClientStrategy\n\n```mermaid\nsequenceDiagram\n    participant CS as ClientStrategy.tick()\n    participant CP as ClientPartial\n    participant EMIT as Emitters\n    participant PERSIST as PersistPartialAdapter\n    \n    Note over CS: Active signal monitoring\n    CS->>CS: getAveragePrice(symbol)\n    CS->>CS: Calculate revenuePercent\n    \n    alt revenuePercent > 0\n        CS->>CP: profit(symbol, signal, price, revenue, backtest, when)\n        CP->>CP: Check new levels crossed\n        CP->>CP: Update _states Map\n        CP->>EMIT: partialProfitSubject.next(contract)\n        CP->>PERSIST: persist(symbol, _states)\n        CP-->>CS: void\n    else revenuePercent < 0\n        CS->>CP: loss(symbol, signal, price, loss, backtest, when)\n        CP->>CP: Check new levels crossed\n        CP->>CP: Update _states Map\n        CP->>EMIT: partialLossSubject.next(contract)\n        CP->>PERSIST: persist(symbol, _states)\n        CP-->>CS: void\n    end\n    \n    Note over CS: Signal closes (TP/SL/time_expired)\n    CS->>CP: clear(symbol, signal, priceClose, backtest)\n    CP->>CP: Delete from _states Map\n    CP->>PERSIST: persist(symbol, _states)\n    CP-->>CS: void\n```\n\n**Invocation Points in ClientStrategy**:\n\n| File Location | Context | Partial Method Called |\n|--------------|---------|----------------------|\n| [src/client/ClientStrategy.ts:900-950]() | `tick()` during active signal monitoring | `profit()` or `loss()` based on `revenuePercent` sign |\n| [src/client/ClientStrategy.ts:1100-1200]() | `backtest()` during candle processing | `profit()` or `loss()` during VWAP checks |\n| [src/client/ClientStrategy.ts:1050-1080]() | Signal close (TP/SL/time_expired) | `clear()` to remove state |\n\n**Sources**: [src/client/ClientStrategy.ts:869-1000](), [src/client/ClientPartial.ts:50-200]()\n\n---\n\n## Event Emission Contracts\n\n### PartialProfitContract\n\n```typescript\ninterface PartialProfitContract {\n  symbol: string;           // Trading pair\n  data: ISignalRow;         // Complete signal data\n  currentPrice: number;     // Market price when level reached\n  level: PartialLevel;      // Milestone reached (10, 20, 30, etc)\n  backtest: boolean;        // Execution mode\n  timestamp: number;        // Event timestamp in ms\n}\n```\n\n**Emitter**: `partialProfitSubject` declared at [src/config/emitters.ts:118]()\n\n**Listener Function**: `listenPartialProfit(fn)` and `listenPartialProfitOnce(filterFn, fn)` at [src/function/event.ts:280-320]()\n\n### PartialLossContract\n\n```typescript\ninterface PartialLossContract {\n  symbol: string;           // Trading pair\n  data: ISignalRow;         // Complete signal data\n  currentPrice: number;     // Market price when level reached\n  level: PartialLevel;      // Milestone reached (10, 20, 30, etc)\n  backtest: boolean;        // Execution mode\n  timestamp: number;        // Event timestamp in ms\n}\n```\n\n**Emitter**: `partialLossSubject` declared at [src/config/emitters.ts:124]()\n\n**Listener Function**: `listenPartialLoss(fn)` and `listenPartialLossOnce(filterFn, fn)` at [src/function/event.ts:330-370]()\n\n**Sources**: [src/contract/PartialProfit.contract.ts:1-20](), [src/contract/PartialLoss.contract.ts:1-20](), [src/function/event.ts:280-380]()\n\n---\n\n## PartialConnectionService Factory\n\nThe `PartialConnectionService` provides memoized `ClientPartial` instances to avoid creating multiple instances per symbol:\n\n```typescript\nclass PartialConnectionService {\n  private getPartial = memoize(\n    ([symbol]) => symbol,\n    (symbol: string) => new ClientPartial({\n      logger: this.loggerService,\n      onProfit: (symbol, data, price, level, backtest, timestamp) => {\n        partialProfitSubject.next({ symbol, data, currentPrice: price, level, backtest, timestamp });\n      },\n      onLoss: (symbol, data, price, level, backtest, timestamp) => {\n        partialLossSubject.next({ symbol, data, currentPrice: price, level, backtest, timestamp });\n      }\n    })\n  );\n}\n```\n\n**Memoization Key**: Symbol only (not symbol:strategyName), because partial tracking is per-signal, not per-strategy\n\n**Instance Lifecycle**:\n1. First call to `getPartial(symbol)` creates `ClientPartial` instance\n2. Subsequent calls return cached instance\n3. On `clear()`, instance is removed from memoization cache via [src/client/ClientPartial.ts:250-280]()\n\n**Sources**: [src/lib/services/connection/PartialConnectionService.ts:1-150](), [src/lib/services/connection/StrategyConnectionService.ts:106-108]()\n\n---\n\n## Markdown Reporting\n\n### PartialMarkdownService Architecture\n\n```mermaid\ngraph TB\n    subgraph \"Event Subscription\"\n        PPE[\"partialProfitSubject\"]\n        PLE[\"partialLossSubject\"]\n    end\n    \n    subgraph \"PartialMarkdownService\"\n        TICK_PROFIT[\"tickProfit()<br/>Add profit event\"]\n        TICK_LOSS[\"tickLoss()<br/>Add loss event\"]\n        \n        STORAGE[\"ReportStorage<br/>Memoized by symbol:strategyName\"]\n        EVENT_LIST[\"_eventList: PartialEvent[]<br/>MAX_EVENTS: 250\"]\n    end\n    \n    subgraph \"Public API\"\n        GET_DATA[\"getData(symbol, strategyName)<br/>→ PartialStatistics\"]\n        GET_REPORT[\"getReport(symbol, strategyName)<br/>→ Markdown string\"]\n        DUMP[\"dump(symbol, strategyName, path)<br/>→ Write to disk\"]\n    end\n    \n    PPE --> TICK_PROFIT\n    PLE --> TICK_LOSS\n    \n    TICK_PROFIT --> STORAGE\n    TICK_LOSS --> STORAGE\n    \n    STORAGE --> EVENT_LIST\n    \n    EVENT_LIST --> GET_DATA\n    EVENT_LIST --> GET_REPORT\n    GET_REPORT --> DUMP\n    \n    style STORAGE fill:#fff4e1,stroke:#333,stroke-width:2px\n    style GET_DATA fill:#e1f5ff,stroke:#333,stroke-width:2px\n    style DUMP fill:#e8f5e9,stroke:#333,stroke-width:2px\n```\n\n### PartialStatistics Structure\n\n```typescript\ninterface PartialStatistics {\n  eventList: PartialEvent[];     // All profit/loss milestone events\n  totalEvents: number;            // Total event count\n  totalProfit: number;            // Count of profit milestone events\n  totalLoss: number;              // Count of loss milestone events\n}\n```\n\n**Event Storage Pattern**: Uses memoized `ReportStorage` instances keyed by `symbol:strategyName`, with bounded queue (MAX_EVENTS = 250) using FIFO eviction.\n\n### Report Table Columns\n\n| Column | Label | Format | Purpose |\n|--------|-------|--------|---------|\n| `action` | Action | \"PROFIT\" / \"LOSS\" | Event type |\n| `symbol` | Symbol | Raw string | Trading pair |\n| `strategyName` | Strategy | Raw string | Strategy identifier |\n| `signalId` | Signal ID | UUID | Signal identifier |\n| `position` | Position | \"LONG\" / \"SHORT\" | Trade direction |\n| `level` | Level % | \"+10%\" / \"-20%\" | Milestone percentage |\n| `currentPrice` | Current Price | \"50000.12345678 USD\" | Market price at milestone |\n| `timestamp` | Timestamp | ISO 8601 | Event time |\n| `mode` | Mode | \"Backtest\" / \"Live\" | Execution mode |\n\n**Sources**: [src/lib/services/markdown/PartialMarkdownService.ts:1-500](), [src/lib/services/markdown/PartialMarkdownService.ts:52-138]()\n\n---\n\n## Usage Examples\n\n### Listening to Partial Events\n\n```typescript\nimport { listenPartialProfit, listenPartialLoss } from 'backtest-kit';\n\n// Subscribe to all profit milestones\nconst unsubProfit = listenPartialProfit((event) => {\n  console.log(`${event.symbol} reached +${event.level}% profit`);\n  console.log(`Signal ID: ${event.data.id}, Price: ${event.currentPrice}`);\n});\n\n// Subscribe to all loss milestones\nconst unsubLoss = listenPartialLoss((event) => {\n  console.log(`${event.symbol} reached -${event.level}% loss`);\n});\n\n// One-time listener for specific condition\nlistenPartialProfitOnce(\n  (event) => event.level === 50 && event.symbol === 'BTCUSDT',\n  (event) => {\n    console.log('BTCUSDT reached 50% profit milestone');\n  }\n);\n```\n\n### Generating Partial Reports\n\n```typescript\nimport { Partial } from 'backtest-kit';\n\n// Get statistics for symbol-strategy pair\nconst stats = await Partial.getData('BTCUSDT', 'my-strategy');\nconsole.log(`Total profit events: ${stats.totalProfit}`);\nconsole.log(`Total loss events: ${stats.totalLoss}`);\n\n// Generate markdown report\nconst markdown = await Partial.getReport('BTCUSDT', 'my-strategy');\nconsole.log(markdown);\n\n// Save report to disk\nawait Partial.dump('BTCUSDT', 'my-strategy', './reports/partial');\n// Writes to: ./reports/partial/BTCUSDT_my-strategy.md\n```\n\n**Sources**: [src/function/event.ts:280-380](), [src/classes/Partial.ts:1-100]()\n\n---\n\n## Strategy Callback Integration\n\nStrategies can receive partial profit/loss events through callbacks:\n\n```typescript\nimport { addStrategy } from 'backtest-kit';\n\naddStrategy({\n  strategyName: 'my-strategy',\n  interval: '1m',\n  getSignal: async (symbol, when) => {\n    // Signal generation logic\n    return null;\n  },\n  callbacks: {\n    onPartialProfit: (symbol, data, currentPrice, revenuePercent, backtest) => {\n      console.log(`Signal ${data.id} has ${revenuePercent}% profit`);\n      console.log(`Current price: ${currentPrice}`);\n    },\n    onPartialLoss: (symbol, data, currentPrice, lossPercent, backtest) => {\n      console.log(`Signal ${data.id} has ${lossPercent}% loss`);\n      console.log(`Current price: ${currentPrice}`);\n    }\n  }\n});\n```\n\n**Callback Timing**: Called from [src/client/ClientStrategy.ts:920-960]() during signal monitoring in `tick()` and `backtest()` methods, before partial events are emitted to subjects.\n\n**Sources**: [src/interfaces/Strategy.interface.ts:122-125](), [src/client/ClientStrategy.ts:900-1000]()\n\n---\n\n## Persistence and Crash Recovery\n\n### File Structure\n\nPartial state is persisted to:\n```\n./dump/partial/{symbol}_partial.json\n```\n\nExample file content:\n```json\n{\n  \"signal-uuid-1\": {\n    \"profitLevels\": [10, 20],\n    \"lossLevels\": []\n  },\n  \"signal-uuid-2\": {\n    \"profitLevels\": [],\n    \"lossLevels\": [10]\n  }\n}\n```\n\n### Recovery Flow\n\n```mermaid\nsequenceDiagram\n    participant CS as ClientStrategy\n    participant PC as PartialConnectionService\n    participant CP as ClientPartial\n    participant PPA as PersistPartialAdapter\n    \n    Note over CS: Live.run() starts\n    CS->>PC: getPartial(symbol)\n    PC->>CP: new ClientPartial()\n    CP->>CP: waitForInit()\n    CP->>PPA: readPartialData(symbol)\n    PPA->>PPA: Read {symbol}_partial.json\n    PPA-->>CP: Record<signalId, IPartialData>\n    \n    Note over CP: Convert arrays to Sets\n    loop For each signal\n        CP->>CP: _states.set(signalId, {<br/>profitLevels: new Set(data.profitLevels),<br/>lossLevels: new Set(data.lossLevels)<br/>})\n    end\n    \n    CP-->>CS: Ready for tick()\n    Note over CS: Resume monitoring with restored state\n```\n\n**Atomic Write Pattern**: `PersistPartialAdapter` uses the same atomic write mechanism as `PersistSignalAdapter` - write to temp file, then rename to ensure no corruption on crash.\n\n**Sources**: [src/classes/Persist.ts:350-450](), [src/client/ClientPartial.ts:80-120]()\n\n---\n\n## Implementation Details\n\n### Level Detection Algorithm\n\nThe `profit()` method in `ClientPartial` implements milestone detection:\n\n```typescript\n// Simplified from src/client/ClientPartial.ts:150-200\nasync profit(symbol: string, data: ISignalRow, currentPrice: number, \n             revenuePercent: number, backtest: boolean, when: Date) {\n  \n  // Get or create state for this signal\n  const state = this._states.get(data.id) || { \n    profitLevels: new Set(), \n    lossLevels: new Set() \n  };\n  \n  // Determine which levels have been crossed\n  const levelsToEmit: PartialLevel[] = [];\n  for (const level of [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]) {\n    if (revenuePercent >= level && !state.profitLevels.has(level)) {\n      state.profitLevels.add(level);\n      levelsToEmit.push(level);\n    }\n  }\n  \n  // Emit events for new levels only\n  for (const level of levelsToEmit) {\n    this.params.onProfit(symbol, data, currentPrice, level, backtest, when.getTime());\n  }\n  \n  // Persist updated state\n  this._states.set(data.id, state);\n  await this.persist(symbol);\n}\n```\n\n**Key Property**: Once a level is added to the Set, it cannot be re-added, ensuring each milestone is reported exactly once per signal.\n\n**Sources**: [src/client/ClientPartial.ts:150-250]()\n\n---\n\n## Performance Considerations\n\n### Memoization Strategy\n\n| Service | Memoization Key | Cache Scope | Rationale |\n|---------|----------------|-------------|-----------|\n| `PartialConnectionService.getPartial()` | `symbol` | Per symbol | Shared across all strategies trading same symbol |\n| `PartialMarkdownService.getStorage()` | `symbol:strategyName` | Per symbol-strategy pair | Separate reports for each strategy |\n\n### Memory Management\n\n- **In-Memory State**: `_states` Map grows with number of active signals, cleared on signal close via `clear()`\n- **Event Storage**: Bounded at MAX_EVENTS = 250 per symbol-strategy pair in `PartialMarkdownService`\n- **Persistence**: JSON file size grows with concurrent active signals, not cumulative signal count\n\n### Event Emission Overhead\n\nPartial events are emitted frequently during active signal monitoring (potentially every `tick()` call when price moves through thresholds). The queued processing pattern in listener functions ensures sequential execution without blocking the main monitoring loop.\n\n**Sources**: [src/lib/services/connection/PartialConnectionService.ts:50-100](), [src/lib/services/markdown/PartialMarkdownService.ts:140-145]()"
                    },
                    {
                        "page_plan": {
                            "id": "10",
                            "title": "Demo Applications"
                        },
                        "content": "# Demo Applications\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/.env.example](demo/optimization/.env.example)\n- [demo/optimization/.gitignore](demo/optimization/.gitignore)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [demo/optimization/src/index.mjs](demo/optimization/src/index.mjs)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [src/contract/ProgressOptimizer.contract.ts](src/contract/ProgressOptimizer.contract.ts)\n- [src/interfaces/Heatmap.interface.ts](src/interfaces/Heatmap.interface.ts)\n- [test/e2e/defend.test.mjs](test/e2e/defend.test.mjs)\n- [test/e2e/risk.test.mjs](test/e2e/risk.test.mjs)\n- [test/index.mjs](test/index.mjs)\n- [test/mock/getMockCandles.mjs](test/mock/getMockCandles.mjs)\n- [test/spec/heat.test.mjs](test/spec/heat.test.mjs)\n- [test/spec/list.test.mjs](test/spec/list.test.mjs)\n\n</details>\n\n\n\nThis page documents the included demo applications that showcase the framework's capabilities. The demos provide practical examples of backtesting, live trading, and LLM-based strategy optimization using real market data and executable code.\n\nFor framework configuration details, see [Global Configuration Parameters](#7.1). For execution mode details, see [Execution Modes Overview](#2.2) and the detailed execution mode pages ([Backtest Mode](#5.1), [Live Trading Mode](#5.2), [Optimizer Mode](#5.4)).\n\n---\n\n## Demo Projects Structure\n\nThe codebase includes three demonstration applications located in the `demo/` directory, each illustrating a different execution mode of the framework.\n\n```mermaid\ngraph TB\n    subgraph \"demo/ Directory\"\n        BACKTEST[\"demo/backtest/<br/>Historical Testing\"]\n        LIVE[\"demo/live/<br/>Real-Time Trading\"]\n        OPT[\"demo/optimization/<br/>LLM Strategy Generation\"]\n    end\n    \n    subgraph \"Backtest Demo Files\"\n        BT_PKG[\"package.json<br/>Dependencies\"]\n        BT_SRC[\"src/index.mjs<br/>Main Entry\"]\n    end\n    \n    subgraph \"Live Demo Files\"\n        LV_PKG[\"package.json<br/>Dependencies\"]\n        LV_SRC[\"src/index.mjs<br/>Main Entry\"]\n    end\n    \n    subgraph \"Optimization Demo Files\"\n        OPT_PKG[\"package.json<br/>Dependencies\"]\n        OPT_SRC[\"src/index.mjs<br/>Main Entry\"]\n        OPT_ENV[\".env.example<br/>Configuration Template\"]\n    end\n    \n    subgraph \"Shared Dependencies\"\n        BT_KIT[\"backtest-kit: 1.5.20<br/>Core Framework\"]\n        CCXT[\"ccxt: 4.5.24<br/>Exchange Integration\"]\n        OLLAMA[\"ollama: 0.6.3<br/>LLM API Client\"]\n        UUID[\"uuid: 13.0.0<br/>ID Generation\"]\n        FUNCTOOLS[\"functools-kit: 1.0.94<br/>Utilities\"]\n    end\n    \n    BACKTEST --> BT_PKG\n    BACKTEST --> BT_SRC\n    \n    LIVE --> LV_PKG\n    LIVE --> LV_SRC\n    \n    OPT --> OPT_PKG\n    OPT --> OPT_SRC\n    OPT --> OPT_ENV\n    \n    BT_PKG --> BT_KIT\n    BT_PKG --> CCXT\n    BT_PKG --> UUID\n    BT_PKG --> FUNCTOOLS\n    \n    LV_PKG --> BT_KIT\n    LV_PKG --> CCXT\n    LV_PKG --> OLLAMA\n    LV_PKG --> UUID\n    LV_PKG --> FUNCTOOLS\n    \n    OPT_PKG --> BT_KIT\n    OPT_PKG --> CCXT\n    OPT_PKG --> OLLAMA\n    OPT_PKG --> UUID\n    OPT_PKG --> FUNCTOOLS\n```\n\n**Demo Application Comparison**\n\n| Demo | Purpose | Execution Mode | Key Features | Output |\n|------|---------|---------------|--------------|--------|\n| Backtest | Historical simulation | Finite iteration over timeframes | Fast candle processing, TP/SL/time monitoring | Closed signals, markdown reports |\n| Live | Real-time trading | Infinite loop with persistence | Crash-safe recovery, atomic writes | Opened/closed signals, state files |\n| Optimization | LLM strategy generation | Multi-source data aggregation | Ollama API integration, code export | Executable .mjs strategy files |\n\n**Sources:** [demo/backtest/package.json:1-19](), [demo/live/package.json:1-19](), [demo/optimization/package.json:1-19]()\n\n---\n\n## Shared Dependencies and Configuration\n\nAll demo applications share a common dependency structure, with variations based on their specific requirements.\n\n**Core Dependencies**\n\n| Package | Version | Purpose | Used By |\n|---------|---------|---------|---------|\n| `backtest-kit` | 1.5.20 | Core framework library | All demos |\n| `ccxt` | 4.5.24 | Exchange API integration for market data | All demos |\n| `functools-kit` | 1.0.94 | Functional utilities (Subject, fetchApi, etc.) | All demos |\n| `uuid` | 13.0.0 | Signal ID generation | All demos |\n| `ollama` | 0.6.3 | LLM API client for strategy generation | Live, Optimization |\n| `dotenv-cli` | 11.0.0 | Environment variable management (dev) | All demos |\n\n**Package Scripts**\n\nEach demo includes a standardized `start` script that loads environment variables and executes the main entry point:\n\n```json\n\"scripts\": {\n  \"start\": \"dotenv -e .env -- node ./src/index.mjs\"\n}\n```\n\nThis pattern is consistent across all demos at [demo/backtest/package.json:5-7](), [demo/live/package.json:5-7](), and [demo/optimization/package.json:5-7]().\n\n**Sources:** [demo/backtest/package.json:1-19](), [demo/live/package.json:1-19](), [demo/optimization/package.json:1-19]()\n\n---\n\n## Backtest Demo\n\nThe backtest demo demonstrates historical simulation of trading strategies using the framework's `Backtest` execution mode. This is the simplest demo, focusing on core backtesting functionality without external API dependencies.\n\n**Key Characteristics**\n\n- **Execution Mode:** `Backtest.run()` or `Backtest.background()`\n- **Data Source:** CCXT exchange API or mock data\n- **Output:** Closed signals with PnL calculations\n- **Reporting:** Markdown reports via `Backtest.dump()`\n\n**Typical Usage Pattern**\n\n```typescript\n// Configuration\naddExchange({ exchangeName, getCandles, formatPrice, formatQuantity });\naddStrategy({ strategyName, interval, getSignal, riskName });\naddFrame({ frameName, interval, startDate, endDate });\n\n// Execution\nBacktest.background(symbol, { strategyName, exchangeName, frameName });\n\n// Event Monitoring\nlistenSignalBacktest((event) => console.log(event));\nlistenDoneBacktest(async (event) => {\n  await Backtest.dump(event.symbol, event.strategyName);\n});\n```\n\nThe backtest demo iterates through a pre-generated timeframe array, processing each timestamp sequentially. For each tick, the framework checks for signal generation (throttled by `interval`), then uses fast candle processing to monitor TP/SL/time conditions and skip to the close timestamp for efficiency.\n\n**Sources:** [README.md:140-154](), [demo/backtest/package.json:1-19]()\n\n---\n\n## Live Trading Demo\n\nThe live trading demo demonstrates real-time execution with crash-safe persistence. This demo showcases the framework's production-ready capabilities for continuous operation.\n\n**Key Characteristics**\n\n- **Execution Mode:** `Live.run()` or `Live.background()`\n- **Persistence:** Atomic JSON file writes via `PersistSignalAdapter`\n- **Recovery:** `waitForInit()` loads previous state on restart\n- **Loop:** Infinite `while` loop with 61-second sleep intervals (`TICK_TTL`)\n- **Output:** Opened/closed signals only (filters idle/active states)\n\n**Typical Usage Pattern**\n\n```typescript\n// Configuration (same as backtest)\naddExchange({ exchangeName, getCandles, formatPrice, formatQuantity });\naddStrategy({ strategyName, interval, getSignal, riskName });\n\n// Live Execution\nLive.background(symbol, { strategyName, exchangeName });\n\n// Event Monitoring\nlistenSignalLive((event) => console.log(event));\n```\n\nThe live demo runs continuously, using `new Date()` for each tick's timestamp. State is persisted after each tick to JSON files in the `./dump/` directory, enabling crash recovery. The framework waits for all positions to close before allowing graceful shutdown via `doneLiveSubject`.\n\n**Sources:** [README.md:156-166](), [demo/live/package.json:1-19]()\n\n---\n\n## Optimization Demo: LLM-Based Strategy Generation\n\nThe optimization demo is the most complex, showcasing the framework's ability to generate trading strategies using large language models (LLMs). This demo fetches multi-timeframe historical data, formats it for LLM consumption, and generates executable strategy code.\n\n```mermaid\ngraph TB\n    subgraph \"demo/optimization/src/index.mjs\"\n        MAIN[\"Main Entry Point\"]\n        TRAIN[\"TRAIN_RANGE Array<br/>7 days for training\"]\n        TEST[\"TEST_RANGE Object<br/>1 day for testing\"]\n        SOURCE_LIST[\"SOURCE_LIST Array<br/>4 data sources\"]\n        FETCH_HELPERS[\"arrayToMarkdownTable()<br/>Data formatting\"]\n    end\n    \n    subgraph \"addOptimizer() Configuration\"\n        OPT_NAME[\"optimizerName\"]\n        OPT_SOURCES[\"sources: SOURCE_LIST\"]\n        OPT_PROMPT[\"getPrompt callback\"]\n    end\n    \n    subgraph \"SOURCE_LIST Items\"\n        LONG_TERM[\"long-term-range<br/>1h candles, 48 lookback\"]\n        SWING_TERM[\"swing-term-range<br/>30m candles, 96 lookback\"]\n        SHORT_TERM[\"short-term-range<br/>15m candles, 60 lookback\"]\n        MICRO_TERM[\"micro-term-range<br/>1m candles, 60 lookback\"]\n    end\n    \n    subgraph \"External Services\"\n        DUMPER[\"CCXT_DUMPER_URL<br/>node-ccxt-dumper API\"]\n        OLLAMA_API[\"Ollama API<br/>deepseek-v3.1:671b model\"]\n    end\n    \n    subgraph \"Optimizer Execution Flow\"\n        ITER_SOURCES[\"Iterate sources<br/>OptimizerGlobalService\"]\n        FETCH_DATA[\"fetch() callback<br/>fetchApi + CCXT_DUMPER_URL\"]\n        FORMAT_MSG[\"Format LLM messages<br/>user() + assistant()\"]\n        CALL_LLM[\"Ollama.chat()<br/>Generate strategy code\"]\n        TEMPLATE[\"OptimizerTemplateService<br/>Wrap code in template\"]\n        EXPORT[\"Optimizer.dump()<br/>Write .mjs file\"]\n    end\n    \n    MAIN --> TRAIN\n    MAIN --> TEST\n    MAIN --> SOURCE_LIST\n    MAIN --> FETCH_HELPERS\n    \n    SOURCE_LIST --> LONG_TERM\n    SOURCE_LIST --> SWING_TERM\n    SOURCE_LIST --> SHORT_TERM\n    SOURCE_LIST --> MICRO_TERM\n    \n    MAIN --> OPT_NAME\n    MAIN --> OPT_SOURCES\n    MAIN --> OPT_PROMPT\n    \n    OPT_SOURCES --> ITER_SOURCES\n    ITER_SOURCES --> FETCH_DATA\n    FETCH_DATA --> DUMPER\n    FETCH_DATA --> FORMAT_MSG\n    FORMAT_MSG --> OPT_PROMPT\n    OPT_PROMPT --> CALL_LLM\n    CALL_LLM --> OLLAMA_API\n    CALL_LLM --> TEMPLATE\n    TEMPLATE --> EXPORT\n```\n\n**Data Source Configuration**\n\nThe demo defines four data sources with different timeframes and indicator sets. Each source has a `fetch` callback that queries the CCXT Dumper API and a `user` callback that formats the data into markdown tables for LLM consumption.\n\n| Source Name | Timeframe | Lookback | Key Indicators | API Endpoint |\n|-------------|-----------|----------|----------------|--------------|\n| `long-term-range` | 1h | 48 candles | RSI(14), MACD(12,26,9), ADX(14), Bollinger(20,2.0), EMA(20,34), Fibonacci | `/view/long-term-range` |\n| `swing-term-range` | 30m | 96 candles | RSI(14), MACD(12,26,9), Stochastic(14,3,3), CCI(20), DEMA(21) | `/view/swing-term-range` |\n| `short-term-range` | 15m | 60 candles | RSI(9), MACD(8,21,5), ADX(14), Bollinger(10,2.0), ROC(5,10) | `/view/short-term-range` |\n| `micro-term-range` | 1m | 60 candles | RSI(9), MACD(8,21,5), Stochastic(3,3,3), ADX(9), ATR(5,9) | `/view/micro-term-range` |\n\nEach source configuration is defined at [demo/optimization/src/index.mjs:66-303]().\n\n**Training and Testing Date Ranges**\n\nThe demo uses a 7-day training period and a 1-day testing period:\n\n- **Training:** [demo/optimization/src/index.mjs:19-55]() defines `TRAIN_RANGE` with 7 consecutive days (November 24-30, 2025)\n- **Testing:** [demo/optimization/src/index.mjs:57-61]() defines `TEST_RANGE` for December 1, 2025\n\n**LLM Message Formatting**\n\nEach data source provides a `user()` callback that formats fetched data into markdown tables with detailed explanations of indicators and their parameters. For example, the 1-hour source includes:\n\n```markdown\n# 1-Hour Candles Trading Analysis for BTCUSDT (Historical Data)\n\n| timestamp | rsi_14 | stoch_rsi_14 | macd | signal | ... |\n| --- | --- | --- | --- | --- | ... |\n| ... data rows ... |\n\n## Data Sources\n- **Timeframe**: 1-hour candles\n- **Lookback Period**: 48 candles (48 hours)\n- **RSI(14)**: over previous 14 candles before row timestamp (Min: 0, Max: 100)\n...\n```\n\nThis pattern is repeated for all four sources at [demo/optimization/src/index.mjs:83-122](), [demo/optimization/src/index.mjs:141-179](), [demo/optimization/src/index.mjs:198-234](), and [demo/optimization/src/index.mjs:253-301]().\n\n**Code Generation and Export**\n\nThe optimizer orchestrates the following workflow:\n\n1. **Iterate Data Sources:** `OptimizerGlobalService` loops through each source in `SOURCE_LIST`\n2. **Fetch Historical Data:** For each training date range, the `fetch()` callback queries the CCXT Dumper API\n3. **Format for LLM:** The `user()` callback converts data into markdown tables\n4. **Generate Strategy:** The `getPrompt()` callback sends formatted data to Ollama API (model: `deepseek-v3.1:671b`)\n5. **Wrap in Template:** `OptimizerTemplateService` wraps generated code in executable template\n6. **Export File:** `Optimizer.dump()` writes the complete strategy to `./generated/{optimizerName}_{symbol}.mjs`\n\nThe generated file includes:\n- `addExchange()` configuration\n- `addStrategy()` with LLM-generated signal logic\n- `addFrame()` for testing period\n- `Walker.background()` to compare multiple strategies\n\n**Sources:** [demo/optimization/src/index.mjs:1-303](), [demo/optimization/package.json:1-19]()\n\n---\n\n## Environment Configuration\n\nAll demos support environment variable configuration via `.env` files. The optimization demo requires specific environment variables for external service integration.\n\n**Optimization Demo Environment Variables**\n\nThe optimization demo requires two environment variables defined in [demo/optimization/.env.example:1-3]():\n\n| Variable | Purpose | Example |\n|----------|---------|---------|\n| `OLLAMA_API_KEY` | Authentication for Ollama API (optional) | `your-api-key-here` |\n| `CCXT_DUMPER_URL` | Base URL for CCXT Dumper API service | `http://localhost:3000` |\n\nThe `CCXT_DUMPER_URL` is used to construct API endpoints for fetching historical candle data with calculated indicators. This service is referenced in the code as a comment: [demo/optimization/src/index.mjs:64]() points to `https://github.com/tripolskypetr/node-ccxt-dumper`.\n\n**General Configuration**\n\nAll demos can use the framework's global configuration via `setConfig()` and `setLogger()` as shown in [README.md:42-58]():\n\n```typescript\nimport { setLogger, setConfig } from 'backtest-kit';\n\n// Enable logging\nsetLogger({\n  log: console.log,\n  debug: console.debug,\n  info: console.info,\n  warn: console.warn,\n});\n\n// Global config (optional)\nsetConfig({\n  CC_PERCENT_SLIPPAGE: 0.1,  // % slippage\n  CC_PERCENT_FEE: 0.1,       // % fee\n  CC_SCHEDULE_AWAIT_MINUTES: 120,  // Pending signal timeout\n});\n```\n\n**Sources:** [demo/optimization/.env.example:1-3](), [README.md:42-58]()\n\n---\n\n## Running Demo Applications\n\nAll demo applications follow a consistent installation and execution pattern.\n\n**Installation Steps**\n\n1. **Navigate to Demo Directory:**\n   ```bash\n   cd demo/backtest  # or demo/live or demo/optimization\n   ```\n\n2. **Install Dependencies:**\n   ```bash\n   npm install\n   ```\n\n3. **Configure Environment (if needed):**\n   ```bash\n   cp .env.example .env\n   # Edit .env with your configuration\n   ```\n\n**Execution Commands**\n\nEach demo provides a `start` script that handles environment loading and execution:\n\n```bash\nnpm start\n```\n\nThis executes the command defined in `package.json`:\n```json\n\"scripts\": {\n  \"start\": \"dotenv -e .env -- node ./src/index.mjs\"\n}\n```\n\nThe `dotenv-cli` package (dev dependency) loads variables from `.env` before executing the Node.js script.\n\n**Execution Flow Diagram**\n\n```mermaid\ngraph LR\n    subgraph \"Execution Command\"\n        NPM[\"npm start\"]\n    end\n    \n    subgraph \"dotenv-cli\"\n        LOAD_ENV[\"Load .env file\"]\n        INJECT[\"Inject process.env\"]\n    end\n    \n    subgraph \"Node.js Runtime\"\n        EXEC[\"node src/index.mjs\"]\n    end\n    \n    subgraph \"Demo Application\"\n        IMPORT[\"Import backtest-kit\"]\n        CONFIG[\"Configure components<br/>addExchange, addStrategy, etc.\"]\n        RUN[\"Execute mode<br/>Backtest/Live/Optimizer\"]\n        LISTEN[\"Event listeners<br/>listenSignal*, listenDone*\"]\n        OUTPUT[\"Generate output<br/>Reports/Files/Console\"]\n    end\n    \n    NPM --> LOAD_ENV\n    LOAD_ENV --> INJECT\n    INJECT --> EXEC\n    EXEC --> IMPORT\n    IMPORT --> CONFIG\n    CONFIG --> RUN\n    RUN --> LISTEN\n    LISTEN --> OUTPUT\n```\n\n**Expected Outputs**\n\n| Demo | Console Output | File Output | Duration |\n|------|---------------|-------------|----------|\n| Backtest | Signal events, progress, final statistics | `./dump/backtest_{symbol}_{strategy}.md` | Minutes (depends on timeframe) |\n| Live | Signal events, tick updates | `./dump/live_{symbol}_{strategy}.json` (state) | Continuous (until stopped) |\n| Optimization | Progress updates, LLM responses | `./generated/{optimizer}_{symbol}.mjs` (strategy code) | Minutes to hours (depends on LLM) |\n\n**Sources:** [demo/backtest/package.json:5-7](), [demo/live/package.json:5-7](), [demo/optimization/package.json:5-7](), [README.md:33-166]()\n\n---\n\n## Demo Code Examples from README\n\nThe README includes complete working examples that can serve as templates for custom demos. These examples are located at [README.md:60-154]() and demonstrate:\n\n**Basic Configuration Example**\n\n```typescript\nimport ccxt from 'ccxt';\nimport { addExchange, addStrategy, addFrame, addRisk } from 'backtest-kit';\n\n// Exchange registration\naddExchange({\n  exchangeName: 'binance',\n  getCandles: async (symbol, interval, since, limit) => {\n    const exchange = new ccxt.binance();\n    const ohlcv = await exchange.fetchOHLCV(symbol, interval, since.getTime(), limit);\n    return ohlcv.map(([timestamp, open, high, low, close, volume]) => \n      ({ timestamp, open, high, low, close, volume })\n    );\n  },\n  formatPrice: (symbol, price) => price.toFixed(2),\n  formatQuantity: (symbol, quantity) => quantity.toFixed(8),\n});\n\n// Risk profile with validation\naddRisk({\n  riskName: 'demo',\n  validations: [\n    ({ pendingSignal, currentPrice }) => {\n      const { priceOpen = currentPrice, priceTakeProfit, position } = pendingSignal;\n      const tpDistance = position === 'long' \n        ? ((priceTakeProfit - priceOpen) / priceOpen) * 100 \n        : ((priceOpen - priceTakeProfit) / priceOpen) * 100;\n      if (tpDistance < 1) throw new Error(`TP too close: ${tpDistance.toFixed(2)}%`);\n    },\n  ],\n});\n\n// Timeframe definition\naddFrame({\n  frameName: '1d-test',\n  interval: '1m',\n  startDate: new Date('2025-12-01'),\n  endDate: new Date('2025-12-02'),\n});\n```\n\n**LLM-Enhanced Strategy Example**\n\n```typescript\nimport { v4 as uuid } from 'uuid';\nimport { addStrategy, dumpSignal, getCandles } from 'backtest-kit';\n\naddStrategy({\n  strategyName: 'llm-strategy',\n  interval: '5m',\n  riskName: 'demo',\n  getSignal: async (symbol) => {\n    // Fetch multi-timeframe data\n    const candles1h = await getCandles(symbol, \"1h\", 24);\n    const candles15m = await getCandles(symbol, \"15m\", 48);\n    const candles5m = await getCandles(symbol, \"5m\", 60);\n    const candles1m = await getCandles(symbol, \"1m\", 60);\n\n    // Prepare messages with indicators\n    const messages = await getMessages(symbol, {\n      candles1h, candles15m, candles5m, candles1m,\n    });\n  \n    // Generate signal via LLM\n    const resultId = uuid();\n    const signal = await json(messages);\n    await dumpSignal(resultId, messages, signal);\n\n    return { ...signal, id: resultId };\n  },\n});\n```\n\nThese examples demonstrate the framework's flexibility and can be adapted for custom demo applications.\n\n**Sources:** [README.md:60-138]()"
                    },
                    {
                        "page_plan": {
                            "id": "10.1",
                            "title": "Optimization Demo"
                        },
                        "content": "# Optimization Demo\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [demo/optimization/.env.example](demo/optimization/.env.example)\n- [demo/optimization/.gitignore](demo/optimization/.gitignore)\n- [demo/optimization/src/index.mjs](demo/optimization/src/index.mjs)\n- [src/classes/Optimizer.ts](src/classes/Optimizer.ts)\n- [src/client/ClientOptimizer.ts](src/client/ClientOptimizer.ts)\n- [src/contract/ProgressOptimizer.contract.ts](src/contract/ProgressOptimizer.contract.ts)\n- [src/interfaces/Optimizer.interface.ts](src/interfaces/Optimizer.interface.ts)\n- [src/lib/services/connection/OptimizerConnectionService.ts](src/lib/services/connection/OptimizerConnectionService.ts)\n- [src/lib/services/global/OptimizerGlobalService.ts](src/lib/services/global/OptimizerGlobalService.ts)\n- [src/lib/services/schema/OptimizerSchemaService.ts](src/lib/services/schema/OptimizerSchemaService.ts)\n- [src/lib/services/template/OptimizerTemplateService.ts](src/lib/services/template/OptimizerTemplateService.ts)\n- [src/lib/services/validation/OptimizerValidationService.ts](src/lib/services/validation/OptimizerValidationService.ts)\n- [src/model/Message.model.ts](src/model/Message.model.ts)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThe optimization demo demonstrates the **LLM-based strategy generation** capabilities of backtest-kit. This demo uses historical market data from multiple timeframes to generate trading strategies via Large Language Model (LLM) inference, then produces executable strategy code that can be backtested using the Walker mode.\n\nThe demo showcases:\n- Multi-timeframe technical analysis data collection (1m, 15m, 30m, 1h candles)\n- LLM conversation history building with market data\n- Automated strategy code generation with complete executable output\n- Integration with external data sources (CCXT Dumper API) and LLM providers (Ollama)\n\nFor general Optimizer system architecture, see [Optimizer Mode](#5.4). For information on running demos in general, see [Running Demos](#10.2).\n\n**Sources:** [demo/optimization/src/index.mjs:1-399]()\n\n---\n\n## Demo Architecture and Data Flow\n\nThe optimization demo follows a structured pipeline from data collection through LLM inference to code generation:\n\n```mermaid\ngraph TB\n    CONFIG[\"Configuration<br/>(index.mjs)\"]\n    TRAIN[\"Training Ranges<br/>TRAIN_RANGE<br/>7 days (Nov 24-30)\"]\n    TEST[\"Testing Range<br/>TEST_RANGE<br/>1 day (Dec 1)\"]\n    \n    subgraph \"Data Sources\"\n        S1[\"long-term-range<br/>1h candles<br/>48 lookback\"]\n        S2[\"swing-term-range<br/>30m candles<br/>96 lookback\"]\n        S3[\"short-term-range<br/>15m candles<br/>192 lookback\"]\n        S4[\"micro-term-range<br/>1m candles<br/>60 lookback\"]\n    end\n    \n    subgraph \"Data Collection (ClientOptimizer.getData)\"\n        FETCH[\"RESOLVE_PAGINATION_FN<br/>iterateDocuments<br/>distinctDocuments<br/>ITERATION_LIMIT=25\"]\n        DUMPER[\"CCXT_DUMPER_URL<br/>/view/long-term-range<br/>/view/swing-term-range<br/>/view/short-term-range<br/>/view/micro-term-range\"]\n        FORMAT[\"arrayToMarkdownTable<br/>User/Assistant Messages\"]\n    end\n    \n    subgraph \"LLM Processing\"\n        MESSAGES[\"MessageModel[]<br/>Conversation History\"]\n        PROMPT[\"getPrompt callback<br/>text() function\"]\n        OLLAMA[\"Ollama API<br/>deepseek-v3.1:671b<br/>think: true\"]\n        STRATEGY[\"Strategy String<br/>Trading logic description\"]\n    end\n    \n    subgraph \"Code Generation (ClientOptimizer.getCode)\"\n        TEMPLATE[\"OptimizerTemplateService<br/>getTopBanner<br/>getStrategyTemplate<br/>getWalkerTemplate<br/>etc.\"]\n        CODE[\"Generated .mjs File<br/>Executable strategy code\"]\n    end\n    \n    subgraph \"Output\"\n        DUMP[\"Optimizer.dump<br/>btc-optimizer_BTCUSDT.mjs<br/>./generated directory\"]\n    end\n    \n    CONFIG --> TRAIN\n    CONFIG --> TEST\n    CONFIG --> S1\n    CONFIG --> S2\n    CONFIG --> S3\n    CONFIG --> S4\n    \n    TRAIN --> FETCH\n    S1 --> FETCH\n    S2 --> FETCH\n    S3 --> FETCH\n    S4 --> FETCH\n    \n    FETCH --> DUMPER\n    DUMPER --> FORMAT\n    FORMAT --> MESSAGES\n    \n    MESSAGES --> PROMPT\n    PROMPT --> OLLAMA\n    OLLAMA --> STRATEGY\n    \n    STRATEGY --> TEMPLATE\n    TEMPLATE --> CODE\n    CODE --> DUMP\n    \n    style OLLAMA fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style CODE fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style DUMPER fill:#f9f9f9,stroke:#333,stroke-width:2px\n```\n\n**Workflow:**\n\n1. **Configuration**: Demo defines 7 training ranges (one per day) and 1 testing range\n2. **Data Collection**: For each training range, fetch data from 4 timeframe sources via pagination\n3. **Message Formatting**: Convert technical indicator data to markdown tables for LLM consumption\n4. **LLM Inference**: Build conversation history and call Ollama API to generate strategy logic\n5. **Code Generation**: Use `OptimizerTemplateService` to create complete executable code\n6. **File Export**: Save generated strategy to `./generated/btc-optimizer_BTCUSDT.mjs`\n\n**Sources:** [demo/optimization/src/index.mjs:1-399](), [src/client/ClientOptimizer.ts:99-215](), [src/lib/services/template/OptimizerTemplateService.ts:1-716]()\n\n---\n\n## Data Source Configuration\n\nThe demo configures four data sources, each representing a different timeframe for technical analysis. These sources fetch pre-calculated technical indicators from the CCXT Dumper API.\n\n### Source Specifications\n\n| Source Name | Timeframe | Lookback Period | Key Indicators |\n|------------|-----------|-----------------|----------------|\n| `long-term-range` | 1-hour candles | 48 candles (48h) | RSI(14), MACD(12,26,9), ADX(14), ATR(14), Bollinger(20,2.0), Fibonacci levels |\n| `swing-term-range` | 30-minute candles | 96 candles (48h) | RSI(14), MACD(12,26,9), ADX(14), CCI(20), Stochastic(14,3,3), Momentum(8) |\n| `short-term-range` | 15-minute candles | 192 candles (48h) | RSI(9), MACD(8,21,5), ADX(14), CCI(14), ROC(5,10), Support/Resistance |\n| `micro-term-range` | 1-minute candles | 60 candles (1h) | RSI(9), MACD(8,21,5), Bollinger(8,2.0), Stochastic(3,3,3), ATR(5,9), Squeeze Momentum |\n\n### Source Structure\n\nEach source in `SOURCE_LIST` implements `IOptimizerSource` interface:\n\n```mermaid\ngraph LR\n    SOURCE[\"IOptimizerSource\"]\n    NAME[\"name: string<br/>'long-term-range'\"]\n    FETCH[\"fetch: IOptimizerSourceFn<br/>Pagination support<br/>limit, offset params\"]\n    USER[\"user: (symbol, data, name)<br/>Format markdown table<br/>with indicator descriptions\"]\n    ASSISTANT[\"assistant: (symbol, data, name)<br/>Acknowledgment message<br/>'Данные получены'\"]\n    \n    SOURCE --> NAME\n    SOURCE --> FETCH\n    SOURCE --> USER\n    SOURCE --> ASSISTANT\n    \n    FETCH --> URL[\"URL Construction<br/>symbol, startDate, endDate<br/>limit, offset\"]\n    FETCH --> API[\"fetchApi(url)<br/>Returns {rows: data[]}\"]\n    \n    USER --> TABLE[\"arrayToMarkdownTable(data)<br/>Format as pipe-delimited table\"]\n    USER --> META[\"Metadata Section<br/>Indicator formulas<br/>Lookback periods\"]\n```\n\n**Fetch Function Example:**\n\nThe fetch function constructs URLs with query parameters and retrieves data from CCXT Dumper API:\n\n```\nURL: ${CCXT_DUMPER_URL}/view/long-term-range\nParams: symbol, startDate (timestamp), endDate (timestamp), limit (1000), offset (0)\nResponse: { rows: Array<IOptimizerData> }\n```\n\n**User Message Format:**\n\nEach user message contains:\n1. Title: \"# {Timeframe} Candles Trading Analysis for {symbol} (Historical Data)\"\n2. Markdown table with all indicator values\n3. Data Sources section explaining each indicator with min/max ranges\n\n**Sources:** [demo/optimization/src/index.mjs:66-310](), [src/interfaces/Optimizer.interface.ts:129-177]()\n\n---\n\n## LLM Integration and Prompt Construction\n\nThe demo uses Ollama API with the `deepseek-v3.1:671b` model to generate trading strategies. The LLM receives multi-timeframe market data and produces strategy recommendations.\n\n### Message Flow Sequence\n\n```mermaid\nsequenceDiagram\n    participant Demo as index.mjs\n    participant Source as Data Sources\n    participant Format as arrayToMarkdownTable\n    participant Messages as MessageModel[]\n    participant Prompt as getPrompt/text()\n    participant Ollama as Ollama API\n    participant Result as Strategy String\n\n    loop For each Training Range\n        loop For each Source (4 timeframes)\n            Demo->>Source: fetch(symbol, startDate, endDate, limit, offset)\n            Source->>Demo: data rows with indicators\n            Demo->>Format: arrayToMarkdownTable(data)\n            Format->>Demo: markdown table string\n            Demo->>Messages: Push user message (table + metadata)\n            Demo->>Messages: Push assistant message (acknowledgment)\n        end\n        Messages->>Prompt: Complete conversation history\n        Prompt->>Ollama: chat(model, messages, think: true)\n        Note over Ollama: System: \"Напиши торговую стратегию\"<br/>User: Multi-timeframe data (4 messages)<br/>User: \"На каких условиях купить?\"\n        Ollama->>Result: Strategy text (escaped)\n        Result->>Demo: strategyList.push({name, messages, strategy})\n    end\n```\n\n### Text Generation Function\n\nThe `text()` function implements the LLM call with specific system instructions:\n\n**Function:** [demo/optimization/src/index.mjs:312-359]()\n\n**Key Configuration:**\n- **Model**: `deepseek-v3.1:671b`\n- **Think Mode**: `true` (enables reasoning)\n- **System Messages**:\n  - Primary instruction: \"Напиши торговую стратегию где нет ничего лишнего\" (Write clean strategy)\n  - Reasoning level: \"high\"\n  - Output constraint: \"Не здоровайся, не говори что делаешь - только отчёт\" (No greetings, just report)\n\n**Final User Prompt:**\n```\nНа каких условиях мне купить {symbol}?\nДай анализ рынка на основе поддержки/сопротивления, точек входа в LONG/SHORT позиции.\nКакой RR ставить для позиций?\nПредпочтительны LONG или SHORT позиции?\n\nСделай не сухой технический, а фундаментальный анализ, содержащий стратигическую рекомендацию\n```\n\n### Response Processing\n\nThe LLM response is escaped to prevent code injection when inserted into generated templates:\n\n**Escaping Chain:** [demo/optimization/src/index.mjs:353-358]()\n```\ncontent.replace(/\\\\/g, \"\\\\\\\\\")    // Escape backslashes\n       .replace(/`/g, \"\\\\`\")       // Escape backticks\n       .replace(/\\$/g, \"\\\\$\")      // Escape dollar signs\n       .replace(/\"/g, '\\\\\"')       // Escape double quotes\n       .replace(/'/g, \"\\\\'\")       // Escape single quotes\n```\n\n**Sources:** [demo/optimization/src/index.mjs:312-359](), [src/interfaces/Optimizer.interface.ts:100-123]()\n\n---\n\n## Generated Code Structure\n\nThe optimizer generates a complete executable Node.js script containing all necessary components for strategy backtesting. The generated file follows a structured template system.\n\n### Code Generation Pipeline\n\n```mermaid\ngraph TB\n    DATA[\"IOptimizerStrategy[]<br/>From getData()\"]\n    PREFIX[\"Random Prefix<br/>CREATE_PREFIX_FN()<br/>e.g., 'x7k2q'\"]\n    \n    subgraph \"Template Methods (OptimizerTemplateService)\"\n        T1[\"getTopBanner<br/>Shebang + imports\"]\n        T2[\"getJsonDumpTemplate<br/>dumpJson() helper\"]\n        T3[\"getTextTemplate<br/>text() LLM function\"]\n        T4[\"getJsonTemplate<br/>json() LLM function\"]\n        T5[\"getExchangeTemplate<br/>addExchange + CCXT\"]\n        T6[\"getFrameTemplate<br/>addFrame for train/test\"]\n        T7[\"getStrategyTemplate<br/>addStrategy + getSignal\"]\n        T8[\"getWalkerTemplate<br/>addWalker config\"]\n        T9[\"getLauncherTemplate<br/>Walker.background + listeners\"]\n    end\n    \n    OUTPUT[\"Generated .mjs File<br/>{optimizerName}_{symbol}.mjs\"]\n    \n    DATA --> PREFIX\n    PREFIX --> T1\n    T1 --> T2\n    T2 --> T3\n    T3 --> T4\n    T4 --> T5\n    T5 --> T6\n    T6 --> T7\n    T7 --> T8\n    T8 --> T9\n    T9 --> OUTPUT\n    \n    T5 -.-> NAMES[\"Naming Convention<br/>{prefix}_exchange<br/>{prefix}_train_frame-{N}<br/>{prefix}_test_frame<br/>{prefix}_strategy-{N}<br/>{prefix}_walker\"]\n```\n\n### Generated File Sections\n\nThe generated code contains 9 distinct sections, concatenated with newlines:\n\n| Section | Template Method | Content | Lines Example |\n|---------|----------------|---------|---------------|\n| 1. Top Banner | `getTopBanner()` | Shebang, imports, constants | [src/lib/services/template/OptimizerTemplateService.ts:36-66]() |\n| 2. JSON Dump Helper | `getJsonDumpTemplate()` | `dumpJson()` function for debug output | [src/lib/services/template/OptimizerTemplateService.ts:452-546]() |\n| 3. Text Helper | `getTextTemplate()` | `text()` function for LLM text generation | [src/lib/services/template/OptimizerTemplateService.ts:555-612]() |\n| 4. JSON Helper | `getJsonTemplate()` | `json()` function for structured signal output | [src/lib/services/template/OptimizerTemplateService.ts:629-712]() |\n| 5. Exchange Config | `getExchangeTemplate()` | `addExchange()` with CCXT Binance | [src/lib/services/template/OptimizerTemplateService.ts:314-342]() |\n| 6. Frame Configs | `getFrameTemplate()` | Multiple `addFrame()` calls (train + test) | [src/lib/services/template/OptimizerTemplateService.ts:354-385]() |\n| 7. Strategy Configs | `getStrategyTemplate()` | Multiple `addStrategy()` with LLM integration | [src/lib/services/template/OptimizerTemplateService.ts:168-304]() |\n| 8. Walker Config | `getWalkerTemplate()` | `addWalker()` for strategy comparison | [src/lib/services/template/OptimizerTemplateService.ts:122-157]() |\n| 9. Launcher | `getLauncherTemplate()` | `Walker.background()` + event listeners | [src/lib/services/template/OptimizerTemplateService.ts:395-443]() |\n\n### Strategy Template Details\n\nThe strategy template is the most complex section, containing multi-timeframe candle fetching and LLM inference:\n\n**Structure:** [src/lib/services/template/OptimizerTemplateService.ts:168-304]()\n\n```javascript\naddStrategy({\n    strategyName: \"{prefix}_strategy-{N}\",\n    interval: \"5m\",\n    getSignal: async (symbol) => {\n        const messages = [];\n        \n        // Load candles for all timeframes\n        const microTermCandles = await getCandles(symbol, \"1m\", 30);\n        const mainTermCandles = await getCandles(symbol, \"5m\", 24);\n        const shortTermCandles = await getCandles(symbol, \"15m\", 24);\n        const mediumTermCandles = await getCandles(symbol, \"1h\", 24);\n        \n        // Build conversation with 4 user/assistant pairs (one per timeframe)\n        // ...push messages analyzing 1h, 15m, 5m, 1m data\n        \n        // Final prompt with strategy logic (from LLM-generated text)\n        messages.push({\n            role: \"user\",\n            content: [\n                \"Проанализируй все таймфреймы и сгенерируй торговый сигнал...\",\n                `{ESCAPED_STRATEGY_PROMPT}`,\n                \"Если сигналы противоречивы или тренд слабый то position: wait\"\n            ].join(\"\\\\n\"),\n        });\n        \n        // Call json() helper for structured output\n        const result = await json(messages);\n        \n        // Dump debug data and return signal\n        await dumpJson(resultId, messages, result);\n        return result;\n    },\n});\n```\n\n### Signal Schema\n\nThe `json()` helper uses a JSON schema to ensure structured signal output:\n\n**Schema Fields:** [src/lib/services/template/OptimizerTemplateService.ts:675-704]()\n\n| Field | Type | Enum/Range | Description |\n|-------|------|------------|-------------|\n| `position` | string | `\"wait\"` \\| `\"long\"` \\| `\"short\"` | Trade decision |\n| `note` | string | - | Strategy explanation |\n| `priceOpen` | number | > 0 | Entry price (market or limit) |\n| `priceTakeProfit` | number | > 0 | Target exit price |\n| `priceStopLoss` | number | > 0 | Stop loss price |\n| `minuteEstimatedTime` | number | 0-360 | Expected duration to TP |\n\n**Sources:** [src/lib/services/template/OptimizerTemplateService.ts:1-716](), [src/client/ClientOptimizer.ts:217-350]()\n\n---\n\n## Environment Configuration\n\nThe demo requires two environment variables for external service integration:\n\n### Required Variables\n\n```bash\nOLLAMA_API_KEY=your_ollama_api_key_here\nCCXT_DUMPER_URL=http://your-ccxt-dumper-url:port\n```\n\n**`OLLAMA_API_KEY`**:\n- Used for authentication with Ollama hosted API\n- Injected in Authorization header: `Bearer ${process.env.OLLAMA_API_KEY}`\n- Required for `text()` function calls to `https://ollama.com`\n- **Usage:** [demo/optimization/src/index.mjs:316]()\n\n**`CCXT_DUMPER_URL`**:\n- Base URL for CCXT Dumper API endpoints\n- Used to construct view URLs: `${CCXT_DUMPER_URL}/view/{source-name}`\n- Provides pre-calculated technical indicators for multiple timeframes\n- **Usage:** [demo/optimization/src/index.mjs:71](), [demo/optimization/src/index.mjs:129](), [demo/optimization/src/index.mjs:186](), [demo/optimization/src/index.mjs:241]()\n\n### CCXT Dumper Integration\n\nThe demo expects CCXT Dumper to expose four endpoints:\n\n```\nGET /view/long-term-range?symbol=BTCUSDT&startDate=1732406400000&endDate=1732492799999&limit=1000&offset=0\nGET /view/swing-term-range?symbol=BTCUSDT&startDate=1732406400000&endDate=1732492799999&limit=1000&offset=0\nGET /view/short-term-range?symbol=BTCUSDT&startDate=1732406400000&endDate=1732492799999&limit=1000&offset=0\nGET /view/micro-term-range?symbol=BTCUSDT&startDate=1732406400000&endDate=1732492799999&limit=1000&offset=0\n```\n\n**Response Format:**\n```json\n{\n  \"rows\": [\n    {\n      \"id\": \"unique_row_id\",\n      \"timestamp\": 1732406400000,\n      \"rsi\": 45.67,\n      \"macd\": 12.34,\n      \"signal\": 10.23,\n      // ... other indicators\n    }\n  ]\n}\n```\n\n**Reference:** CCXT Dumper API documented at [https://github.com/tripolskypetr/node-ccxt-dumper](https://github.com/tripolskypetr/node-ccxt-dumper)\n\n**Sources:** [demo/optimization/.env.example:1-3](), [demo/optimization/src/index.mjs:66-310]()\n\n---\n\n## Running the Demo\n\n### Prerequisites\n\n1. Install dependencies in demo directory:\n   ```bash\n   cd demo/optimization\n   npm install\n   ```\n\n2. Create `.env` file with required variables:\n   ```bash\n   cp .env.example .env\n   # Edit .env with your API keys\n   ```\n\n3. Ensure CCXT Dumper service is running and accessible\n\n### Execution\n\n**Command:**\n```bash\nnpm start\n```\n\n**Execution Flow:** [demo/optimization/src/index.mjs:361-399]()\n\n1. **Registration**: `addOptimizer()` registers optimizer configuration with 7 training ranges, 4 data sources, and LLM prompt generation\n2. **Progress Monitoring**: `listenOptimizerProgress()` logs completion percentage\n3. **Code Generation**: `Optimizer.dump()` executes the full pipeline:\n   - Fetch data from all sources for each training range\n   - Build LLM conversation history\n   - Generate strategy prompts via Ollama\n   - Produce executable code using templates\n   - Write to `./generated/btc-optimizer_BTCUSDT.mjs`\n\n### Progress Output\n\n```\nProgress: 0%\nProgress: 3.57%\nProgress: 7.14%\n...\nProgress: 100%\n```\n\n**Progress Calculation:** [src/client/ClientOptimizer.ts:102-114]()\n```\nprogress = processedSources / totalSources\ntotalSources = rangeTrain.length × source.length\n            = 7 training ranges × 4 sources\n            = 28 total data fetches\n```\n\n### Generated Output Location\n\n**File Path:** `./generated/btc-optimizer_BTCUSDT.mjs`\n\n**File Structure:**\n- Executable Node.js script with shebang `#!/usr/bin/env node`\n- Complete standalone file with all dependencies imported\n- Can be executed directly after generation\n\n**Alternative Operations:**\n\nCommented code in [demo/optimization/src/index.mjs:385-398]() shows how to retrieve strategy data without code generation:\n\n```javascript\nawait Optimizer.getData(\"BTCUSDT\", {\n  optimizerName: \"btc-optimizer\",\n}).then((list) =>\n  fs.writeFile(\n    \"./strategy_list.json\",\n    JSON.stringify(\n      list.map(({ strategy }) => strategy),\n      null,\n      2\n    )\n  )\n);\n```\n\nThis extracts only the LLM-generated strategy text for inspection without generating full executable code.\n\n**Sources:** [demo/optimization/src/index.mjs:361-399](), [src/classes/Optimizer.ts:100-120]()\n\n---\n\n## Debug Output and Logging\n\nThe generated strategy code includes debug output capabilities via the `dumpJson()` helper function. This creates detailed logs of LLM interactions for analysis and troubleshooting.\n\n### Debug Directory Structure\n\n```\n./dump/strategy/\n└── {resultId}/\n    ├── 00_system_prompt.md\n    ├── 01_user_message.md\n    ├── 02_user_message.md\n    ├── 03_user_message.md\n    ├── 04_user_message.md\n    └── 05_llm_output.md\n```\n\n### Debug File Contents\n\n| File | Content | Purpose |\n|------|---------|---------|\n| `00_system_prompt.md` | System messages + output data JSON | Shows system instructions and final signal result |\n| `0X_user_message.md` | User input markdown with timestamp | Documents each timeframe analysis request |\n| `05_llm_output.md` | Final LLM response JSON | Shows the structured signal output |\n\n**Template Implementation:** [src/lib/services/template/OptimizerTemplateService.ts:452-546]()\n\n### Size Warning System\n\nThe `dumpJson()` function includes size monitoring to warn about large messages that may impact LLM performance:\n\n**Warning Logic:** [src/lib/services/template/OptimizerTemplateService.ts:507-515]()\n```javascript\nconst messageSizeBytes = Buffer.byteLength(message.content, \"utf8\");\nconst messageSizeKb = Math.floor(messageSizeBytes / 1024);\nif (messageSizeKb > WARN_KB) {  // WARN_KB = 100\n    console.warn(\n        `User message ${idx + 1} is ${messageSizeBytes} bytes (${messageSizeKb}kb), \n         which exceeds warning limit`\n    );\n}\n```\n\n### Progress Events\n\nThe optimizer emits progress events during data collection, allowing real-time monitoring:\n\n**Event Contract:** [src/contract/ProgressOptimizer.contract.ts:17-28]()\n\n```typescript\ninterface ProgressOptimizerContract {\n    optimizerName: string;     // \"btc-optimizer\"\n    symbol: string;            // \"BTCUSDT\"\n    totalSources: number;      // 28 (7 ranges × 4 sources)\n    processedSources: number;  // Current count\n    progress: number;          // 0.0 to 1.0\n}\n```\n\n**Emission Points:** [src/client/ClientOptimizer.ts:108-114](), [src/client/ClientOptimizer.ts:201-208]()\n\nProgress events are emitted:\n1. At the start of processing each source\n2. After completing all sources (100%)\n\n**Sources:** [src/lib/services/template/OptimizerTemplateService.ts:452-546](), [src/contract/ProgressOptimizer.contract.ts:1-31](), [src/client/ClientOptimizer.ts:99-215]()"
                    },
                    {
                        "page_plan": {
                            "id": "10.2",
                            "title": "Running Demos"
                        },
                        "content": "# Running Demos\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/.env.example](demo/optimization/.env.example)\n- [demo/optimization/.gitignore](demo/optimization/.gitignore)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [demo/optimization/src/index.mjs](demo/optimization/src/index.mjs)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [src/contract/ProgressOptimizer.contract.ts](src/contract/ProgressOptimizer.contract.ts)\n- [src/interfaces/Heatmap.interface.ts](src/interfaces/Heatmap.interface.ts)\n- [test/e2e/defend.test.mjs](test/e2e/defend.test.mjs)\n- [test/e2e/risk.test.mjs](test/e2e/risk.test.mjs)\n- [test/index.mjs](test/index.mjs)\n- [test/mock/getMockCandles.mjs](test/mock/getMockCandles.mjs)\n- [test/spec/heat.test.mjs](test/spec/heat.test.mjs)\n- [test/spec/list.test.mjs](test/spec/list.test.mjs)\n\n</details>\n\n\n\nThis page explains how to set up, configure, and execute the demo applications included in the backtest-kit repository. The demos showcase different execution modes and integration patterns. For detailed information about execution mode internals, see [Execution Modes (Detailed)](#5). For LLM-based strategy generation theory, see [Optimizer Mode](#5.4).\n\n---\n\n## Demo Projects Overview\n\nThe repository includes three demonstration projects, each illustrating a different use case of the framework:\n\n| Demo | Purpose | Mode | Key Features |\n|------|---------|------|--------------|\n| **optimization** | LLM strategy generation | Optimizer | Ollama integration, multi-timeframe analysis, code export |\n| **backtest** | Historical simulation | Backtest | Fast candle processing, statistics generation |\n| **live** | Real-time trading | Live | Crash-safe persistence, continuous execution |\n\n### Directory Structure\n\n```\ndemo/\n├── optimization/\n│   ├── package.json\n│   ├── .env.example\n│   ├── .gitignore\n│   └── src/\n│       └── index.mjs\n├── backtest/\n│   ├── package.json\n│   └── src/\n│       └── index.mjs\n└── live/\n    ├── package.json\n    └── src/\n        └── index.mjs\n```\n\n**Sources**: [demo/optimization/package.json:1-18](), [demo/backtest/package.json:1-18](), [demo/live/package.json:1-18]()\n\n---\n\n## Demo Dependency Architecture\n\n```mermaid\ngraph TB\n    subgraph \"Demo Applications\"\n        OPT[\"optimization demo<br/>demo/optimization/src/index.mjs\"]\n        BT[\"backtest demo<br/>demo/backtest/src/index.mjs\"]\n        LV[\"live demo<br/>demo/live/src/index.mjs\"]\n    end\n    \n    subgraph \"Core Dependencies\"\n        BTKIT[\"backtest-kit@1.5.20<br/>Main framework\"]\n        CCXT[\"ccxt@4.5.24<br/>Exchange connector\"]\n        FUNC[\"functools-kit@1.0.94<br/>Utility functions\"]\n        UUID[\"uuid@13.0.0<br/>ID generation\"]\n        OLLAMA[\"ollama@0.6.3<br/>LLM client\"]\n    end\n    \n    subgraph \"Development Dependencies\"\n        DOTENV[\"dotenv-cli@11.0.0<br/>Environment loader\"]\n    end\n    \n    subgraph \"External Services\"\n        OLLAMA_SRV[\"Ollama API<br/>LLM inference\"]\n        DUMPER[\"CCXT Dumper Service<br/>Historical data\"]\n        EXCHANGES[\"Exchange APIs<br/>Market data\"]\n    end\n    \n    OPT --> BTKIT\n    OPT --> CCXT\n    OPT --> FUNC\n    OPT --> UUID\n    OPT --> OLLAMA\n    OPT --> DOTENV\n    \n    BT --> BTKIT\n    BT --> CCXT\n    BT --> FUNC\n    BT --> UUID\n    BT --> OLLAMA\n    BT --> DOTENV\n    \n    LV --> BTKIT\n    LV --> CCXT\n    LV --> FUNC\n    LV --> UUID\n    LV --> OLLAMA\n    LV --> DOTENV\n    \n    OLLAMA --> OLLAMA_SRV\n    OPT --> DUMPER\n    CCXT --> EXCHANGES\n    \n    style BTKIT fill:#e1f5ff,stroke:#333,stroke-width:3px\n    style OPT fill:#ffe1e1,stroke:#333,stroke-width:2px\n```\n\n**Sources**: [demo/optimization/package.json:8-17](), [demo/backtest/package.json:8-17](), [demo/live/package.json:8-17]()\n\n---\n\n## Installation and Setup\n\n### Step 1: Navigate to Demo Directory\n\n```bash\ncd demo/optimization  # or demo/backtest or demo/live\n```\n\n### Step 2: Install Dependencies\n\n```bash\nnpm install\n```\n\nThis installs the following packages as specified in [demo/optimization/package.json:8-14]():\n\n| Package | Version | Purpose |\n|---------|---------|---------|\n| `backtest-kit` | 1.5.20 | Core framework |\n| `ccxt` | 4.5.24 | Exchange data fetching |\n| `functools-kit` | 1.0.94 | Async utilities, Subject pattern |\n| `ollama` | 0.6.3 | LLM API client |\n| `uuid` | 13.0.0 | Signal ID generation |\n| `dotenv-cli` | 11.0.0 | Environment variable loading (dev) |\n\n### Step 3: Configure Environment\n\nCreate `.env` file from template:\n\n```bash\ncp .env.example .env\n```\n\nEdit `.env` with required values:\n\n```bash\nOLLAMA_API_KEY=your_api_key_here\nCCXT_DUMPER_URL=http://localhost:3000\n```\n\n**Sources**: [demo/optimization/.env.example:1-2](), [demo/optimization/package.json:1-18]()\n\n---\n\n## Environment Configuration\n\n### Required Variables\n\n| Variable | Required For | Purpose | Example |\n|----------|-------------|---------|---------|\n| `OLLAMA_API_KEY` | optimization | Authentication for Ollama LLM API | `sk-...` |\n| `CCXT_DUMPER_URL` | optimization | Base URL for historical data service | `http://localhost:3000` |\n\n### CCXT Dumper Service\n\nThe optimization demo requires a running CCXT dumper service (referenced at [demo/optimization/src/index.mjs:64-82]()). This service provides historical candle data with pre-calculated technical indicators.\n\n**Expected API endpoints**:\n- `/view/long-term-range` - 1-hour candles with 48-hour lookback\n- `/view/swing-term-range` - 30-minute candles with 48-hour lookback  \n- `/view/short-term-range` - 15-minute candles\n- `/view/micro-term-range` - 1-minute candles with 1-hour lookback\n\n**Query parameters**:\n- `symbol`: Trading pair (e.g., \"BTCUSDT\")\n- `startDate`: Unix timestamp in milliseconds\n- `endDate`: Unix timestamp in milliseconds\n- `limit`: Maximum rows (default: 1000)\n- `offset`: Pagination offset (default: 0)\n\n**Response format**:\n```json\n{\n  \"rows\": [\n    {\n      \"timestamp\": 1234567890,\n      \"open\": 42000.5,\n      \"high\": 42100.2,\n      \"low\": 41900.0,\n      \"close\": 42050.8,\n      \"rsi_14\": 65.3,\n      \"macd\": 123.4,\n      \"...\": \"...\"\n    }\n  ]\n}\n```\n\n**Sources**: [demo/optimization/src/index.mjs:64-82](), [demo/optimization/src/index.mjs:66-123]()\n\n---\n\n## Running Demos\n\n### Optimization Demo Execution Flow\n\n```mermaid\ngraph TB\n    START[\"npm start<br/>demo/optimization\"]\n    \n    ENV[\"dotenv-cli loads .env<br/>OLLAMA_API_KEY<br/>CCXT_DUMPER_URL\"]\n    \n    EXEC[\"node src/index.mjs\"]\n    \n    subgraph \"Demo Initialization\"\n        ADD_OPT[\"addOptimizer call<br/>optimizerName<br/>sources array<br/>getPrompt callback\"]\n        \n        SOURCES[\"SOURCE_LIST definition<br/>4 data sources<br/>fetch + format functions\"]\n        \n        RANGES[\"TRAIN_RANGE array<br/>7 days training data<br/>TEST_RANGE object<br/>1 day test data\"]\n    end\n    \n    subgraph \"Execution Loop\"\n        OPT_RUN[\"Optimizer.run call<br/>symbol + optimizerName\"]\n        \n        FETCH[\"For each source:<br/>fetchApi from CCXT_DUMPER_URL<br/>arrayToMarkdownTable<br/>Format for LLM\"]\n        \n        LLM[\"Ollama API call<br/>deepseek-v3.1:671b model<br/>Generate strategy code\"]\n        \n        TEMPLATE[\"OptimizerTemplateService<br/>Merge LLM response<br/>Generate .mjs file\"]\n        \n        EMIT[\"progressOptimizerEmitter<br/>processedSources<br/>totalSources<br/>progress percentage\"]\n    end\n    \n    OUTPUT[\"Generated code output<br/>addExchange + addStrategy<br/>Walker.background calls\"]\n    \n    DUMP[\"Optimizer.dump<br/>Write to file system<br/>./{optimizerName}_{symbol}.mjs\"]\n    \n    START --> ENV\n    ENV --> EXEC\n    EXEC --> ADD_OPT\n    ADD_OPT --> SOURCES\n    ADD_OPT --> RANGES\n    \n    SOURCES --> OPT_RUN\n    RANGES --> OPT_RUN\n    \n    OPT_RUN --> FETCH\n    FETCH --> LLM\n    LLM --> TEMPLATE\n    \n    FETCH --> EMIT\n    \n    TEMPLATE --> OUTPUT\n    OUTPUT --> DUMP\n    \n    style START fill:#e1f5ff,stroke:#333,stroke-width:3px\n    style LLM fill:#e8f5e9,stroke:#333,stroke-width:2px\n    style OUTPUT fill:#fff4e1,stroke:#333,stroke-width:2px\n```\n\n**Sources**: [demo/optimization/package.json:6](), [demo/optimization/src/index.mjs:1-4](), [demo/optimization/src/index.mjs:19-61](), [demo/optimization/src/index.mjs:66-123]()\n\n---\n\n## Running Commands\n\n### Optimization Demo\n\n```bash\ncd demo/optimization\nnpm start\n```\n\n**Execution**: [demo/optimization/package.json:6]()\n- Loads environment from `.env` via `dotenv-cli`\n- Executes `node ./src/index.mjs`\n- Connects to Ollama API for LLM inference\n- Fetches multi-timeframe historical data from CCXT Dumper\n- Generates strategy code via LLM\n- Exports executable `.mjs` file\n\n**Expected output**:\n- Progress updates: `Progress: 25.00%` (one per data source)\n- Generated strategy code printed to console\n- File written: `./{optimizerName}_{symbol}.mjs`\n\n### Backtest Demo\n\n```bash\ncd demo/backtest\nnpm start\n```\n\n**Execution**: [demo/backtest/package.json:6]()\n- Loads environment from `.env`\n- Executes `node ./src/index.mjs`\n- Runs backtest with historical candle iteration\n- Generates performance statistics\n- Outputs markdown reports\n\n**Expected output**:\n- Signal events: `opened`, `closed` with PNL\n- Backtest completion event with statistics\n- Markdown report in `./dump/` directory\n\n### Live Demo\n\n```bash\ncd demo/live\nnpm start\n```\n\n**Execution**: [demo/live/package.json:6]()\n- Loads environment from `.env`\n- Executes `node ./src/index.mjs`\n- Runs infinite loop with 61-second tick interval\n- Persists state to JSON files after each tick\n- Monitors positions until closed\n\n**Expected output**:\n- Live tick events every 61 seconds\n- Signal lifecycle events: `opened`, `active`, `closed`\n- Persistence confirmations\n- Graceful shutdown on Ctrl+C\n\n**Sources**: [demo/optimization/package.json:6](), [demo/backtest/package.json:6](), [demo/live/package.json:6]()\n\n---\n\n## Optimization Demo Source Structure\n\n### Data Source Configuration\n\nThe optimization demo defines four data sources at [demo/optimization/src/index.mjs:66-298](), each with specific parameters:\n\n```mermaid\ngraph LR\n    subgraph \"SOURCE_LIST Array\"\n        SRC1[\"long-term-range<br/>1h candles<br/>48h lookback<br/>RSI/MACD/ADX/ATR<br/>Bollinger/Stoch/Fib\"]\n        \n        SRC2[\"swing-term-range<br/>30m candles<br/>48h lookback<br/>RSI/MACD/Bollinger<br/>Volume/Volatility\"]\n        \n        SRC3[\"short-term-range<br/>15m candles<br/>RSI/MACD/CCI<br/>ROC/Support/Resistance\"]\n        \n        SRC4[\"micro-term-range<br/>1m candles<br/>1h lookback<br/>Fast indicators<br/>Histogram/Width\"]\n    end\n    \n    subgraph \"Each Source Object\"\n        NAME[\"name: string\"]\n        FETCH[\"fetch: async function<br/>symbol, startDate, endDate<br/>limit, offset\"]\n        USER[\"user: function<br/>symbol, data<br/>returns markdown\"]\n        ASSISTANT[\"assistant: function<br/>returns confirmation\"]\n    end\n    \n    SRC1 --> NAME\n    SRC1 --> FETCH\n    SRC1 --> USER\n    SRC1 --> ASSISTANT\n```\n\n**Sources**: [demo/optimization/src/index.mjs:66-298]()\n\n### Training and Test Ranges\n\nConfiguration at [demo/optimization/src/index.mjs:19-61]():\n\n**TRAIN_RANGE**: Array of 7 date ranges\n- November 24-30, 2025\n- Each range: `{ note, startDate, endDate }`\n- Used for historical data fetching\n\n**TEST_RANGE**: Single date range\n- December 1, 2025\n- Format: `{ note, startDate, endDate }`\n- Used for validation\n\n### Helper Functions\n\n**arrayToMarkdownTable** at [demo/optimization/src/index.mjs:6-17]():\n- Converts array of objects to markdown table\n- Auto-generates header from object keys\n- Formats separator and data rows\n- Used for LLM data presentation\n\n**Sources**: [demo/optimization/src/index.mjs:6-17](), [demo/optimization/src/index.mjs:19-61](), [demo/optimization/src/index.mjs:66-298]()\n\n---\n\n## Package.json Script Configuration\n\n### Script Definition Pattern\n\nAll three demos use identical script configuration at [demo/optimization/package.json:5-7]():\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"dotenv -e .env -- node ./src/index.mjs\"\n  }\n}\n```\n\n**Component breakdown**:\n- `dotenv`: CLI tool for loading environment variables\n- `-e .env`: Specifies environment file path\n- `--`: Separator between dotenv options and command\n- `node ./src/index.mjs`: Execute demo entry point\n\n### Module Type\n\nAll demos specify ES module mode at [demo/optimization/package.json:4]():\n\n```json\n{\n  \"type\": \"module\"\n}\n```\n\nThis enables:\n- `import`/`export` syntax instead of `require()`\n- Top-level `await` support\n- `.mjs` file execution\n- Async generator functions\n\n**Sources**: [demo/optimization/package.json:4-7](), [demo/backtest/package.json:4-7](), [demo/live/package.json:4-7]()\n\n---\n\n## Progress Monitoring\n\n### Optimizer Progress Events\n\nThe optimization demo emits progress events via `progressOptimizerEmitter` (see [Optimizer Mode](#5.4) for implementation details).\n\n**Listening to progress** at [demo/optimization/src/index.mjs:1]():\n\n```javascript\nimport { listenOptimizerProgress } from \"backtest-kit\";\n\nlistenOptimizerProgress((event) => {\n  console.log(`Processing: ${event.processedSources}/${event.totalSources}`);\n  console.log(`Progress: ${(event.progress * 100).toFixed(2)}%`);\n});\n```\n\n**Event payload structure**:\n- `optimizerName`: Name of optimizer being executed\n- `symbol`: Trading pair being analyzed\n- `totalSources`: Total number of data sources (4 in demo)\n- `processedSources`: Number of completed sources (0-4)\n- `progress`: Completion ratio from 0.0 to 1.0\n\n### Progress Calculation\n\nFor 4 sources:\n- Source 1 complete: `processedSources=1, progress=0.25`\n- Source 2 complete: `processedSources=2, progress=0.50`\n- Source 3 complete: `processedSources=3, progress=0.75`\n- Source 4 complete: `processedSources=4, progress=1.00`\n\n**Sources**: [demo/optimization/src/index.mjs:1](), [src/contract/ProgressOptimizer.contract.ts:1-31]()\n\n---\n\n## Common Issues and Solutions\n\n### Issue: \"Cannot find module 'backtest-kit'\"\n\n**Cause**: Dependencies not installed\n\n**Solution**:\n```bash\ncd demo/optimization  # or demo/backtest or demo/live\nnpm install\n```\n\n### Issue: \"OLLAMA_API_KEY is not defined\"\n\n**Cause**: Environment file not configured\n\n**Solution**:\n```bash\ncp .env.example .env\n# Edit .env with your API key\n```\n\n### Issue: \"Failed to fetch from CCXT_DUMPER_URL\"\n\n**Cause**: CCXT dumper service not running or wrong URL\n\n**Solution**:\n1. Start CCXT dumper service: `npm start` in dumper repo\n2. Verify URL in `.env` matches service port\n3. Test endpoint: `curl http://localhost:3000/view/long-term-range?symbol=BTCUSDT&startDate=...`\n\n### Issue: \"Ollama connection refused\"\n\n**Cause**: Ollama service not running\n\n**Solution**:\n```bash\n# Start Ollama service\nollama serve\n\n# Verify model is available\nollama list | grep deepseek\n```\n\n**Sources**: [demo/optimization/.env.example:1-2](), [demo/optimization/src/index.mjs:70-82]()\n\n---\n\n## Demo Project Comparison\n\n| Feature | Optimization | Backtest | Live |\n|---------|-------------|----------|------|\n| **Execution** | One-time code generation | Historical simulation | Infinite loop |\n| **Primary API** | `addOptimizer`, `Optimizer.run` | `Backtest.run`, `listenSignalBacktest` | `Live.run`, `listenSignalLive` |\n| **Duration** | Minutes (LLM inference time) | Seconds to minutes (data size) | Continuous until stopped |\n| **Output** | `.mjs` code file | Markdown reports, statistics | JSON persistence files, live events |\n| **External Deps** | Ollama API, CCXT Dumper | Exchange data (CCXT) | Exchange data (CCXT) |\n| **Data Source** | Pre-aggregated historical | Raw historical candles | Real-time candles |\n| **State** | Stateless | Stateless | Stateful (crash-safe) |\n| **Use Case** | Strategy discovery | Strategy validation | Production trading |\n\n**Sources**: [demo/optimization/src/index.mjs:1-4](), [demo/optimization/package.json:1-18](), [demo/backtest/package.json:1-18](), [demo/live/package.json:1-18]()"
                    }
                ]
            }
        },
        "default_language": "en"
    },
    "git_connection_type": "gitlab_oauth",
    "git_host": "gitlab.com"
}